"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("./index");
const chai_1 = require("chai");
class NodeData {
    constructor(id, name, version) {
        this.id = id;
        this.name = name;
        this.version = version;
    }
    stringify() {
        return JSON.stringify({ name: this.name, version: this.version });
    }
}
class EdgeData {
    constructor(dep, semDist) {
        this.dep = dep;
        this.semDist = semDist;
    }
    stringify() {
        return JSON.stringify({ dep: this.dep, semDist: this.semDist });
    }
}
describe('graphTester', () => {
    let nodeArr = [
        { id: 'a', node: new NodeData('a', 'comp1', '1.0.0') },
        { id: 'b', node: new NodeData('b', 'comp2', '2.0.0') },
        { id: 'c', node: new NodeData('c', 'comp3', '1.0.0') },
        { id: 'd', node: new NodeData('d', 'comp4', '15.0.0') },
        { id: 'e', node: new NodeData('e', 'comp5', '3.0.0') },
        { id: 'f', node: new NodeData('f', 'comp6', '2.0.0') },
        { id: 'g', node: new NodeData('g', 'comp7', '2.0.0') }
    ];
    let edgeArr = [
        { sourceId: 'a', targetId: 'b', edge: new EdgeData('peer', 3) },
        { sourceId: 'a', targetId: 'c', edge: new EdgeData('dev', 3) },
        { sourceId: 'c', targetId: 'd', edge: new EdgeData('regular', 3) },
        { sourceId: 'c', targetId: 'e', edge: new EdgeData('regular', 3) },
        { sourceId: 'd', targetId: 'f', edge: new EdgeData('peer', 1) },
        { sourceId: 'e', targetId: 'd', edge: new EdgeData('dev', 1) },
        { sourceId: 'g', targetId: 'a', edge: new EdgeData('dev', 1) }
    ];
    let g = new index_1.Graph(nodeArr, edgeArr);
    let h = new index_1.Graph();
    let i = new index_1.Graph();
    describe('basicTester', () => {
        it('should return node', () => {
            chai_1.expect(g.node("b")).to.deep.equal({ id: 'b', name: 'comp2', version: '2.0.0' });
        });
        it('should return undefined for missing node', () => {
            chai_1.expect(g.node("l")).to.be.undefined;
        });
        it('should return edge', () => {
            chai_1.expect(g.edge('a', 'b')).to.deep.equal({ dep: 'peer', semDist: 3 });
        });
        it('should return undefined for missing edge', () => {
            chai_1.expect(g.edge("l", "t")).to.be.undefined;
        });
        it('should return true for an existing edge', () => {
            chai_1.expect(g.hasEdge("c", "d")).to.be.true;
        });
        it('should return edge source and target Ids by edgeId', () => {
            const { sourceId, targetId } = g.edgeNodesById('a->b');
            chai_1.expect(sourceId).to.equal('a');
            chai_1.expect(targetId).to.equal('b');
        });
        it('should override existing node with same id', () => {
            var _a;
            const newNodes = [{ id: 'c', node: new NodeData('c', 'newNode', '1.0.0') }];
            chai_1.expect((_a = g.setNodes(newNodes).node('c')) === null || _a === void 0 ? void 0 : _a.name).to.equal('newNode');
            g.setNode('c', new NodeData('c', 'comp3', '1.0.0'));
        });
        it('should override existing edge with same source, target ids', () => {
            var _a;
            const newEdges = [{ sourceId: 'a', targetId: 'b', edge: new EdgeData('dev', 3) }];
            chai_1.expect((_a = g.setEdges(newEdges).edge('a', 'b')) === null || _a === void 0 ? void 0 : _a.dep).to.equal('dev');
            g.setEdge('a', 'b', new EdgeData('peer', 3));
        });
        it('should not override existing node with same id', () => {
            var _a;
            const newNodes = [{ id: 'c', node: new NodeData('c', 'newNode', '1.0.0') }];
            chai_1.expect((_a = g.setNodes(newNodes, false).node('c')) === null || _a === void 0 ? void 0 : _a.name).to.equal('comp3');
            g.setNode('c', new NodeData('c', 'comp3', '1.0.0'));
        });
        it('should not override existing edge with same source, target ids', () => {
            var _a;
            const newEdges = [{ sourceId: 'a', targetId: 'b', edge: new EdgeData('dev', 3) }];
            chai_1.expect((_a = g.setEdges(newEdges, false).edge('a', 'b')) === null || _a === void 0 ? void 0 : _a.dep).to.equal('peer');
            g.setEdge('a', 'b', new EdgeData('peer', 3));
        });
        it('should return all graph nodes as a map', () => {
            const keys = [...g.nodes.keys()];
            chai_1.expect(keys).to.deep.equal(['a', 'b', 'c', 'd', 'e', 'f', 'g']);
        });
        it('should return all graph edges as a map', () => {
            const keys = [...g.edges.keys()];
            chai_1.expect(keys).to.deep.equal(["a->b", "a->c", "c->d", "c->e", "d->f", "e->d", "g->a"]);
        });
        it('should return the correct node count', () => {
            chai_1.expect(g.nodeCount()).to.equal(7);
        });
        it('should return the correct edge count', () => {
            chai_1.expect(g.edgeCount()).to.equal(7);
        });
        it('should return all graph sources', () => {
            const res = g.sources();
            const ids = res.map(elem => elem ? elem.id : '');
            chai_1.expect(ids).to.deep.equal(['g']);
        });
        it('should return all graph sinks', () => {
            const res = g.sinks();
            const ids = res.map(elem => elem ? elem.id : '');
            chai_1.expect(ids).to.deep.equal(['b', 'f']);
        });
        it('should delete node', () => {
            g.setNode('h', new NodeData('h', 'comp8', '1.0.0'));
            chai_1.expect(g.nodeCount()).to.equal(8);
            g.deleteNode('h');
            chai_1.expect(g.nodeCount()).to.equal(7);
        });
        it('should delete edge', () => {
            g.setEdge('g', 'd', new EdgeData('dev', 1));
            chai_1.expect(g.edgeCount()).to.equal(8);
            g.deleteEdge('g', 'd');
            chai_1.expect(g.edgeCount()).to.equal(7);
        });
        it('should find all in edges of a given node', () => {
            const keys = [...g.inEdges('d').keys()];
            chai_1.expect(keys).to.deep.equal(['c->d', 'e->d']);
        });
        it('should find all out edges of a given node', () => {
            const keys = [...g.outEdges('a').keys()];
            chai_1.expect(keys).to.deep.equal(['a->b', 'a->c']);
        });
        it('should find all node edges of a given node', () => {
            const keys = [...g.nodeEdges('a').keys()];
            chai_1.expect(keys).to.deep.equal(['g->a', 'a->b', 'a->c']);
        });
        it('should find immediate successors of a given node', () => {
            const keys = [...g.successors('c').keys()];
            chai_1.expect(keys).to.deep.equal(['d', 'e']);
        });
        it('should find immediate predecessors of a given node', () => {
            const keys = [...g.predecessors('c').keys()];
            chai_1.expect(keys).to.deep.equal(['a']);
        });
        it('should find neighbors of a given node', () => {
            const keys = [...g.neighbors('c').keys()];
            chai_1.expect(keys).to.deep.equal(['a', 'd', 'e']);
        });
        it('should find recursive successors sub-graph of a given node', () => {
            const node = g.node('c');
            const subgraph = node ? g.successorsSubgraph(node.id) : new index_1.Graph();
            const nodeKeys = [...subgraph.nodes.keys()];
            const edgeKeys = [...subgraph.edges.keys()];
            chai_1.expect(nodeKeys).to.deep.equal(['c', 'd', 'f', 'e']);
            chai_1.expect(edgeKeys).to.deep.equal(['c->d', 'd->f', 'c->e', 'e->d']);
        });
        it('should find recursive successors sub-graph of two nodes where one is a successor of the other', () => {
            const node1 = g.node('a');
            const node2 = g.node('c');
            const subgraph = node1 && node2 ? g.successorsSubgraph([node1.id, node2.id]) : new index_1.Graph();
            const nodeKeys = [...subgraph.nodes.keys()];
            const edgeKeys = [...subgraph.edges.keys()];
            chai_1.expect(nodeKeys).to.deep.equal(['a', 'b', 'c', 'd', 'f', 'e']);
            chai_1.expect(edgeKeys).to.deep.equal(['a->b', 'a->c', 'c->d', 'd->f', 'c->e', 'e->d']);
        });
        it('should find recursive successors sub-graph of two nodes where one is *not* a successor of the other', () => {
            g.setNode('h', new NodeData('h', 'comp22', '1.0.0'));
            g.setEdge('b', 'h', new EdgeData('peer', 1));
            const node1 = g.node('b');
            const node2 = g.node('c');
            const subgraph = node1 && node2 ? g.successorsSubgraph([node1.id, node2.id]) : new index_1.Graph();
            const nodeKeys = [...subgraph.nodes.keys()];
            const edgeKeys = [...subgraph.edges.keys()];
            chai_1.expect(nodeKeys).to.deep.equal(["b", "h", "c", "d", "f", "e"]);
            chai_1.expect(edgeKeys).to.deep.equal(["b->h", "c->d", "d->f", "c->e", "e->d"]);
            g.deleteNode('h');
            g.deleteEdge('b', 'h');
        });
        it('should find recursive predecessors sub-graph of a given node', () => {
            const node = g.node('d');
            const subgraph = node ? g.predecessorsSubgraph(node.id) : new index_1.Graph();
            const nodeKeys = [...subgraph.nodes.keys()];
            const edgeKeys = [...subgraph.edges.keys()];
            chai_1.expect(nodeKeys).to.deep.equal(['d', 'c', 'a', 'g', 'e']);
            chai_1.expect(edgeKeys).to.deep.equal(["c->d", "a->c", "g->a", "e->d", "c->e"]);
        });
        it('should find recursive predecessors sub-graph of two nodes where one is a predecessor of the other', () => {
            const node1 = g.node('d');
            const node2 = g.node('c');
            const subgraph = node1 && node2 ? g.predecessorsSubgraph([node1.id, node2.id]) : new index_1.Graph();
            const nodeKeys = [...subgraph.nodes.keys()];
            const edgeKeys = [...subgraph.edges.keys()];
            chai_1.expect(nodeKeys).to.deep.equal(["d", "c", "a", "g", "e"]);
            chai_1.expect(edgeKeys).to.deep.equal(["c->d", "a->c", "g->a", "e->d", "c->e"]);
        });
        it('should find recursive predecessors sub-graph of two nodes where one is *not* a predecessor of the other', () => {
            g.setNode('h', new NodeData('h', 'comp22', '1.0.0'));
            g.setEdge('b', 'h', new EdgeData('peer', 1));
            const node1 = g.node('d');
            const node2 = g.node('h');
            const subgraph = node1 && node2 ? g.predecessorsSubgraph([node1.id, node2.id]) : new index_1.Graph();
            const nodeKeys = [...subgraph.nodes.keys()];
            const edgeKeys = [...subgraph.edges.keys()];
            chai_1.expect(nodeKeys).to.deep.equal(["d", "c", "a", "g", "e", "h", "b"]);
            chai_1.expect(edgeKeys).to.deep.equal(["c->d", "a->c", "g->a", "e->d", "c->e", "b->h", "a->b"]);
            g.deleteNode('h');
            g.deleteEdge('b', 'h');
        });
        it('should find recursive successors array of a given node', () => {
            const node = g.node('c');
            const arr = !!node ? g.successorsArray(node.id).map(elem => elem.id) : [];
            chai_1.expect(arr).to.deep.equal(['d', 'f', 'e']);
        });
        it('should find recursive predecessors array of a given node', () => {
            const node = g.node('d');
            const arr = !!node ? g.predecessorsArray(node.id).map(elem => elem.id) : [];
            chai_1.expect(arr).to.deep.equal(['c', 'a', 'g', 'e']);
        });
        it('should return all node successors recursively as layers - version 1', () => {
            chai_1.expect(g.successorsLayers('a')).to.deep.equal([["a"], ["b", "c"], ["e"], ["d"], ["f"]]);
        });
        it('should return all node successors recursively as layers - version 2', () => {
            let a = new index_1.Graph();
            a.setNode('a', new NodeData('a', 'comp1', '1.0.0'));
            a.setNode('b', new NodeData('b', 'comp2', '2.0.0'));
            a.setNode('c', new NodeData('c', 'comp3', '1.0.1'));
            a.setNode('d', new NodeData('d', 'comp4', '15.0.0'));
            a.setNode('e', new NodeData('e', 'comp5', '3.0.0'));
            a.setNode('f', new NodeData('f', 'comp6', '2.0.0'));
            a.setNode('g', new NodeData('g', 'comp7', '2.0.0'));
            a.setNode('h', new NodeData('h', 'comp8', '2.0.0'));
            a.setEdge('a', 'b', new EdgeData('peer', 3));
            a.setEdge('a', 'g', new EdgeData('peer', 3));
            a.setEdge('b', 'c', new EdgeData('dev', 3));
            a.setEdge('b', 'f', new EdgeData('regular', 2));
            a.setEdge('c', 'e', new EdgeData('regular', 3));
            a.setEdge('c', 'd', new EdgeData('peer', 3));
            a.setEdge('d', 'f', new EdgeData('dev', 3));
            a.setEdge('f', 'g', new EdgeData('dev', 3));
            a.setEdge('e', 'h', new EdgeData('dev', 1));
            chai_1.expect(a.successorsLayers('a')).to.deep.equal([["a"], ["b"], ["c"], ["e", "d"], ["h", "f"], ["g"]]);
        });
        it('should return all node successors recursively as layers with filter function', () => {
            chai_1.expect(g.successorsLayers('a', edgeFilterByDevDep)).to.deep.equal([['a'], ['c']]);
        });
        it('should return all node predecessors recursively as layers - version 1', () => {
            chai_1.expect(g.predecessorsLayers('d')).to.deep.equal([["d"], ["e"], ["c"], ["a"], ["g"]]);
        });
        it('should throw error for circular dependencies for successors as layers', () => {
            g.setEdge('f', 'a', new EdgeData('regular', 3));
            try {
                g.successorsLayers('a');
            }
            catch (e) {
                chai_1.expect(e.message).to.equal('cyclic dependency');
                g.deleteEdge('f', 'a');
                return;
            }
            g.deleteEdge('f', 'a');
            chai_1.expect.fail('should have thrown exception');
        });
        it('should perform topological sort on the graph', () => {
            const res = g.toposort();
            const ids = res.map(elem => elem ? elem.id : '');
            chai_1.expect(ids).to.deep.equal(['g', 'a', 'b', 'c', 'e', 'd', 'f']);
        });
        it('should perform topological sort on the graph and return reverse order', () => {
            const res = g.toposort(true);
            const ids = res.map(elem => elem ? elem.id : '');
            chai_1.expect(ids).to.deep.equal(['f', 'd', 'e', 'c', 'b', 'a', 'g']);
        });
        it('should perform topological sort on graph with unconnected components', () => {
            g.deleteEdge('g', 'a');
            const res = g.toposort();
            const ids = res.map(elem => elem ? elem.id : '');
            chai_1.expect(ids).to.deep.equal(['a', 'b', 'c', 'e', 'd', 'f', 'g']);
            g.setEdge('g', 'a', new EdgeData('dev', 1));
        });
        it('should throw cyclic dependencies error on topological sort given graph with cycles', () => {
            const f = function () { g.toposort(); };
            g.setEdge('f', 'g', new EdgeData('dev', 2));
            chai_1.expect(f).to.throw(index_1.CyclicError);
            g.deleteEdge('f', 'g');
        });
        it('should find all paths from one node to another', () => {
            g.setEdge('a', 'd', new EdgeData('dev', 2));
            g.setEdge('e', 'f', new EdgeData('dev', 2));
            chai_1.expect(g.allPaths('a', 'd')).to.deep.equal([
                ['a', 'c', 'd'],
                ['a', 'c', 'e', 'd'],
                ['a', 'd']
            ]);
            g.deleteEdge('a', 'd');
            g.deleteEdge('e', 'f');
        });
        it('should return all cycles in graph', () => {
            g.setEdge('f', 'g', new EdgeData('dev', 2));
            chai_1.expect(g.findCycles()).to.deep.equal([['e', 'g', 'f', 'd', 'c', 'a']]);
            g.deleteEdge('f', 'g');
        });
        it('should convert graph to json object', () => {
            const res = g.toJson();
            chai_1.expect(res.nodes.length).to.equal(7);
            chai_1.expect(res.edges.length).to.equal(7);
        });
        it('should build graph from JSON', () => {
            const json = {
                "nodes": [
                    { "id": 'a', "node": 'hello' },
                    { "id": 'b', node: 'world' }
                ],
                "edges": [
                    { "sourceId": 'a', "targetId": 'b', "edge": {} }
                ]
            };
            const newGraph = index_1.Graph.parse(JSON.stringify(json));
            chai_1.expect([...newGraph.nodes.keys()]).to.deep.equal(['a', 'b']);
            chai_1.expect([...newGraph.edges.keys()]).to.deep.equal(['a->b']);
        });
        before('creating graphs for merge', function () {
            console.log('before');
            h.setNode('a', new NodeData('a', 'comp17', '12.0.0'));
            h.setNode('h', new NodeData('h', 'comp20', '1.0.0'));
            h.setNode('i', new NodeData('i', 'comp11', '3.0.0'));
            h.setEdge('a', 'h', new EdgeData('peer', 3));
            h.setEdge('i', 'h', new EdgeData('dev', 2));
            i.setNode('a', new NodeData('a', 'comp34', '3.0.0'));
            i.setNode('j', new NodeData('j', 'comp53', '1.0.0'));
            i.setEdge('j', 'a', new EdgeData('peer', 1));
        });
        it('should merge graphs', () => {
            const res = g.merge([h, i]);
            chai_1.expect(res.nodes.size).to.equal(10);
            chai_1.expect(res.edges.size).to.equal(10);
            chai_1.expect(res.edges.has('i->h')).to.be.true;
        });
    });
});
function nodeFilterPredicateVersion(nodeData) {
    return (nodeData.version === '2.0.0');
}
function nodeFilterPredicateComp(nodeData) {
    return (nodeData.id === 'comp2');
}
function edgeFilterByRegularDep(edgeData) {
    return (edgeData.dep === 'regular');
}
function edgeFilterByDevDep(edgeData) {
    return (edgeData.dep === 'dev');
}
function edgeFilterByPeerDep(edgeData) {
    return (edgeData.dep === 'peer');
}
function edgeFilterByPeerOrDevDep(edgeData) {
    return (edgeData.dep === 'peer' || edgeData.dep === 'dev');
}
//# sourceMappingURL=graph.spec.js.map