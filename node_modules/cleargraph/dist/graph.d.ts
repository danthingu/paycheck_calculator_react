import { GraphNode, NodeId } from './index';
import { GraphEdge, EdgeId } from './index';
export declare class Graph<N, E> {
    constructor(nodes?: {
        id: string;
        node: N;
    }[], edges?: {
        sourceId: string;
        targetId: string;
        edge: E;
    }[]);
    private _nodes;
    private _edges;
    get _userNodes(): Map<NodeId, N>;
    get _userEdges(): Map<EdgeId, E>;
    _transformToUserNodeMap(map: Map<NodeId, GraphNode<N>>): Map<NodeId, N>;
    _transformToUserEdgeMap(map: Map<EdgeId, GraphEdge<E>>): Map<EdgeId, E>;
    setNode(id: string, node: N, overrideExisting?: boolean): Graph<N, E>;
    setEdge(sourceId: string, targetId: string, edge: E, overrideExisting?: boolean): Graph<N, E>;
    setNodes(nodes: {
        id: string;
        node: N;
    }[], overrideExisting?: boolean): Graph<N, E>;
    setEdges(edges: {
        sourceId: string;
        targetId: string;
        edge: E;
    }[], overrideExisting?: boolean): Graph<N, E>;
    hasNode(id: NodeId): boolean;
    hasEdge(sourceId: NodeId, targetId: NodeId): boolean;
    node(id: NodeId): N | undefined;
    edge(sourceId: string, targetId: string): E | undefined;
    _node(id: NodeId): GraphNode<N> | undefined;
    _edge(sourceId: string, targetId: string): GraphEdge<E> | undefined;
    _edgeById(edgeId: string): GraphEdge<E> | undefined;
    edgeNodesById(edgeId: EdgeId): {
        sourceId: string | undefined;
        targetId: string | undefined;
    };
    get nodes(): Map<NodeId, N>;
    get edges(): Map<EdgeId, E>;
    nodeCount(): number;
    edgeCount(): number;
    sources(): N[];
    sinks(): N[];
    deleteNode(id: NodeId): void;
    deleteEdge(sourceId: string, targetId: string): void;
    inEdges(nodeId: NodeId): Map<EdgeId, E>;
    outEdges(nodeId: NodeId): Map<EdgeId, E>;
    nodeEdges(nodeId: NodeId): Map<EdgeId, E>;
    _inEdges(nodeId: NodeId): Map<EdgeId, GraphEdge<E>>;
    _outEdges(nodeId: NodeId): Map<EdgeId, GraphEdge<E>>;
    _nodeEdges(nodeId: NodeId): Map<EdgeId, GraphEdge<E>>;
    successors(nodeId: NodeId, filterPredicate?: (edge: E) => boolean): Map<NodeId, N>;
    predecessors(nodeId: NodeId, filterPredicate?: (edge: E) => boolean): Map<NodeId, N>;
    neighbors(nodeId: NodeId, filterPredicate?: (edge: E) => boolean): Map<NodeId, N>;
    _successors(nodeId: NodeId, filterPredicate?: (edge: E) => boolean): Map<NodeId, GraphNode<N>>;
    _predecessors(nodeId: NodeId, filterPredicate?: (edge: E) => boolean): Map<NodeId, GraphNode<N>>;
    _neighbors(nodeId: NodeId, filterPredicate?: (edge: E) => boolean): Map<NodeId, GraphNode<N>>;
    successorsSubgraph(nodeIds: NodeId | NodeId[], filterPredicate?: (edge: E) => boolean): Graph<N, E>;
    _alreadyProcessed(nodeId: NodeId, subgraphs: Graph<N, E>[]): boolean;
    _buildSubgraphs(nodeIds: NodeId | NodeId[], filterPredicate: (edge: E) => boolean, order: 'successors' | 'predecessors'): Graph<N, E>;
    _buildSubgraph(nodeId: NodeId, filterPredicate: (edge: E) => boolean, order: 'successors' | 'predecessors'): Graph<N, E>;
    _successorsSubgraphUtil(nodeId: NodeId, successorsGraph: Graph<N, E>, visited: {
        [key: string]: boolean;
    } | undefined, filterPredicate: (data: E) => boolean): Graph<N, E>;
    successorsArray(nodeId: NodeId, filterPredicate?: (data: E) => boolean): N[];
    _successorsArrayUtil(nodeId: string, successorsList?: string[], visited?: {
        [key: string]: boolean;
    }, filterPredicate?: (data: E) => boolean): NodeId[];
    successorsLayers(nodeKey: string, filterPredicate?: (data: E) => boolean, order?: 'fromSource' | 'fromLastLeaf'): string[][] | never;
    private _successorsLayersUtil;
    predecessorsSubgraph(nodeIds: NodeId | NodeId[], filterPredicate?: (edge: E) => boolean): Graph<N, E>;
    _predecessorsSubgraphUtil(nodeId: NodeId, predecessorsGraph: Graph<N, E>, visited?: {
        [key: string]: boolean;
    }, filterPredicate?: (data: E) => boolean): Graph<N, E>;
    predecessorsArray(nodeId: NodeId, filterPredicate?: (data: E) => boolean): N[];
    _predecessorsArrayUtil(nodeId: string, predecessorsList?: string[], visited?: {
        [key: string]: boolean;
    }, filterPredicate?: (data: E) => boolean): NodeId[];
    predecessorsLayers(nodeKey: string, filterPredicate?: (data: E) => boolean, order?: 'fromSource' | 'fromLastLeaf'): string[][] | never;
    private _predecessorsLayersUtil;
    toposort(reverse?: boolean): N[];
    _transformEdges(): string[][];
    _toposort(): any[];
    isCyclic(graph?: Graph<N, E>): boolean;
    findCycles(graph?: Graph<N, E>): (number | ((...items: never[]) => number) | (() => undefined) | (() => string) | {
        (...items: ConcatArray<never>[]): never[];
        (...items: ConcatArray<never>[]): never[];
    } | ((searchElement: never, fromIndex?: number | undefined) => number) | ((searchElement: never, fromIndex?: number | undefined) => number) | ((start?: number | undefined, end?: number | undefined) => never[]) | ((searchElement: never, fromIndex?: number | undefined) => boolean) | (() => string) | ((callbackfn: (value: never, index: number, array: never[]) => void, thisArg?: any) => void) | ((separator?: string | undefined) => string) | (() => never[]) | (() => undefined) | ((compareFn?: ((a: never, b: never) => number) | undefined) => never[]) | {
        (start: number, deleteCount?: number | undefined): never[];
        (start: number, deleteCount: number, ...items: never[]): never[];
    } | ((...items: never[]) => number) | ((callbackfn: (value: never, index: number, array: never[]) => unknown, thisArg?: any) => boolean) | ((callbackfn: (value: never, index: number, array: never[]) => unknown, thisArg?: any) => boolean) | (<U>(callbackfn: (value: never, index: number, array: never[]) => U, thisArg?: any) => U[]) | {
        <S extends never>(callbackfn: (value: never, index: number, array: never[]) => value is S, thisArg?: any): S[];
        (callbackfn: (value: never, index: number, array: never[]) => unknown, thisArg?: any): never[];
    } | {
        (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: never[]) => never): never;
        (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: never[]) => never, initialValue: never): never;
        <U_1>(callbackfn: (previousValue: U_1, currentValue: never, currentIndex: number, array: never[]) => U_1, initialValue: U_1): U_1;
    } | {
        (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: never[]) => never): never;
        (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: never[]) => never, initialValue: never): never;
        <U_2>(callbackfn: (previousValue: U_2, currentValue: never, currentIndex: number, array: never[]) => U_2, initialValue: U_2): U_2;
    } | {
        <S_1 extends never>(predicate: (this: void, value: never, index: number, obj: never[]) => value is S_1, thisArg?: any): S_1 | undefined;
        (predicate: (value: never, index: number, obj: never[]) => unknown, thisArg?: any): undefined;
    } | ((predicate: (value: never, index: number, obj: never[]) => unknown, thisArg?: any) => number) | ((value: never, start?: number | undefined, end?: number | undefined) => never[]) | ((target: number, start: number, end?: number | undefined) => never[]) | (() => IterableIterator<[number, never]>) | (() => IterableIterator<number>) | (() => IterableIterator<never>) | (<U_3, This = undefined>(callback: (this: This, value: never, index: number, array: never[]) => U_3 | readonly U_3[], thisArg?: This | undefined) => U_3[]) | {
        <U_4>(this: U_4[][][][][][][][], depth: 7): U_4[];
        <U_5>(this: U_5[][][][][][][], depth: 6): U_5[];
        <U_6>(this: U_6[][][][][][], depth: 5): U_6[];
        <U_7>(this: U_7[][][][][], depth: 4): U_7[];
        <U_8>(this: U_8[][][][], depth: 3): U_8[];
        <U_9>(this: U_9[][][], depth: 2): U_9[];
        <U_10>(this: U_10[][], depth?: 1 | undefined): U_10[];
        <U_11>(this: U_11[], depth: 0): U_11[];
        <U_12>(depth?: number | undefined): any[];
    })[];
    merge(graphs: Graph<N, E>[]): Graph<N, E>;
    allPaths(sourceId: NodeId, targetId: NodeId): NodeId[][];
    _allPaths(source: NodeId, target: NodeId, currPath: NodeId[], paths: NodeId[][], visited?: {
        [key: string]: boolean;
    }): string[][];
    toJson(graph?: Graph<N, E>): any;
    stringify(graph?: Graph<N, E>): string;
    static parse(json: string | object, parseNode?: (data: any) => any, parseEdge?: (data: any) => any): Graph<unknown, unknown>;
    _toJson(graph: Graph<any, any>, returnType: 'object' | 'string'): any;
    static _fromJson(json: string | object, parseNode: (data: any) => any, parseEdge: (data: any) => any): Graph<unknown, unknown>;
    bfs(): void;
    dfs(): void;
}
