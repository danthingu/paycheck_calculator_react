"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("./index");
const index_2 = require("./index");
const index_3 = require("./index");
const lodash_1 = __importDefault(require("lodash"));
const algorithms_1 = require("./algorithms");
const node_1 = require("./node");
const edge_1 = require("./edge");
class Graph {
    constructor(nodes = [], edges = []) {
        this._nodes = new Map();
        this._edges = new Map();
        nodes.forEach(elem => this.setNode(elem.id, elem.node));
        edges.forEach(elem => this.setEdge(elem.sourceId, elem.targetId, elem.edge));
    }
    get _userNodes() {
        return this._transformToUserNodeMap(this._nodes);
    }
    get _userEdges() {
        return this._transformToUserEdgeMap(this._edges);
    }
    _transformToUserNodeMap(map) {
        let newMap = new Map();
        for (const [key, value] of map.entries()) {
            newMap.set(key, value.attr);
        }
        ;
        return newMap;
    }
    _transformToUserEdgeMap(map) {
        let newMap = new Map();
        for (const [key, value] of map.entries()) {
            newMap.set(key, value.attr);
        }
        ;
        return newMap;
    }
    setNode(id, node, overrideExisting = true) {
        if (!this.hasNode(id)) {
            let graphNode = new index_1.GraphNode(id, node);
            this._nodes.set(id, graphNode);
        }
        else if (overrideExisting) {
            let existingNode = this._node(id);
            if (existingNode) {
                existingNode.attr = node;
            }
        }
        return this;
    }
    setEdge(sourceId, targetId, edge, overrideExisting = true) {
        if (this.hasEdge(sourceId, targetId)) {
            if (overrideExisting) {
                let existingEdge = this._edge(sourceId, targetId);
                if (existingEdge) {
                    existingEdge.attr = edge;
                }
                ;
                return this;
            }
            else {
                return this;
            }
        }
        const id = index_2.GraphEdge.edgeId(sourceId, targetId);
        let graphEdge = new index_2.GraphEdge(sourceId, targetId, edge);
        this._edges.set(id, graphEdge);
        if (this._nodes.has(sourceId)) {
            let sourceNode = this._nodes.get(sourceId);
            if (sourceNode !== undefined) {
                sourceNode.setOutEdge(id);
            }
        }
        else {
            throw Error('source node does not exist');
        }
        if (this._nodes.has(targetId)) {
            let targetNode = this._nodes.get(targetId);
            if (targetNode !== undefined) {
                targetNode.setInEdge(id);
            }
        }
        else {
            throw Error('target node does not exist');
        }
        return this;
    }
    setNodes(nodes, overrideExisting = true) {
        nodes.forEach(elem => {
            if (!this.hasNode(elem.id)) {
                this.setNode(elem.id, elem.node);
            }
            else if (overrideExisting) {
                let existingNode = this._node(elem.id);
                if (existingNode) {
                    existingNode.attr = elem.node;
                }
            }
        });
        return this;
    }
    setEdges(edges, overrideExisting = true) {
        edges.forEach(elem => {
            if (!this.hasEdge(elem.sourceId, elem.targetId)) {
                this.setEdge(elem.sourceId, elem.targetId, elem.edge);
            }
            else if (overrideExisting) {
                let existingEdge = this._edge(elem.sourceId, elem.targetId);
                if (existingEdge) {
                    existingEdge.attr = elem.edge;
                }
            }
        });
        return this;
    }
    hasNode(id) {
        return this._nodes.has(id);
    }
    hasEdge(sourceId, targetId) {
        return this._edges.has(index_2.GraphEdge.edgeId(sourceId, targetId));
    }
    node(id) {
        var _a;
        return (_a = this._nodes.get(id)) === null || _a === void 0 ? void 0 : _a.attr;
    }
    edge(sourceId, targetId) {
        var _a;
        return (_a = this._edges.get(index_2.GraphEdge.edgeId(sourceId, targetId))) === null || _a === void 0 ? void 0 : _a.attr;
    }
    _node(id) {
        return this._nodes.get(id);
    }
    _edge(sourceId, targetId) {
        return this._edges.get(index_2.GraphEdge.edgeId(sourceId, targetId));
    }
    _edgeById(edgeId) {
        return this._edges.get(edgeId);
    }
    edgeNodesById(edgeId) {
        var _a, _b;
        return {
            sourceId: (_a = this._edges.get(edgeId)) === null || _a === void 0 ? void 0 : _a.sourceId,
            targetId: (_b = this._edges.get(edgeId)) === null || _b === void 0 ? void 0 : _b.targetId
        };
    }
    get nodes() {
        return this._userNodes;
    }
    get edges() {
        return this._userEdges;
    }
    nodeCount() {
        return [...this._nodes.keys()].length;
    }
    edgeCount() {
        return [...this._edges.keys()].length;
    }
    sources() {
        let nodesToReturn = [...this._nodes.values()];
        return nodesToReturn.filter(node => node.isSource()).map(elem => elem.attr);
    }
    sinks() {
        let nodesToReturn = [...this._nodes.values()];
        return nodesToReturn.filter(node => node.isSink()).map(elem => elem.attr);
    }
    deleteNode(id) {
        const node = this._node(id);
        if (typeof (node) === 'undefined')
            return;
        node.nodeEdges.forEach((edgeId) => {
            const { sourceId, targetId } = index_2.GraphEdge.parseEdgeId(edgeId);
            this.deleteEdge(sourceId, targetId);
        });
        this._nodes.delete(id);
    }
    deleteEdge(sourceId, targetId) {
        const edgeId = index_2.GraphEdge.edgeId(sourceId, targetId);
        const edge = this._edges.get(edgeId);
        if (edge !== undefined) {
            let sourceNode = this._nodes.get(sourceId);
            if (sourceNode !== undefined) {
                sourceNode.deleteEdge(edgeId);
            }
            let targetNode = this._nodes.get(targetId);
            if (targetNode !== undefined) {
                targetNode.deleteEdge(edgeId);
            }
        }
        this._edges.delete(edgeId);
    }
    inEdges(nodeId) {
        return this._transformToUserEdgeMap(this._inEdges(nodeId));
    }
    outEdges(nodeId) {
        return this._transformToUserEdgeMap(this._outEdges(nodeId));
    }
    nodeEdges(nodeId) {
        return this._transformToUserEdgeMap(this._nodeEdges(nodeId));
    }
    _inEdges(nodeId) {
        let newEdges = new Map();
        const node = this._node(nodeId);
        if (node === undefined)
            return newEdges;
        node.inEdges.forEach(edgeId => {
            let { sourceId, targetId } = index_2.GraphEdge.parseEdgeId(edgeId);
            let edge = this._edge(sourceId, targetId);
            if (edge !== undefined) {
                newEdges.set(edgeId, edge);
            }
        });
        return newEdges;
    }
    _outEdges(nodeId) {
        let newEdges = new Map();
        const node = this._node(nodeId);
        if (node === undefined)
            return newEdges;
        node.outEdges.forEach(edgeId => {
            let { sourceId, targetId } = index_2.GraphEdge.parseEdgeId(edgeId);
            let edge = this._edge(sourceId, targetId);
            if (edge !== undefined) {
                newEdges.set(edgeId, edge);
            }
        });
        return newEdges;
    }
    _nodeEdges(nodeId) {
        let newEdges = new Map();
        const node = this._node(nodeId);
        if (node === undefined)
            return newEdges;
        node.nodeEdges.forEach(edgeId => {
            let { sourceId, targetId } = index_2.GraphEdge.parseEdgeId(edgeId);
            let edge = this._edge(sourceId, targetId);
            if (edge !== undefined) {
                newEdges.set(edgeId, edge);
            }
        });
        return newEdges;
    }
    successors(nodeId, filterPredicate = returnTrue) {
        return this._transformToUserNodeMap(this._successors(nodeId, filterPredicate));
    }
    predecessors(nodeId, filterPredicate = returnTrue) {
        return this._transformToUserNodeMap(this._predecessors(nodeId, filterPredicate));
    }
    neighbors(nodeId, filterPredicate = returnTrue) {
        return this._transformToUserNodeMap(this._neighbors(nodeId, filterPredicate));
    }
    _successors(nodeId, filterPredicate = returnTrue) {
        let successors = new Map();
        const node = this._node(nodeId);
        if (node === undefined)
            return successors;
        node.outEdges.forEach(edgeId => {
            var _a;
            const edge = (_a = this._edges.get(edgeId)) === null || _a === void 0 ? void 0 : _a.attr;
            if (edge != undefined && filterPredicate(edge)) {
                const { sourceId, targetId } = index_2.GraphEdge.parseEdgeId(edgeId);
                const targetNode = this._node(targetId);
                if (!!targetId && targetNode !== undefined) {
                    successors.set(targetId, targetNode);
                }
            }
        });
        return successors;
    }
    _predecessors(nodeId, filterPredicate = returnTrue) {
        let predecessors = new Map();
        const node = this._node(nodeId);
        if (node === undefined)
            return predecessors;
        node.inEdges.forEach(edgeId => {
            var _a;
            const edge = (_a = this._edges.get(edgeId)) === null || _a === void 0 ? void 0 : _a.attr;
            if (edge != undefined && filterPredicate(edge)) {
                const { sourceId, targetId } = index_2.GraphEdge.parseEdgeId(edgeId);
                const sourceNode = this._node(sourceId);
                if (!!sourceId && sourceNode !== undefined) {
                    predecessors.set(sourceId, sourceNode);
                }
            }
        });
        return predecessors;
    }
    _neighbors(nodeId, filterPredicate = returnTrue) {
        let neighbors = new Map([...this._predecessors(nodeId, filterPredicate), ...this._successors(nodeId, filterPredicate)]);
        return neighbors;
    }
    successorsSubgraph(nodeIds, filterPredicate = returnTrue) {
        return this._buildSubgraphs(nodeIds, filterPredicate, 'successors');
    }
    _alreadyProcessed(nodeId, subgraphs) {
        for (const graph of subgraphs) {
            if (graph.hasNode(nodeId)) {
                return true;
            }
        }
        return false;
    }
    _buildSubgraphs(nodeIds, filterPredicate, order) {
        let subgraphs = [];
        if (!Array.isArray(nodeIds)) {
            return this._buildSubgraph(nodeIds, filterPredicate, order);
        }
        nodeIds.forEach(nodeId => {
            if (this._alreadyProcessed(nodeId, subgraphs)) {
                return;
            }
            subgraphs.push(this._buildSubgraph(nodeId, filterPredicate, order));
        });
        if (subgraphs.length === 1) {
            return subgraphs[0];
        }
        let mergedGraphs = new Graph();
        if (subgraphs.length) {
            mergedGraphs = subgraphs[0].merge(subgraphs);
        }
        return mergedGraphs;
    }
    _buildSubgraph(nodeId, filterPredicate, order) {
        let g = new Graph();
        let graphNode = this._node(nodeId);
        if (!graphNode) {
            throw new Error('Node does not exist on graph');
        }
        else {
            g.setNode(nodeId, graphNode.attr);
        }
        return order === 'successors' ? this._successorsSubgraphUtil(nodeId, g, {}, filterPredicate) :
            this._predecessorsSubgraphUtil(nodeId, g, {}, filterPredicate);
    }
    _successorsSubgraphUtil(nodeId, successorsGraph, visited = {}, filterPredicate) {
        const successors = [...this._successors(nodeId, filterPredicate).keys()] || [];
        if (successors.length > 0 && !visited[nodeId]) {
            successors.forEach((successor) => {
                visited[nodeId] = true;
                const newNode = this._nodes.get(successor);
                const newEdge = this._edges.get(index_2.GraphEdge.edgeId(nodeId, successor));
                if (newNode !== undefined && newEdge != undefined) {
                    successorsGraph.setNode(successor, newNode.attr);
                    successorsGraph.setEdge(nodeId, successor, newEdge.attr);
                    return this._successorsSubgraphUtil(successor, successorsGraph, visited, filterPredicate);
                }
            });
        }
        return successorsGraph;
    }
    successorsArray(nodeId, filterPredicate = returnTrue) {
        const successorIds = lodash_1.default.uniq(this._successorsArrayUtil(nodeId, [], {}, filterPredicate));
        let successors = [];
        successorIds.forEach((id) => {
            let node = this.node(id);
            if (node != undefined) {
                successors.push(node);
            }
        });
        return successors;
    }
    _successorsArrayUtil(nodeId, successorsList = [], visited = {}, filterPredicate = returnTrue) {
        const successors = [...this._successors(nodeId, filterPredicate).keys()] || [];
        if (successors.length > 0 && !visited[nodeId]) {
            successors.forEach((successor) => {
                visited[nodeId] = true;
                successorsList.push(successor);
                return this._successorsArrayUtil(successor, successorsList, visited, filterPredicate);
            });
        }
        return successorsList;
    }
    successorsLayers(nodeKey, filterPredicate = returnTrue, order = 'fromSource') {
        let successorsGraph = this.successorsSubgraph(nodeKey, filterPredicate);
        if (this.isCyclic(successorsGraph)) {
            throw new Error("cyclic dependency");
        }
        let layers = [];
        layers[0] = [nodeKey];
        let floor = 0;
        let rawLayers = this._successorsLayersUtil([nodeKey], layers, floor, filterPredicate);
        return arrangeLayers(rawLayers, order);
    }
    _successorsLayersUtil(nodeKeys, layers, floor, filterPredicate = returnTrue) {
        if (nodeKeys.length > 0) {
            let nextFloor = floor + 1;
            layers.push([]);
            layers[floor].forEach((successor) => {
                const successors = [...this.successors(successor, filterPredicate).keys()];
                layers[nextFloor] = layers[nextFloor].concat(successors);
            });
            return this._successorsLayersUtil(layers[nextFloor], layers, nextFloor, filterPredicate);
        }
        return layers;
    }
    predecessorsSubgraph(nodeIds, filterPredicate = returnTrue) {
        return this._buildSubgraphs(nodeIds, filterPredicate, 'predecessors');
    }
    _predecessorsSubgraphUtil(nodeId, predecessorsGraph, visited = {}, filterPredicate = returnTrue) {
        const predecessors = [...this._predecessors(nodeId, filterPredicate).keys()] || [];
        if (predecessors.length > 0 && !visited[nodeId]) {
            predecessors.forEach((predecessor) => {
                visited[nodeId] = true;
                const newNode = this._nodes.get(predecessor);
                const newEdge = this._edges.get(index_2.GraphEdge.edgeId(predecessor, nodeId));
                if (newNode !== undefined && newEdge != undefined) {
                    predecessorsGraph.setNode(predecessor, newNode.attr);
                    predecessorsGraph.setEdge(predecessor, nodeId, newEdge.attr);
                    return this._predecessorsSubgraphUtil(predecessor, predecessorsGraph, visited, filterPredicate);
                }
            });
        }
        return predecessorsGraph;
    }
    predecessorsArray(nodeId, filterPredicate = returnTrue) {
        const predecessorIds = lodash_1.default.uniq(this._predecessorsArrayUtil(nodeId, [], {}, filterPredicate));
        let predecessors = [];
        predecessorIds.forEach((id) => {
            let node = this.node(id);
            if (node != undefined) {
                predecessors.push(node);
            }
        });
        return predecessors;
    }
    _predecessorsArrayUtil(nodeId, predecessorsList = [], visited = {}, filterPredicate = returnTrue) {
        const predecessors = [...this._predecessors(nodeId, filterPredicate).keys()] || [];
        if (predecessors.length > 0 && !visited[nodeId]) {
            predecessors.forEach((predecessor) => {
                visited[nodeId] = true;
                predecessorsList.push(predecessor);
                return this._predecessorsArrayUtil(predecessor, predecessorsList, visited, filterPredicate);
            });
        }
        return predecessorsList;
    }
    predecessorsLayers(nodeKey, filterPredicate = returnTrue, order = 'fromSource') {
        let successorsGraph = this.predecessorsSubgraph(nodeKey, filterPredicate);
        if (this.isCyclic(successorsGraph)) {
            throw new Error("cyclic sub-graph");
        }
        let layers = [];
        layers[0] = [nodeKey];
        let floor = 0;
        let rawLayers = this._predecessorsLayersUtil([nodeKey], layers, floor, filterPredicate);
        return arrangeLayers(rawLayers, order);
    }
    _predecessorsLayersUtil(nodeKeys, layers, floor, filterPredicate = returnTrue) {
        if (nodeKeys.length > 0) {
            let nextFloor = floor + 1;
            layers.push([]);
            layers[floor].forEach((predecessor) => {
                const predecessors = [...this.predecessors(predecessor, filterPredicate).keys()];
                layers[nextFloor] = layers[nextFloor].concat(predecessors);
            });
            return this._predecessorsLayersUtil(layers[nextFloor], layers, nextFloor, filterPredicate);
        }
        return layers;
    }
    toposort(reverse = false) {
        let nodes = this._toposort().map(nodeId => this.node(nodeId));
        nodes = lodash_1.default.compact(nodes);
        return reverse ? nodes.reverse() : nodes;
    }
    _transformEdges() {
        let edges = [];
        this._edges.forEach(originalEdge => {
            edges.push([originalEdge.sourceId, originalEdge.targetId]);
        });
        return edges;
    }
    _toposort() {
        const nodes = [...this._nodes.keys()];
        const edges = this._transformEdges();
        var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
        edges.forEach(function (edge) {
            if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
                throw new Error('Unknown node. There is an unknown node in the supplied edges.');
            }
        });
        while (i--) {
            if (!visited[i])
                visit(nodes[i], i, new Set());
        }
        return sorted;
        function visit(node, i, predecessors) {
            if (predecessors.has(node)) {
                var nodeRep;
                try {
                    nodeRep = ", node was:" + JSON.stringify(node);
                }
                catch (e) {
                    nodeRep = "";
                }
                throw new index_3.CyclicError('Cyclic dependency' + nodeRep);
            }
            if (!nodesHash.has(node)) {
                throw new Error('Found unknown node. Make sure to provide all involved nodes. Unknown node: ' + JSON.stringify(node));
            }
            if (visited[i])
                return;
            visited[i] = true;
            var outgoing = outgoingEdges.get(node) || new Set();
            outgoing = Array.from(outgoing);
            if (i = outgoing.length) {
                predecessors.add(node);
                do {
                    var child = outgoing[--i];
                    visit(child, nodesHash.get(child), predecessors);
                } while (i);
                predecessors.delete(node);
            }
            sorted[--cursor] = node;
        }
    }
    isCyclic(graph = this) {
        try {
            graph.toposort();
        }
        catch (e) {
            if (e instanceof index_3.CyclicError) {
                return true;
            }
            throw e;
        }
        return false;
    }
    findCycles(graph = this) {
        return findCycles(graph);
    }
    merge(graphs) {
        let mergedGraph = this;
        graphs.forEach(incomingGraph => {
            var _a, _b;
            for (let [nodeId, nodeData] of incomingGraph.nodes) {
                mergedGraph.setNode(nodeId, nodeData);
            }
            for (let [edgeId, edgeData] of incomingGraph.edges) {
                const sourceId = (_a = incomingGraph._edges.get(edgeId)) === null || _a === void 0 ? void 0 : _a.sourceId;
                const targetId = (_b = incomingGraph._edges.get(edgeId)) === null || _b === void 0 ? void 0 : _b.targetId;
                if (mergedGraph.edges.has(edgeId) && !!sourceId && !!targetId) {
                    mergedGraph.setEdge(sourceId, targetId, edgeData);
                }
                else {
                    if (!!sourceId && !!targetId && mergedGraph.hasNode(sourceId) && mergedGraph.hasNode(targetId)) {
                        mergedGraph.setEdge(sourceId, targetId, edgeData);
                    }
                    else {
                        throw index_3.NodeDoesntExist;
                    }
                }
            }
        });
        return mergedGraph;
    }
    allPaths(sourceId, targetId) {
        const paths = this._allPaths(sourceId, targetId, [], []);
        return paths;
    }
    _allPaths(source, target, currPath, paths, visited = {}) {
        visited[source] = true;
        currPath.push(source);
        if (source === target) {
            paths.push(lodash_1.default.cloneDeep(currPath));
        }
        else {
            const successors = [...this._successors(source).keys()] || [];
            successors.forEach(nodeId => {
                if (!visited[nodeId]) {
                    this._allPaths(nodeId, target, currPath, paths, visited);
                }
            });
        }
        currPath.pop();
        visited[source] = false;
        return paths;
    }
    toJson(graph) {
        return graph ? this._toJson(graph, 'object') : this._toJson(this, 'object');
    }
    stringify(graph) {
        return graph ? this._toJson(graph, 'string') : this._toJson(this, 'string');
    }
    static parse(json, parseNode = node_1.genericParseNode, parseEdge = edge_1.genericParseEdge) {
        return this._fromJson(json, parseNode, parseEdge);
    }
    _toJson(graph, returnType) {
        let nodeArray = [];
        for (let [nodeId, nodeData] of graph.nodes.entries()) {
            const graphNode = graph._node(nodeId);
            if (!!graphNode) {
                let convertedNode;
                if (returnType === 'object') {
                    if (!!graphNode.attr['toJson'] && typeof graphNode.attr['toJson'] === 'function') {
                        convertedNode = graphNode.attr.toJson();
                    }
                    else {
                        convertedNode = node_1.genericNodeToJson(graphNode.attr);
                    }
                }
                else {
                    convertedNode = graphNode.stringify();
                }
                nodeArray.push({
                    id: nodeId,
                    node: convertedNode
                });
            }
        }
        let edgeArray = [];
        for (let [edgeId, edgeData] of graph.edges.entries()) {
            const graphEdge = graph._edgeById(edgeId);
            if (!!graphEdge) {
                let convertedEdge;
                if (returnType === 'object') {
                    if (!!graphEdge.attr['toJson'] && typeof graphEdge.attr['toJson'] === 'function') {
                        convertedEdge = graphEdge.attr.toJson();
                    }
                    else {
                        convertedEdge = node_1.genericNodeToJson(graphEdge.attr);
                    }
                }
                else {
                    convertedEdge = graphEdge.stringify();
                }
                edgeArray.push({
                    sourceId: graphEdge.sourceId,
                    targetId: graphEdge.targetId,
                    edge: convertedEdge
                });
            }
        }
        let json = {
            nodes: nodeArray,
            edges: edgeArray
        };
        return returnType === 'object' ? json : JSON.stringify(json);
    }
    static _fromJson(json, parseNode, parseEdge) {
        const obj = typeof (json) === 'string' ? JSON.parse(json) : json;
        let graph = new Graph();
        if (!obj.hasOwnProperty('nodes') || !obj.hasOwnProperty('edges')) {
            throw Error('missing properties on JSON. Should contain nodes: {id: string, node: N}[], and edges: {sourceId: string, targetId: string, edge:E}[]');
        }
        obj.nodes.forEach(nodeObj => {
            const res = index_1.GraphNode.fromObject(nodeObj, parseNode);
            graph.setNode(res.id, res.node);
        });
        obj.edges.forEach(edgeObj => {
            const res = index_2.GraphEdge.fromObject(edgeObj, parseEdge);
            graph.setEdge(res.sourceId, res.targetId, res.edge);
        });
        return graph;
    }
    bfs() {
    }
    dfs() {
    }
}
exports.Graph = Graph;
function returnTrue() { return true; }
function makeOutgoingEdges(arr) {
    var edges = new Map();
    for (var i = 0, len = arr.length; i < len; i++) {
        var edge = arr[i];
        if (!edges.has(edge[0]))
            edges.set(edge[0], new Set());
        if (!edges.has(edge[1]))
            edges.set(edge[1], new Set());
        edges.get(edge[0]).add(edge[1]);
    }
    return edges;
}
function makeNodesHash(arr) {
    var res = new Map();
    for (var i = 0, len = arr.length; i < len; i++) {
        res.set(arr[i], i);
    }
    return res;
}
function findCycles(g) {
    return lodash_1.default.filter(algorithms_1.tarjan(g), function (cmpt) {
        return cmpt.length > 1 || (cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]));
    });
}
function arrangeLayers(layers, order) {
    let finalLayers = [];
    let seenNodes = [];
    layers = layers.reverse();
    let i = 0;
    layers.forEach(layer => {
        if (layer.length > 0) {
            finalLayers.push([]);
            layer.forEach(node => {
                if (seenNodes.indexOf(node) == -1) {
                    seenNodes.push(node);
                    finalLayers[i].push(node);
                }
            });
            i++;
        }
    });
    return order === 'fromSource' ? finalLayers.reverse() : finalLayers;
}
//# sourceMappingURL=graph.js.map