"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var postcss = require("postcss");
var selector_utils_1 = require("../selector-utils");
var classname_optimizer_1 = require("./classname-optimizer");
var namespace_optimizer_1 = require("./namespace-optimizer");
var StylableOptimizer = /** @class */ (function () {
    function StylableOptimizer(classNameOptimizer, namespaceOptimizer) {
        if (classNameOptimizer === void 0) { classNameOptimizer = new classname_optimizer_1.StylableClassNameOptimizer(); }
        if (namespaceOptimizer === void 0) { namespaceOptimizer = new namespace_optimizer_1.StylableNamespaceOptimizer(); }
        this.classNameOptimizer = classNameOptimizer;
        this.namespaceOptimizer = namespaceOptimizer;
    }
    StylableOptimizer.prototype.minifyCSS = function (css) {
        var CleanCSS = require('clean-css');
        return new CleanCSS({}).minify(css).styles;
    };
    StylableOptimizer.prototype.optimize = function (config, stylableResults, delimiter, usageMapping) {
        var meta = stylableResults.meta, jsExports = stylableResults.exports;
        var outputAst = meta.outputAst;
        if (config.removeComments) {
            this.removeComments(outputAst);
        }
        if (config.removeStylableDirectives) {
            this.removeStylableDirectives(outputAst);
        }
        if (config.removeUnusedComponents && usageMapping && delimiter) {
            this.removeUnusedComponents(delimiter, outputAst, usageMapping);
        }
        if (config.removeEmptyNodes) {
            this.removeEmptyNodes(outputAst);
        }
        if (config.classNameOptimizations) {
            this.classNameOptimizer.optimizeAstAndExports(outputAst, jsExports, Object.keys(meta.classes));
        }
    };
    StylableOptimizer.prototype.removeStylableDirectives = function (root, shouldComment) {
        if (shouldComment === void 0) { shouldComment = false; }
        var toRemove = [];
        root.walkDecls(function (decl) {
            if (decl.prop.startsWith('-st-')) {
                toRemove.push(decl);
            }
        });
        toRemove.forEach(shouldComment
            ? function (node) {
                node.replaceWith.apply(node, createLineByLineComment(node));
            }
            : function (node) {
                node.remove();
            });
    };
    StylableOptimizer.prototype.removeEmptyNodes = function (root) {
        removeEmptyNodes(root);
    };
    StylableOptimizer.prototype.removeComments = function (root) {
        removeCommentNodes(root);
    };
    StylableOptimizer.prototype.removeUnusedComponents = function (delimiter, outputAst, usageMapping, shouldComment) {
        var _this = this;
        if (shouldComment === void 0) { shouldComment = false; }
        var matchNamespace = new RegExp("(.+)" + delimiter + "(.+)");
        outputAst.walkRules(function (rule) {
            var outputSelectors = rule.selectors.filter(function (selector) {
                var selectorAst = selector_utils_1.parseSelector(selector);
                return !_this.isContainsUnusedParts(selectorAst, usageMapping, matchNamespace);
            });
            if (outputSelectors.length) {
                rule.selector = outputSelectors.join();
            }
            else {
                if (shouldComment) {
                    replaceRecursiveUpIfEmpty('NOT_IN_USE', rule);
                }
                else {
                    rule.remove();
                }
            }
        });
    };
    StylableOptimizer.prototype.isContainsUnusedParts = function (selectorAst, usageMapping, matchNamespace) {
        // TODO: !!-!-!! last working point
        var isContainsUnusedParts = false;
        selector_utils_1.traverseNode(selectorAst, function (node) {
            if (isContainsUnusedParts) {
                return false;
            }
            if (node.type === 'class') {
                var parts = matchNamespace.exec(node.name);
                if (parts) {
                    if (usageMapping[parts[1]] === false) {
                        isContainsUnusedParts = true;
                    }
                }
            }
            else if (node.type === 'nested-pseudo-element') {
                return false;
            }
            return undefined;
        });
        return isContainsUnusedParts;
    };
    return StylableOptimizer;
}());
exports.StylableOptimizer = StylableOptimizer;
function removeCommentNodes(root) {
    root.walkComments(function (comment) { return comment.remove(); });
    root.walkDecls(function (decl) {
        var r = decl.raws;
        if (r.value) {
            r.value.raw = decl.value;
        }
    });
}
exports.removeCommentNodes = removeCommentNodes;
function removeEmptyNodes(root) {
    var toRemove = [];
    root.walkRules(function (rule) {
        var shouldRemove = (rule.nodes && rule.nodes.length === 0) ||
            (rule.nodes && rule.nodes.filter(function (node) { return node.type !== 'comment'; }).length === 0);
        if (shouldRemove) {
            toRemove.push(rule);
        }
    });
    toRemove.forEach(function (node) {
        removeRecursiveUpIfEmpty(node);
    });
}
exports.removeEmptyNodes = removeEmptyNodes;
function createCommentFromNode(label, node) {
    return [
        postcss.comment({
            text: label + ':'
        })
    ].concat(createLineByLineComment(node));
}
exports.createCommentFromNode = createCommentFromNode;
function createLineByLineComment(node) {
    return node
        .toString()
        .split(/\r?\n/)
        .map(function (x) {
        if (x.trim() === '') {
            return undefined;
        }
        var c;
        if (x.trim().startsWith('/*') && x.trim().endsWith('*/')) {
            c = postcss.comment({ text: x.replace(/\*\//gm, '').replace(/\/\*/gm, '') });
            // c = postcss.comment({ text: x.replace(/\*\//gm, '').replace(/\/\*/gm, '') });
        }
        else {
            c = postcss.comment({ text: x.replace(/\*\//gm, '*//*') });
        }
        return c;
    })
        .filter(Boolean);
}
exports.createLineByLineComment = createLineByLineComment;
function removeRecursiveUpIfEmpty(node) {
    var parent = node.parent;
    node.remove();
    if (parent && parent.nodes && parent.nodes.length === 0) {
        removeRecursiveUpIfEmpty(parent);
    }
}
exports.removeRecursiveUpIfEmpty = removeRecursiveUpIfEmpty;
function replaceRecursiveUpIfEmpty(label, node) {
    var parent = node.parent;
    node.raws = {};
    node.replaceWith.apply(node, (node.type === 'decl'
        ? createLineByLineComment(node)
        : createCommentFromNode(label, node)));
    if (parent &&
        parent.nodes &&
        parent.nodes.filter(function (node) { return node.type !== 'comment'; }).length === 0) {
        replaceRecursiveUpIfEmpty('EMPTY_NODE', parent);
    }
}
exports.replaceRecursiveUpIfEmpty = replaceRecursiveUpIfEmpty;
//# sourceMappingURL=stylable-optimizer.js.map