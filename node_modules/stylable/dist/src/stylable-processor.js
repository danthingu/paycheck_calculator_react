"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var postcss = require("postcss");
var diagnostics_1 = require("./diagnostics");
var path = require("./path");
var selector_utils_1 = require("./selector-utils");
var stylable_assets_1 = require("./stylable-assets");
var stylable_meta_1 = require("./stylable-meta");
var stylable_utils_1 = require("./stylable-utils");
var stylable_value_parsers_1 = require("./stylable-value-parsers");
var utils_1 = require("./utils");
__export(require("./stylable-meta")); /* TEMP EXPORT */
var hash = require('murmurhash');
var parseNamed = stylable_value_parsers_1.SBTypesParsers[stylable_value_parsers_1.valueMapping.named];
var parseMixin = stylable_value_parsers_1.SBTypesParsers[stylable_value_parsers_1.valueMapping.mixin];
var parseStates = stylable_value_parsers_1.SBTypesParsers[stylable_value_parsers_1.valueMapping.states];
var parseCompose = stylable_value_parsers_1.SBTypesParsers[stylable_value_parsers_1.valueMapping.compose];
var parseTheme = stylable_value_parsers_1.SBTypesParsers[stylable_value_parsers_1.valueMapping.theme];
var parseGlobal = stylable_value_parsers_1.SBTypesParsers[stylable_value_parsers_1.valueMapping.global];
var parseExtends = stylable_value_parsers_1.SBTypesParsers[stylable_value_parsers_1.valueMapping.extends];
/* tslint:disable:max-line-length */
exports.processorWarnings = {
    UNSCOPED_CLASS: function (name) { return "unscoped native element \"" + name + "\" will affect all elements of the same type in the document"; },
    UNSCOPED_ELEMENT: function (name) { return "unscoped native element \"" + name + "\" will affect all elements of the same type in the document"; },
    FORBIDDEN_DEF_IN_COMPLEX_SELECTOR: function (name) { return "cannot define \"" + name + "\" inside a complex selector"; },
    ROOT_AFTER_SPACING: function () { return '".root" class cannot be used after native elements or selectors external to the stylesheet'; },
    DEFAULT_IMPORT_IS_LOWER_CASE: function () { return 'Default import of a Stylable stylesheet must start with an upper-case letter'; },
    ILLEGAL_PROP_IN_IMPORT: function (propName) { return "\"" + propName + "\" css attribute cannot be used inside :import block"; },
    FROM_PROP_MISSING_IN_IMPORT: function () { return "\"" + stylable_value_parsers_1.valueMapping.from + "\" is missing in :import block"; },
    STATE_DEFINITION_IN_ELEMENT: function () { return 'cannot define pseudo states inside element selectors'; },
    STATE_DEFINITION_IN_COMPLEX: function () { return 'cannot define pseudo states inside complex selectors'; },
    REDECLARE_SYMBOL: function (name) { return "redeclare symbol \"" + name + "\""; },
    CANNOT_RESOLVE_EXTEND: function (name) { return "cannot resolve '" + stylable_value_parsers_1.valueMapping.extends + "' type for '" + name + "'"; },
    CANNOT_RESOLVE_COMPOSE: function (name) { return "cannot resolve '" + stylable_value_parsers_1.valueMapping.compose + "' type for '" + name + "'"; },
    CANNOT_EXTEND_IN_COMPLEX: function () { return "cannot define \"" + stylable_value_parsers_1.valueMapping.extends + "\" inside a complex selector"; },
    CANNOT_COMPOSE_IN_COMPLEX: function () { return "cannot define \"" + stylable_value_parsers_1.valueMapping.compose + "\" inside a complex selector"; },
    UNKNOWN_MIXIN: function (name) { return "unknown mixin: \"" + name + "\""; },
    OVERRIDE_MIXIN: function () { return "override mixin on same rule"; },
    OVERRIDE_TYPED_RULE: function (key, name) { return "override \"" + key + "\" on typed rule \"" + name + "\""; }
};
/* tslint:enable:max-line-length */
var StylableProcessor = /** @class */ (function () {
    function StylableProcessor(diagnostics, resolveNamespace) {
        if (diagnostics === void 0) { diagnostics = new diagnostics_1.Diagnostics(); }
        if (resolveNamespace === void 0) { resolveNamespace = processNamespace; }
        this.diagnostics = diagnostics;
        this.resolveNamespace = resolveNamespace;
    }
    StylableProcessor.prototype.process = function (root) {
        var _this = this;
        this.meta = new stylable_meta_1.StylableMeta(root, this.diagnostics);
        this.handleAtRules(root);
        var stubs = this.insertCustomSelectorsStubs();
        root.walkRules(function (rule) {
            if (!selector_utils_1.isChildOfAtRule(rule, 'keyframes')) {
                _this.handleCustomSelectors(rule);
                _this.handleRule(rule);
            }
        });
        root.walkDecls(function (decl) {
            if (stylable_value_parsers_1.stValuesMap[decl.prop]) {
                _this.handleDirectives(decl.parent, decl);
            }
            stylable_assets_1.processDeclarationUrls(decl, function (node) {
                _this.meta.urls.push(node.url);
            }, false);
        });
        stubs.forEach(function (s) { return s && s.remove(); });
        return this.meta;
    };
    StylableProcessor.prototype.insertCustomSelectorsStubs = function () {
        var _this = this;
        return Object.keys(this.meta.customSelectors).map(function (selector) {
            if (_this.meta.customSelectors[selector]) {
                var rule = postcss.rule({ selector: selector });
                _this.meta.ast.append(rule);
                return rule;
            }
            return null;
        });
    };
    StylableProcessor.prototype.handleCustomSelectors = function (rule) {
        stylable_utils_1.expandCustomSelectors(rule, this.meta.customSelectors, this.meta.diagnostics);
    };
    StylableProcessor.prototype.handleAtRules = function (root) {
        var _this = this;
        var namespace = '';
        var toRemove = [];
        root.walkAtRules(function (atRule) {
            switch (atRule.name) {
                case 'namespace':
                    var match = atRule.params.match(/["'](.*?)['"]/);
                    match ? (namespace = match[1]) : _this.diagnostics.error(atRule, 'invalid namespace');
                    toRemove.push(atRule);
                    break;
                case 'keyframes':
                    _this.meta.keyframes.push(atRule);
                    break;
                case 'custom-selector':
                    var params = atRule.params.split(/\s/);
                    var customName = params.shift();
                    toRemove.push(atRule);
                    if (customName && customName.match(stylable_utils_1.CUSTOM_SELECTOR_RE)) {
                        _this.meta.customSelectors[customName] = atRule.params.replace(customName, '').trim();
                    }
                    else {
                        // TODO: add warn there are two types one is not valid name and the other is empty name.
                    }
                    break;
            }
        });
        toRemove.forEach(function (node) { return node.remove(); });
        namespace = namespace || utils_1.filename2varname(path.basename(this.meta.source)) || 's';
        this.meta.namespace = this.resolveNamespace(namespace, this.meta.source);
    };
    StylableProcessor.prototype.handleRule = function (rule) {
        var _this = this;
        rule.selectorAst = selector_utils_1.parseSelector(rule.selector);
        var checker = selector_utils_1.createSimpleSelectorChecker();
        var validRoot = selector_utils_1.isRootValid(rule.selectorAst, 'root');
        var locallyScoped = false;
        selector_utils_1.traverseNode(rule.selectorAst, function (node, _index, _nodes) {
            if (!checker(node)) {
                rule.isSimpleSelector = false;
            }
            var name = node.name, type = node.type;
            if (type === 'pseudo-class') {
                if (name === 'import') {
                    if (rule.selector === ':import') {
                        var _import = _this.handleImport(rule);
                        _this.meta.imports.push(_import);
                        _this.addImportSymbols(_import);
                        return false;
                    }
                    else {
                        _this.diagnostics.warn(rule, exports.processorWarnings.FORBIDDEN_DEF_IN_COMPLEX_SELECTOR(':import'));
                    }
                }
                else if (name === 'vars') {
                    if (rule.selector === ':vars') {
                        _this.addVarSymbols(rule);
                        return false;
                    }
                    else {
                        _this.diagnostics.warn(rule, exports.processorWarnings.FORBIDDEN_DEF_IN_COMPLEX_SELECTOR(':vars'));
                    }
                }
            }
            else if (type === 'class') {
                _this.addClassSymbolOnce(name, rule);
                if (_this.meta.classes[name]) {
                    if (!_this.meta.classes[name].alias) {
                        locallyScoped = true;
                    }
                    else if (locallyScoped === false) {
                        _this.diagnostics.warn(rule, exports.processorWarnings.UNSCOPED_CLASS(name), { word: name });
                    }
                }
            }
            else if (type === 'element') {
                _this.addElementSymbolOnce(name, rule);
                if (locallyScoped === false) {
                    _this.diagnostics.warn(rule, exports.processorWarnings.UNSCOPED_ELEMENT(name), { word: name });
                }
            }
            else if (type === 'nested-pseudo-class' && name === 'global') {
                return true;
            }
            return void 0;
        });
        if (rule.isSimpleSelector !== false) {
            rule.isSimpleSelector = true;
            rule.selectorType = rule.selector.match(/^\./) ? 'class' : 'element';
        }
        else {
            rule.selectorType = 'complex';
        }
        if (!validRoot) {
            this.diagnostics.warn(rule, exports.processorWarnings.ROOT_AFTER_SPACING());
        }
    };
    StylableProcessor.prototype.checkRedeclareSymbol = function (symbolName, node) {
        var symbol = this.meta.mappedSymbols[symbolName];
        if (symbol) {
            this.diagnostics.warn(node, exports.processorWarnings.REDECLARE_SYMBOL(symbolName), { word: symbolName });
        }
    };
    StylableProcessor.prototype.addElementSymbolOnce = function (name, rule) {
        if (selector_utils_1.isCompRoot(name) && !this.meta.elements[name]) {
            var alias = this.meta.mappedSymbols[name];
            if (alias && alias._kind !== 'import') {
                this.checkRedeclareSymbol(name, rule);
                alias = undefined;
            }
            this.meta.elements[name] = this.meta.mappedSymbols[name] = { _kind: 'element', name: name, alias: alias };
        }
    };
    StylableProcessor.prototype.addClassSymbolOnce = function (name, rule) {
        if (!this.meta.classes[name]) {
            var alias = this.meta.mappedSymbols[name];
            if (alias && alias._kind !== 'import') {
                this.checkRedeclareSymbol(name, rule);
                alias = undefined;
            }
            this.meta.classes[name] = this.meta.mappedSymbols[name] = { _kind: 'class', name: name, alias: alias };
        }
    };
    StylableProcessor.prototype.addImportSymbols = function (importDef) {
        var _this = this;
        if (importDef.defaultExport) {
            this.checkRedeclareSymbol(importDef.defaultExport, importDef.rule);
            this.meta.mappedSymbols[importDef.defaultExport] = {
                _kind: 'import',
                type: 'default',
                name: 'default',
                import: importDef,
                context: path.dirname(this.meta.source)
            };
        }
        Object.keys(importDef.named).forEach(function (name) {
            _this.checkRedeclareSymbol(name, importDef.rule);
            _this.meta.mappedSymbols[name] = {
                _kind: 'import',
                type: 'named',
                name: importDef.named[name],
                import: importDef,
                context: path.dirname(_this.meta.source)
            };
        });
    };
    StylableProcessor.prototype.addVarSymbols = function (rule) {
        var _this = this;
        rule.walkDecls(function (decl) {
            _this.checkRedeclareSymbol(decl.prop, decl);
            var type = null;
            var prev = decl.prev();
            if (prev && prev.type === 'comment') {
                var typeMatch = prev.text.match(/^@type (.+)$/);
                if (typeMatch) {
                    type = typeMatch[1];
                }
            }
            var varSymbol = {
                _kind: 'var',
                name: decl.prop,
                value: '',
                text: decl.value,
                node: decl,
                valueType: type
            };
            _this.meta.vars.push(varSymbol);
            _this.meta.mappedSymbols[decl.prop] = varSymbol;
        });
        rule.remove();
    };
    StylableProcessor.prototype.handleDirectives = function (rule, decl) {
        var _this = this;
        if (decl.prop === stylable_value_parsers_1.valueMapping.states) {
            if (rule.isSimpleSelector && rule.selectorType !== 'element') {
                this.extendTypedRule(decl, rule.selector, stylable_value_parsers_1.valueMapping.states, parseStates(decl.value, decl, this.diagnostics));
            }
            else {
                if (rule.selectorType === 'element') {
                    this.diagnostics.warn(decl, exports.processorWarnings.STATE_DEFINITION_IN_ELEMENT());
                }
                else {
                    this.diagnostics.warn(decl, exports.processorWarnings.STATE_DEFINITION_IN_COMPLEX());
                }
            }
        }
        else if (decl.prop === stylable_value_parsers_1.valueMapping.extends) {
            if (rule.isSimpleSelector) {
                var parsed = parseExtends(decl.value);
                var symbolName = parsed.types[0] && parsed.types[0].symbolName;
                var extendsRefSymbol = this.meta.mappedSymbols[symbolName];
                if (extendsRefSymbol &&
                    (extendsRefSymbol._kind === 'import' ||
                        extendsRefSymbol._kind === 'class' ||
                        extendsRefSymbol._kind === 'element') ||
                    decl.value === this.meta.root) {
                    this.extendTypedRule(decl, rule.selector, stylable_value_parsers_1.valueMapping.extends, stylable_utils_1.getAlias(extendsRefSymbol) || extendsRefSymbol);
                }
                else {
                    this.diagnostics.warn(decl, exports.processorWarnings.CANNOT_RESOLVE_EXTEND(decl.value), { word: decl.value });
                }
            }
            else {
                this.diagnostics.warn(decl, exports.processorWarnings.CANNOT_EXTEND_IN_COMPLEX());
            }
        }
        else if (decl.prop === stylable_value_parsers_1.valueMapping.mixin) {
            var mixins_1 = [];
            parseMixin(decl, function (type) {
                var mixinRefSymbol = _this.meta.mappedSymbols[type];
                if (mixinRefSymbol && mixinRefSymbol._kind === 'import' && !mixinRefSymbol.import.from.match(/.css$/)) {
                    return 'args';
                }
                return 'named';
            }, this.diagnostics).forEach(function (mixin) {
                var mixinRefSymbol = _this.meta.mappedSymbols[mixin.type];
                if (mixinRefSymbol && (mixinRefSymbol._kind === 'import' || mixinRefSymbol._kind === 'class')) {
                    mixins_1.push({
                        mixin: mixin,
                        ref: mixinRefSymbol
                    });
                }
                else {
                    _this.diagnostics.warn(decl, exports.processorWarnings.UNKNOWN_MIXIN(mixin.type), { word: mixin.type });
                }
            });
            if (rule.mixins) {
                this.diagnostics.warn(decl, exports.processorWarnings.OVERRIDE_MIXIN());
            }
            rule.mixins = mixins_1;
        }
        else if (decl.prop === stylable_value_parsers_1.valueMapping.compose) {
            var composes = parseCompose(decl, this.diagnostics);
            if (rule.isSimpleSelector) {
                var composeSymbols = composes.map(function (name) {
                    var extendsRefSymbol = _this.meta.mappedSymbols[name];
                    if (extendsRefSymbol &&
                        (extendsRefSymbol._kind === 'import' || extendsRefSymbol._kind === 'class')) {
                        return extendsRefSymbol;
                    }
                    else {
                        _this.diagnostics.warn(decl, exports.processorWarnings.CANNOT_RESOLVE_COMPOSE(name), { word: name });
                        return null;
                    }
                }).filter(function (x) { return !!x; });
                this.extendTypedRule(decl, rule.selector, stylable_value_parsers_1.valueMapping.compose, composeSymbols);
            }
            else {
                this.diagnostics.warn(decl, exports.processorWarnings.CANNOT_COMPOSE_IN_COMPLEX());
            }
        }
        else if (decl.prop === stylable_value_parsers_1.valueMapping.global) {
            if (rule.isSimpleSelector && rule.selectorType !== 'element') {
                this.setClassGlobalMapping(decl, rule);
            }
            else {
                // TODO: diagnostics - scoped on none class
            }
        }
    };
    StylableProcessor.prototype.setClassGlobalMapping = function (decl, rule) {
        var name = rule.selector.replace('.', '');
        var typedRule = this.meta.classes[name];
        if (typedRule) {
            typedRule[stylable_value_parsers_1.valueMapping.global] = parseGlobal(decl, this.diagnostics);
        }
    };
    StylableProcessor.prototype.extendTypedRule = function (node, selector, key, value) {
        var name = selector.replace('.', '');
        var typedRule = this.meta.mappedSymbols[name];
        if (typedRule && typedRule[key]) {
            this.diagnostics.warn(node, exports.processorWarnings.OVERRIDE_TYPED_RULE(key, name), { word: name });
        }
        if (typedRule) {
            typedRule[key] = value;
        }
    };
    StylableProcessor.prototype.handleImport = function (rule) {
        var _this = this;
        var importObj = {
            defaultExport: '', from: '', fromRelative: '', named: {}, overrides: [], rule: rule, theme: false
        };
        rule.walkDecls(function (decl) {
            switch (decl.prop) {
                case stylable_value_parsers_1.valueMapping.from:
                    var importPath = utils_1.stripQuotation(decl.value);
                    if (!path.isAbsolute(importPath) && !importPath.startsWith('.')) {
                        importObj.fromRelative = importPath;
                        importObj.from = importPath;
                    }
                    else {
                        importObj.fromRelative = importPath;
                        importObj.from = path.resolve(path.dirname(_this.meta.source), importPath);
                    }
                    break;
                case stylable_value_parsers_1.valueMapping.default:
                    importObj.defaultExport = decl.value;
                    if (!selector_utils_1.isCompRoot(importObj.defaultExport) && importObj.from.match(/\.css$/)) {
                        _this.diagnostics.warn(decl, exports.processorWarnings.DEFAULT_IMPORT_IS_LOWER_CASE(), { word: importObj.defaultExport });
                    }
                    break;
                case stylable_value_parsers_1.valueMapping.named:
                    importObj.named = parseNamed(decl.value);
                    break;
                case stylable_value_parsers_1.valueMapping.theme:
                    importObj.theme = parseTheme(decl.value);
                    break;
                default:
                    importObj.overrides.push(decl);
                    break;
            }
        });
        if (!importObj.theme) {
            importObj.overrides.forEach(function (decl) {
                _this.diagnostics.warn(decl, exports.processorWarnings.ILLEGAL_PROP_IN_IMPORT(decl.prop), { word: decl.prop });
            });
        }
        if (!importObj.from) {
            this.diagnostics.error(rule, exports.processorWarnings.FROM_PROP_MISSING_IN_IMPORT());
        }
        rule.remove();
        return importObj;
    };
    return StylableProcessor;
}());
exports.StylableProcessor = StylableProcessor;
function createEmptyMeta(root, diagnostics) {
    utils_1.deprecated('createEmptyMeta is deprecated and will be removed in the next version. Use "new StylableMeta()"');
    return new stylable_meta_1.StylableMeta(root, diagnostics);
}
exports.createEmptyMeta = createEmptyMeta;
function processNamespace(namespace, source) {
    return namespace + hash.v3(source); // .toString(36);
}
exports.processNamespace = processNamespace;
function process(root, diagnostics, resolveNamespace) {
    if (diagnostics === void 0) { diagnostics = new diagnostics_1.Diagnostics(); }
    return new StylableProcessor(diagnostics, resolveNamespace).process(root);
}
exports.process = process;
//# sourceMappingURL=stylable-processor.js.map