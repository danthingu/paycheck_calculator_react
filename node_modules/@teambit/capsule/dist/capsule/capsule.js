"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const state_1 = __importDefault(require("./state"));
const path = __importStar(require("path"));
const p_limit_1 = __importDefault(require("p-limit"));
const any_fs_1 = require("@teambit/any-fs");
const console_1 = __importDefault(require("./console"));
class Capsule {
    constructor(
    /**
     * container implementation the capsule is being executed within.
     */
    container, 
    /**
     * the capsule's file system.
     */
    fs, 
    /**
     * console for controlling process streams as stdout, stdin and stderr.
     */
    console, 
    /**
     * capsule's state.
     */
    state, 
    /**
     * config to pass capsule */
    config = {}) {
        this.container = container;
        this.fs = fs;
        this.console = console;
        this.state = state;
        this.config = config;
    }
    // implement this to handle capsules ids.
    get id() {
        return '';
    }
    get containerId() {
        return this.container.id;
    }
    run(modulePath, options) {
        return new Promise((resolve, reject) => {
            console.log(`running script: ${modulePath} in capsule`);
            return this.exec({ command: ['node', `./node_modules/${modulePath}`] })
                .then(exec => {
                let data = '';
                let err = '';
                exec.stdout.on('data', (chunk) => {
                    data += chunk.toString('utf8');
                });
                exec.stderr.on('data', (chunk) => {
                    err += chunk.toString('utf8');
                });
                exec.on('error', () => {
                });
                exec.on('close', () => {
                    console.log(err, data);
                    if (err !== '')
                        return reject(err);
                    resolve(data);
                });
            });
        });
    }
    async runFn(fn, options) {
        return new Promise((resolve, reject) => {
            const serFn = `const fn = ${fn.toString()}\nprocess.stdout.write(fn().toString());`;
            const fileName = `__run__${Date.now()}.js`;
            const filepath = options ? options.cwd + fileName : fileName;
            this.fs.writeFileSync(filepath, serFn);
            // console.log('running script', serFn);
            return this.exec({ command: ['node', filepath] })
                .then((exec) => {
                // handle streaming
                // handle response and serialization
                // resolve modules from path (e.g. extension node_modules)
                let data = '';
                let err = '';
                exec.stdout.on('data', (chunk) => {
                    data += chunk.toString('utf8');
                });
                exec.stderr.on('data', (chunk) => {
                    err += chunk.toString('utf8');
                });
                exec.on('error', () => {
                });
                exec.on('close', () => {
                    console.log(err, data);
                    if (err !== '')
                        return reject(err);
                    this.fs.unlinkSync(filepath);
                    resolve(data);
                });
            });
        });
    }
    start() {
        return this.container.start();
    }
    serialize() {
        return JSON.stringify(Object.assign({
            id: this.containerId
        }, this.config));
    }
    log() {
        return this.container.log();
    }
    on(event, fn) {
        this.container.on(event, fn);
    }
    async updateFs(fs) {
        const limit = p_limit_1.default(1);
        const queueWrite = Object.keys(fs).map(async (filePath) => {
            return limit(async () => {
                await this.fs.promises.mkdir(path.dirname(filePath), {
                    recursive: true
                });
                await this.fs.promises.writeFile(filePath, fs[filePath]);
            });
        });
        await Promise.all(queueWrite);
        return;
    }
    pause() {
        return this.container.pause();
    }
    resume() {
        return this.container.resume();
    }
    stop() {
        return this.container.stop();
    }
    status() {
        return this.container.inspect();
    }
    async exec(execOpions) {
        return this.container.exec(execOpions);
    }
    destroy() {
        return this.container.stop();
    }
    static async create(containerFactory, volume = new any_fs_1.MemoryFS(), config = {}, initialState = new state_1.default(), console = new console_1.default()) {
        const container = await containerFactory.createContainer(config);
        return new this(container, container.fs, console, initialState, config);
    }
    static async obtain(containerFactory, raw) {
        const object = JSON.parse(raw);
        const container = await containerFactory.obtain(object);
        return new this(container, container.fs, new console_1.default(), new state_1.default());
    }
}
exports.default = Capsule;
//# sourceMappingURL=capsule.js.map