"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const duplex_buffer_stream_1 = require("./duplex-buffer-stream");
const fixtures_1 = __importDefault(require("./fixtures"));
describe('WritableStreamBuffer with defaults', function () {
    beforeEach(function () {
        this.buffer = new duplex_buffer_stream_1.DuplexBufferStream();
    });
    it('returns false on call to getContents() when empty', function () {
        chai_1.expect(this.buffer.getContents()).to.equal('');
    });
    it('returns false on call to getContentsAsString() when empty', function () {
        chai_1.expect(this.buffer.getContentsAsString()).to.equal('');
    });
    it('backing buffer should be default size', function () {
        chai_1.expect(this.buffer.maxSize()).to.equal(duplex_buffer_stream_1.DEFAULT_INITIAL_SIZE);
    });
    describe('when writing a simple string', function () {
        beforeEach(function () {
            this.buffer.write(fixtures_1.default.simpleString);
        });
        it('should have a backing buffer of correct length', function () {
            chai_1.expect(this.buffer.size).to.equal(fixtures_1.default.simpleString.length);
        });
        it('should have a default max size', function () {
            chai_1.expect(this.buffer.maxSize()).to.equal(duplex_buffer_stream_1.DEFAULT_INITIAL_SIZE);
        });
        it('contents should be correct', function () {
            chai_1.expect(this.buffer.getContentsAsString()).to.equal(fixtures_1.default.simpleString);
        });
        it('returns partial contents correctly', function () {
            var buf = Buffer.concat([
                this.buffer.getContents(Math.floor(Buffer.byteLength(fixtures_1.default.simpleString) / 2)),
                this.buffer.getContents()
            ]);
            chai_1.expect(buf.toString()).to.equal(fixtures_1.default.simpleString);
        });
    });
    describe('when writing a large binary blob', function () {
        beforeEach(function () {
            this.buffer.write(fixtures_1.default.largeBinaryData);
        });
        it('should have a backing buffer of correct length', function () {
            chai_1.expect(this.buffer.size).to.equal(fixtures_1.default.largeBinaryData.length);
        });
        it('should have a larger backing buffer max size', function () {
            chai_1.expect(this.buffer.maxSize()).to.equal(duplex_buffer_stream_1.DEFAULT_INITIAL_SIZE + duplex_buffer_stream_1.DEFAULT_INCREMENT_AMOUNT);
        });
        it('contents are valid', function () {
            chai_1.expect(this.buffer.getContents()).to.deep.equal(fixtures_1.default.largeBinaryData);
        });
    });
    describe('when writing some simple data to the stream', function () {
        beforeEach(function () {
            this.buffer = new duplex_buffer_stream_1.DuplexBufferStream();
            this.buffer.write(fixtures_1.default.simpleString);
        });
        describe('and retrieving half of it', function () {
            beforeEach(function () {
                this.firstStr = this.buffer.getContentsAsString('utf8', Math.floor(fixtures_1.default.simpleString.length / 2));
            });
            it('returns correct data', function () {
                chai_1.expect(this.firstStr).to.equal(fixtures_1.default.simpleString.substring(0, Math.floor(fixtures_1.default.simpleString.length / 2)));
            });
            it('leaves correct amount of data remaining in buffer', function () {
                chai_1.expect(this.buffer.size).to.equal(Math.ceil(fixtures_1.default.simpleString.length / 2));
            });
            describe('and then retrieving the other half of it', function () {
                beforeEach(function () {
                    this.secondStr = this.buffer.getContentsAsString('utf8', Math.ceil(fixtures_1.default.simpleString.length / 2));
                });
                it('returns correct data', function () {
                    chai_1.expect(this.secondStr).to.equal(fixtures_1.default.simpleString.substring(Math.floor(fixtures_1.default.simpleString.length / 2)));
                });
                it('results in an empty buffer', function () {
                    chai_1.expect(this.buffer.size).to.equal(0);
                });
            });
        });
    });
});
describe('WritableStreamBuffer with a different initial size and increment amount', function () {
    beforeEach(function () {
        this.buffer = new duplex_buffer_stream_1.DuplexBufferStream(62, 321);
    });
    it('has the correct initial size', function () {
        chai_1.expect(this.buffer.maxSize()).to.equal(62);
    });
    describe('after data is written', function () {
        beforeEach(function () {
            this.buffer.write(fixtures_1.default.binaryData);
        });
        it('has correct initial size + custom increment amount', function () {
            chai_1.expect(this.buffer.maxSize()).to.equal(321 + 62);
        });
    });
});
describe('When WritableStreamBuffer is written in two chunks', function () {
    beforeEach(function () {
        this.buffer = new duplex_buffer_stream_1.DuplexBufferStream();
        this.buffer.write(fixtures_1.default.simpleString);
        this.buffer.write(fixtures_1.default.simpleString);
    });
    it('buffer contents are correct', function () {
        chai_1.expect(this.buffer.getContentsAsString()).to.equal(fixtures_1.default.simpleString + fixtures_1.default.simpleString);
    });
});
describe('A default ReadableStreamBuffer', function () {
    beforeEach(function () {
        this.buffer = new duplex_buffer_stream_1.DuplexBufferStream();
    });
    it('is a Stream', function () {
        chai_1.expect(this.buffer).to.be.an.instanceOf(require('stream').Stream);
    });
    it('is empty by default', function () {
        chai_1.expect(this.buffer.size).to.equal(0);
    });
    it('has default backing buffer size', function () {
        chai_1.expect(this.buffer.maxSize()).to.equal(duplex_buffer_stream_1.DEFAULT_INITIAL_SIZE);
    });
    it('emits end event after data, when stopped', function (done) {
        var that = this;
        var str = '';
        this.buffer.on('readable', function () {
            str += (that.buffer.read() || new Buffer(0)).toString('utf8');
        });
        this.buffer.on('end', function () {
            chai_1.expect(str).to.equal(fixtures_1.default.unicodeString);
            done();
        });
        this.buffer.write(fixtures_1.default.unicodeString);
        this.buffer.stop();
    });
    // it('pushes new data even if read when empty', function(done) {
    //   var that = this;
    //   var str = '';
    //   this.buffer.on('readable', function() {
    //     str += (that.buffer.read() || new Buffer(0)).toString('utf8');
    //   });
    //   this.buffer.on('end', function() {
    //     expect(str).to.equal(fixtures.unicodeString);
    //     done();
    //   });
    //   setTimeout(function() {
    //     that.buffer.write(fixtures.unicodeString, () => {
    //       that.buffer.stop();
    //     });
    //   }, DEFAULT_FREQUENCY + 1);
    // });
    describe('when writing binary data', function () {
        beforeEach(function (done) {
            var that = this;
            this.buffer.write(fixtures_1.default.binaryData);
            this.buffer.once('readable', function () {
                that.data = that.buffer.read();
                done();
            });
        });
        it('results in a Buffer', function () {
            chai_1.expect(this.data).to.be.an.instanceOf(Buffer);
        });
        it('with the correct data', function () {
            chai_1.expect(this.data).to.deep.equal(fixtures_1.default.binaryData);
        });
    });
    it('supports putting in hex data', function (done) {
        this.buffer.write('BEEF', 'hex');
        var that = this;
        this.buffer.once('readable', function () {
            var buf = that.buffer.read();
            chai_1.expect(buf[0]).to.equal(190);
            chai_1.expect(buf[1]).to.equal(239);
            done();
        });
    });
    describe('when writing binary data larger than initial backing buffer size', function () {
        beforeEach(function () {
            this.buffer.pause();
            this.buffer.write(fixtures_1.default.largeBinaryData);
        });
        it('buffer is correct size', function () {
            chai_1.expect(this.buffer.size).to.equal(fixtures_1.default.largeBinaryData.length);
        });
        it('backing buffer is correct size', function () {
            chai_1.expect(this.buffer.maxSize()).to.equal(duplex_buffer_stream_1.DEFAULT_INITIAL_SIZE + duplex_buffer_stream_1.DEFAULT_INCREMENT_AMOUNT);
        });
    });
});
describe('A ReadableStreamBuffer using custom chunk size', function () {
    beforeEach(function (done) {
        var that = this;
        this.buffer = new duplex_buffer_stream_1.DuplexBufferStream(undefined, undefined, undefined, 2);
        this.buffer.once('readable', function () {
            that.data = that.buffer.read();
            done();
        });
        this.buffer.write(fixtures_1.default.binaryData);
    });
    it('yields a Buffer with the correct data', function () {
        chai_1.expect(this.data).to.deep.equal(fixtures_1.default.binaryData.slice(0, 2));
    });
});
describe('A ReadableStreamBuffer using custom frequency', function () {
    beforeEach(function (done) {
        var that = this;
        var startTime = new Date().getTime();
        this.buffer = new duplex_buffer_stream_1.DuplexBufferStream(undefined, undefined, 300, undefined);
        this.buffer.once('readable', function () {
            that.time = new Date().getTime() - startTime;
            done();
        });
        this.buffer.write(fixtures_1.default.binaryData);
    });
    it('gave us data after the correct amount of time', function () {
        // Wtfux: sometimes the timer is coming back a millisecond or two
        // faster. So we do a 'close-enough' assertion here ;)
        chai_1.expect(this.time).to.be.at.least(295);
    });
});
//# sourceMappingURL=duplex-buffer-stream.spec.js.map