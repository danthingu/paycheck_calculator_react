"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
exports.DEFAULT_INITIAL_SIZE = 8 * 1024;
exports.DEFAULT_INCREMENT_AMOUNT = 8 * 1024;
exports.DEFAULT_FREQUENCY = 1;
exports.DEFAULT_CHUNK_SIZE = 1024;
class DuplexBufferStream extends stream_1.Duplex {
    constructor(initialSize = exports.DEFAULT_INITIAL_SIZE, incrementAmount = exports.DEFAULT_INCREMENT_AMOUNT, frequency = exports.DEFAULT_FREQUENCY, chunkSize = exports.DEFAULT_CHUNK_SIZE) {
        super();
        this.initialSize = initialSize;
        this.incrementAmount = incrementAmount;
        this.frequency = frequency;
        this.chunkSize = chunkSize;
        this.buffer = Buffer.alloc(this.initialSize);
        this.size = 0;
        this.allowPush = false;
        this.stopped = false;
        this.timeout = null;
        this.sendData = () => {
            const amount = Math.min(this.chunkSize, this.size);
            let sendMore = false;
            if (amount > 0) {
                const chunk = Buffer.alloc(amount);
                this.buffer.copy(chunk, 0, 0, amount);
                sendMore = this.push(chunk) !== false;
                this.allowPush = sendMore;
                this.buffer.copy(this.buffer, 0, amount, this.size);
                this.size -= amount;
            }
            if (this.size === 0 && this.stopped) {
                this.push(null);
            }
            if (sendMore) {
                this.timeout = setTimeout(this.sendData, this.frequency);
            }
            else {
                this.timeout = null;
            }
        };
    }
    maxSize() {
        return this.buffer.length;
    }
    getContents(length) {
        if (!this.size)
            return '';
        const data = Buffer.alloc(Math.min(length || this.size, this.size));
        this.buffer.copy(data, 0, 0, data.length);
        if (data.length < this.size)
            this.buffer.copy(this.buffer, 0, data.length);
        this.size -= data.length;
        return data;
    }
    getContentsAsString(encoding, length) {
        if (!this.size)
            return '';
        const data = this.buffer.toString(encoding, 0, Math.min(length || this.size, this.size));
        const dataLength = Buffer.byteLength(data);
        if (dataLength < this.size)
            this.buffer.copy(this.buffer, 0, dataLength);
        this.size -= dataLength;
        return data;
    }
    _write(chunk, encoding, done) {
        this.emit('data', chunk);
        this.increaseBufferIfNecessary(chunk.length);
        chunk.copy(this.buffer, this.size, 0);
        this.size += chunk.length;
        done();
    }
    increaseBufferIfNecessary(incomingDataSize) {
        if (this.buffer.length - this.size < incomingDataSize) {
            const factor = Math.ceil((incomingDataSize - (this.buffer.length - this.size)) /
                this.incrementAmount);
            const newBuffer = Buffer.alloc(this.buffer.length + this.incrementAmount * factor);
            this.buffer.copy(newBuffer, 0, 0, this.size);
            this.buffer = newBuffer;
        }
    }
    initiateSendData() {
        if (!this.timeout && this.allowPush) {
            this.timeout = setTimeout(this.sendData, this.frequency);
        }
    }
    stop() {
        this.stopped = true;
    }
    _read() {
        this.allowPush = true;
        this.initiateSendData();
    }
}
exports.DuplexBufferStream = DuplexBufferStream;
//# sourceMappingURL=duplex-buffer-stream.js.map