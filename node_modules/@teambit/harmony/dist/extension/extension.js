"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const extension_init_error_1 = require("../exceptions/extension-init-error");
/**
 * harmony's extension definition. this can be used to define and extend `Harmony` applications.
 */
class Extension {
    constructor(
    /**
     * manifest of the extension.
     */
    manifest) {
        this.manifest = manifest;
        this._instance = null;
        this._loaded = false;
    }
    /**
     * returns the instance of the extension
     */
    get instance() {
        return this._instance;
    }
    get name() {
        const metadata = Reflect.getMetadata('harmony:name', this.manifest);
        return metadata || this.manifest.id || this.manifest.name;
    }
    get dependencies() {
        const metadata = Reflect.getMetadata('harmony:dependencies', this.manifest);
        return metadata || this.manifest.dependencies || [];
    }
    get provider() {
        const metadata = Reflect.getMetadata('harmony:provider', this.manifest);
        return metadata || this.manifest.provider;
    }
    /**
     * returns an indication of the extension already loaded (the provider run)
     * We don't rely on the instance since an extension provider might return null
     */
    get loaded() {
        return this._loaded;
    }
    toString() {
        return JSON.stringify(this.name);
    }
    buildSlotRegisties(slots, context) {
        return slots.map((slot) => {
            return slot(() => {
                return context.current;
            });
        });
    }
    /**
     * initiate Harmony in run-time.
     */
    __run(dependencies, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const name = this.name;
            context.initExtension(name);
            // @ts-ignore
            const registries = this.buildSlotRegisties(this.manifest.slots || [], context);
            const config = context.config.get(name) || this.manifest.defaultConfig;
            if (!this.loaded) {
                if (this.provider)
                    this._instance = yield this.provider(dependencies, config, registries, context);
                else {
                    try {
                        // @ts-ignore
                        this._instance = new this.manifest(...dependencies);
                    }
                    catch (err) {
                        throw new extension_init_error_1.ExtensionInstantiationException(err.toString());
                    }
                }
                ;
                // @ts-ignore adding the extension ID to the instance.
                // this._instance.id = this.manifest.name;
                // @ts-ignore adding the extension ID to the instance.
                // this._instance.config = config;
                this._loaded = true;
                return this._instance;
            }
            context.endExtension();
            return Promise.resolve(this.instance);
        });
    }
}
exports.Extension = Extension;
