import 'reflect-metadata';
import ExtensionGraph from './extension-graph/extension-graph';
import { Extension, ExtensionManifest } from './extension';
import { Config } from './config';
export declare type GlobalConfig = {
    [key: string]: object;
};
export declare class Harmony {
    /**
     * extension graph
     */
    private graph;
    /**
     * harmony top level config
     */
    readonly config: Config;
    constructor(
    /**
     * extension graph
     */
    graph: ExtensionGraph, 
    /**
     * harmony top level config
     */
    config: Config);
    current: string | null;
    /**
     * list all registered extensions
     */
    get extensions(): Map<string, Extension>;
    /**
     * list all registered extensions ids
     */
    get extensionsIds(): string[];
    /**
     * set extensions during Harmony runtime.
     */
    set(extensions: ExtensionManifest[]): Promise<void>;
    private runOne;
    initExtension(id: string): void;
    endExtension(): void;
    /**
     * get an extension from harmony.
     */
    get<T>(id: string): T;
    /**
     * execute harmony extension. applies providers of all extensions by execution order.
     */
    run(manifest: ExtensionManifest | ExtensionManifest[]): Promise<void>;
    /**
     * load harmony from a root extensions
     */
    static load(extensions: ExtensionManifest[], globalConfig: GlobalConfig): Harmony;
    /**
     * load all extensions and execute harmony.
     */
    static run(extension: ExtensionManifest): Promise<void>;
}
declare const _default: Harmony;
export default _default;
