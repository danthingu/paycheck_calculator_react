"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const harmony_1 = __importStar(require("./harmony"));
const chai_1 = require("chai");
// import { BitExt } from '../../bit/dist/extensions/bit';
const base_compiler_1 = require("./fixtures/base-compiler");
const typescript_1 = require("./fixtures/typescript/typescript");
const babel_extension_1 = require("./fixtures/babel/babel.extension");
const slots_1 = require("./slots");
describe('Harmony', () => {
    describe('run()', () => {
        it('should return a string', () => __awaiter(void 0, void 0, void 0, function* () {
            const manifest = {
                name: 'HelloWorld',
                provider: () => __awaiter(void 0, void 0, void 0, function* () { return 'hello world'; })
            };
            yield harmony_1.default.run(manifest);
            chai_1.expect(harmony_1.default.get('HelloWorld')).eql('hello world');
        }));
        it('should load an array of different extensions', () => __awaiter(void 0, void 0, void 0, function* () {
            yield harmony_1.default.run([base_compiler_1.BaseCompiler, typescript_1.TypeScript]);
            const compiler = harmony_1.default.get('BaseCompiler');
            const typescript = harmony_1.default.get('typescript');
            chai_1.expect(typescript.compile()).to.eq('hello world');
            chai_1.expect(compiler.compile()).to.eq('hello world');
        }));
        it('should load extensions with slots', () => __awaiter(void 0, void 0, void 0, function* () {
            class Env {
                build() {
                    return 'react built';
                }
            }
            it('extension instance should include an ID', () => __awaiter(void 0, void 0, void 0, function* () {
                const React = {
                    name: '@teambit/react',
                    dependencies: [],
                    provide: () => __awaiter(void 0, void 0, void 0, function* () { })
                };
                yield harmony.run([React]);
                const react = harmony.get(React.name);
                chai_1.expect(react.id).to.eq(React.name);
            }));
            const Envs = {
                name: '@teambit/envs',
                slots: [slots_1.Slot.withType()],
                provider: ([], config, [envSlot]) => __awaiter(void 0, void 0, void 0, function* () {
                    return {
                        register: (env) => {
                            envSlot.register(env);
                        },
                        start() {
                            const instance = envSlot.get(config.env);
                            if (!instance)
                                throw new Error('could not find envs');
                            return instance.build();
                        }
                    };
                })
            };
            const React = {
                name: '@teambit/react',
                dependencies: [Envs],
                provide: ([envs], config) => __awaiter(void 0, void 0, void 0, function* () {
                    envs.register(new Env());
                })
            };
            const harmony = harmony_1.Harmony.load([Envs, React], {
                '@teambit/envs': {
                    env: '@teambit/react'
                }
            });
            yield harmony.run([Envs, React]);
            const envs = harmony.get(Envs.name);
            chai_1.expect(envs.start()).to.eq('react built');
        }));
        it('should load extensions with config', () => __awaiter(void 0, void 0, void 0, function* () {
            const e1 = {
                name: '@teambit/typescript',
                provider: ([], config) => __awaiter(void 0, void 0, void 0, function* () {
                    return {
                        get: () => {
                            return config.declarations || false;
                        }
                    };
                })
            };
            const e2 = { name: '@teambit/react', defaultConfig: { ts: false }, provide: ([], config) => __awaiter(void 0, void 0, void 0, function* () {
                    return {
                        config: config.ts
                    };
                })
            };
            const harmony = harmony_1.Harmony.load([e1], {
                '@teambit/typescript': {
                    declarations: true
                },
            });
            yield harmony.run([e1]);
            const ts = harmony.get('@teambit/typescript');
            chai_1.expect(ts.get()).to.eq(true);
            harmony.config.set('@teambit/react', { ts: true });
            yield harmony.set([e2]);
            const react = harmony.get('@teambit/react');
            chai_1.expect(react.config).to.eq(true);
        }));
        it('should invoke a class extension method', () => __awaiter(void 0, void 0, void 0, function* () {
            yield harmony_1.default.run(base_compiler_1.BaseCompiler);
            const compiler = harmony_1.default.get('BaseCompiler');
            chai_1.expect(compiler.compile()).to.eq('hello world');
        }));
        it('should invoke a class extension with configured dependencies', () => __awaiter(void 0, void 0, void 0, function* () {
            yield harmony_1.default.run(typescript_1.TypeScript);
            const typescript = harmony_1.default.get('typescript');
            chai_1.expect(typescript.compile()).to.eq('hello world');
        }));
        it('should use prefer id over name', () => __awaiter(void 0, void 0, void 0, function* () {
            const dependency = {
                name: 'dependencyName',
                id: 'dependencyId',
                provider: () => __awaiter(void 0, void 0, void 0, function* () { return 'hello world'; })
            };
            const dependent = {
                name: 'dependentName',
                id: 'dependentId',
                dependencies: [dependency],
                provider: () => __awaiter(void 0, void 0, void 0, function* () { return 'hello world'; })
            };
            yield harmony_1.default.run(dependent);
            const ids = harmony_1.default.extensionsIds;
            chai_1.expect(ids).to.contain('dependencyId');
            chai_1.expect(ids).to.contain('dependentId');
        }));
        it('should execute bit core extension graph', () => __awaiter(void 0, void 0, void 0, function* () {
            // const bit = await Harmony.run(BitExt);
        }));
        it('should register during run', () => __awaiter(void 0, void 0, void 0, function* () {
            const compiler = yield harmony_1.default.run(babel_extension_1.Babel);
        }));
    });
});
