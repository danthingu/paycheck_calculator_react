"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PkgExtension = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _harmony() {
  const data = require("@teambit/harmony");

  _harmony = function () {
    return data;
  };

  return data;
}

function _scope() {
  const data = require("../scope");

  _scope = function () {
    return data;
  };

  return data;
}

function _pack() {
  const data = require("./pack.cmd");

  _pack = function () {
    return data;
  };

  return data;
}

function _pack2() {
  const data = require("./pack");

  _pack2 = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = _interopRequireDefault(require("../../consumer/component"));

  _component = function () {
    return data;
  };

  return data;
}

function _environments() {
  const data = require("../environments");

  _environments = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("../cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _isolator() {
  const data = require("../isolator");

  _isolator = function () {
    return data;
  };

  return data;
}

// import { BitCli as CLI, BitCliExt as CLIExtension } from '../cli';
class PkgExtension {
  static provider([cli, scope, envs, isolator], config, [packageJsonPropsRegistry]) {
    const packer = new (_pack2().Packer)(isolator, scope === null || scope === void 0 ? void 0 : scope.legacyScope);
    const pkg = new PkgExtension(config, packageJsonPropsRegistry, packer, envs); // TODO: maybe we don't really need the id here any more

    _component().default.registerAddConfigAction(PkgExtension.id, pkg.mergePackageJsonProps.bind(pkg)); // TODO: consider passing the pkg instead of packer


    cli.register(new (_pack().PackCmd)(packer));
    return pkg;
  }
  /**
   *Creates an instance of PkgExtension.
   * @param {PkgExtensionConfig} config
   * @param {PackageJsonPropsRegistry} packageJsonPropsRegistry
   * @param {Packer} packer
   * @memberof PkgExtension
   */


  constructor(config, packageJsonPropsRegistry, packer, envs) {
    this.config = config;
    this.packageJsonPropsRegistry = packageJsonPropsRegistry;
    this.packer = packer;
    this.envs = envs;
  }
  /**
   * register changes in the package.json
   */


  registerPackageJsonNewProps(props) {
    return this.packageJsonPropsRegistry.register(props);
  }
  /**
   * Pack a component and generate a tarball suitable for npm registry
   *
   * @param {string} componentId
   * @param {(string | undefined)} scopePath
   * @param {string} outDir
   * @param {boolean} [prefix=false]
   * @param {boolean} [override=false]
   * @param {boolean} [keep=false]
   * @returns {Promise<PackResult>}
   * @memberof PkgExtension
   */


  packComponent(componentId, scopePath, options) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      return _this.packer.packComponent(componentId, scopePath, options);
    })();
  }
  /**
   * Merge the configs provided by:
   * 1. envs configured in the component - via getPackageJsonProps method
   * 2. extensions that registered to the registerPackageJsonNewProps slot (and configured for the component)
   * 3. props defined by the user (they are the strongest one)
   * @param configuredExtensions
   */


  mergePackageJsonProps(configuredExtensions) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      let newProps = {};

      const env = _this2.envs.getEnvFromExtensions(configuredExtensions);

      if ((env === null || env === void 0 ? void 0 : env.getPackageJsonProps) && typeof env.getPackageJsonProps === 'function') {
        const propsFromEnv = yield env.getPackageJsonProps();
        newProps = Object.assign(newProps, propsFromEnv);
      }

      const configuredIds = configuredExtensions.ids;
      configuredIds.forEach(extId => {
        // Only get props from configured extensions on this specific component
        const props = _this2.packageJsonPropsRegistry.get(extId);

        if (props) {
          newProps = Object.assign(newProps, props);
        }
      });
      const currentExtension = configuredExtensions.findExtension(PkgExtension.id);
      const currentConfig = currentExtension === null || currentExtension === void 0 ? void 0 : currentExtension.config;

      if (currentConfig && currentConfig.packageJson) {
        newProps = Object.assign(newProps, currentConfig.packageJson);
      }

      return newProps;
    })();
  }

}

exports.PkgExtension = PkgExtension;
(0, _defineProperty2().default)(PkgExtension, "id", '@teambit/pkg');
(0, _defineProperty2().default)(PkgExtension, "dependencies", [_cli().CLIExtension, _scope().ScopeExtension, _environments().Environments, _isolator().IsolatorExtension]);
(0, _defineProperty2().default)(PkgExtension, "slots", [_harmony().Slot.withType()]);
(0, _defineProperty2().default)(PkgExtension, "defaultConfig", {});