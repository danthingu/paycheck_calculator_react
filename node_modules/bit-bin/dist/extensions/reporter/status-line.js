"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _stringToColor() {
  const data = _interopRequireDefault(require("string-to-color"));

  _stringToColor = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _ora() {
  const data = _interopRequireDefault(require("ora"));

  _ora = function () {
    return data;
  };

  return data;
}

function _debounce() {
  const data = _interopRequireDefault(require("debounce"));

  _debounce = function () {
    return data;
  };

  return data;
}

function _getColumnCount() {
  const data = _interopRequireDefault(require("./get-column-count"));

  _getColumnCount = function () {
    return data;
  };

  return data;
}

// this number is added to status line length calculations.
// the idea is to assume we have a longer status line to make
// up for the js runtime speed
const SPACE_BUFFER = 10;

function clearStatusRow() {
  // eslint-disable-next-line no-console
  console.log(`\r${Array((0, _getColumnCount().default)()).fill(' ').join('')}`);
} // we send a proxy to the spinner instance rather than proxess.stdout
// so that we would be able to bypass our monkey-patch of process.stdout
// this is so that we won't have a case where the stdout "write" method
// triggers itself through the spinner by doing "spinner.start()" or "spinner.stop()"


const originalStdoutWrite = process.stdout.write.bind(process.stdout);
const stdoutProxy = new Proxy(process.stdout, {
  get(obj, prop) {
    if (prop === 'write') {
      return originalStdoutWrite;
    }

    return obj[prop];
  }

});
const originalStderrWrite = process.stderr.write.bind(process.stderr);

class StatusLine {
  // 6 for spinner, 1 for space after it
  constructor() {
    (0, _defineProperty2().default)(this, "buffer", SPACE_BUFFER);
    (0, _defineProperty2().default)(this, "spinner", (0, _ora().default)({
      spinner: 'bouncingBar',
      stream: stdoutProxy,
      isEnabled: true
    }).stop());
    (0, _defineProperty2().default)(this, "spinnerLength", 7);
    (0, _defineProperty2().default)(this, "text", '');
    (0, _defineProperty2().default)(this, "ids", []);
    (0, _defineProperty2().default)(this, "ended", false);
    this.reRender = (0, _debounce().default)(this.reRender, 100); // @ts-ignore
    // here we monkey-patch the process.stdout stream so that whatever is printed
    // does not break the status line with the spinner, and that this line always
    // remains at the bottom of the screen

    process.stdout.write = (buffer, encoding, callback) => {
      const wasSpinning = this.spinner.isSpinning;

      if (wasSpinning) {
        this.spinner.stop();
      }

      originalStdoutWrite(buffer, encoding, callback);

      if (wasSpinning) {
        this.spinner.start();
      }
    }; // @ts-ignore


    process.stderr.write = (buffer, encoding, callback) => {
      const wasSpinning = this.spinner.isSpinning;

      if (wasSpinning) {
        this.spinner.stop();
      }

      originalStderrWrite(buffer, encoding, callback);

      if (wasSpinning) {
        this.spinner.start();
      }
    };
  }

  addId(id) {
    this.ids.push(id);
  }

  fullVersion(phaseName) {
    return this.ids.length > 0 ? `${phaseName}: (${this.ids.map(logId => _chalk().default.hex((0, _stringToColor().default)(logId))(logId)).join(', ')})` : phaseName || '';
  }

  fullVersionLength(text) {
    // we have to measure the length in this way because otherwise the formatting characters are measured as well
    return (this.ids.length > 0 ? `${text}: (${this.ids.join(', ')})` : text || '').length;
  }

  get minimumLength() {
    return this.spinnerLength;
  }

  shortStatusLine(text) {
    return `${text}: (...)`;
  }

  clear() {
    clearStatusRow();
    this.spinner.stop();
    this.ended = true;
  }

  clearIds() {
    this.ids = [];
  }

  stopSpinner() {
    this.spinner.stop();
  }

  startSpinner() {
    this.spinner.start();
  }

  reRender(newText) {
    if (this.ended) {
      return;
    }

    if (newText) {
      this.text = newText;
    }

    if (this.text.length === 0) {
      return;
    }

    this.spinner.stop();
    const columnCount = (0, _getColumnCount().default)();
    const spinnerLength = 7; // 6 for the spinner, 1 for the space after it

    if (columnCount < spinnerLength + 10) {
      clearStatusRow();
    } else if (columnCount < this.shortStatusLine(this.text).length + spinnerLength + SPACE_BUFFER) {
      this.spinner.text = this.text;
      this.spinner.start();
    } else if (columnCount < this.fullVersionLength(this.text) + this.spinnerLength + SPACE_BUFFER) {
      this.spinner.text = this.shortStatusLine(this.text);
      this.spinner.start();
    } else {
      this.spinner.text = this.fullVersion(this.text);
      this.spinner.start();
    }
  }

}

exports.default = StatusLine;