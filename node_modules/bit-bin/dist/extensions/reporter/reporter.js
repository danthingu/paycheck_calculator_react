"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _stringToColor() {
  const data = _interopRequireDefault(require("string-to-color"));

  _stringToColor = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("../logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _statusLine() {
  const data = _interopRequireDefault(require("./status-line"));

  _statusLine = function () {
    return data;
  };

  return data;
}

function _getColumnCount() {
  const data = _interopRequireDefault(require("./get-column-count"));

  _getColumnCount = function () {
    return data;
  };

  return data;
}

/* eslint-disable no-console */
class Reporter {
  constructor(logger) {
    this.logger = logger;
    (0, _defineProperty2().default)(this, "outputShouldBeSuppressed", false);
    (0, _defineProperty2().default)(this, "statusLine", new (_statusLine().default)());
    this.outputShouldBeSuppressed = process.argv.includes('--json') || process.argv.includes('-j');
    process.on('SIGWINCH', () => {
      const columnCount = (0, _getColumnCount().default)();

      if (columnCount < this.statusLine.minimumLength + this.statusLine.buffer) {
        this.statusLine.clear();
      }

      if (this.shouldWriteOutput) {
        this.statusLine.reRender();
      }
    });
  }

  suppressOutput() {
    this.outputShouldBeSuppressed = true;
  }
  /**
   * this text always shows in the bottom of the capsule. once it is called, it replaces the
   * previous text. as a result, at any given time only one message is shown.
   */


  setStatusText(text) {
    this.statusLine.reRender(text);
  }

  title(...messages) {
    this.statusLine.stopSpinner();
    console.log('');
    console.log(_chalk().default.bold(messages.join(' '))); // TODO: default color/style

    console.log('');
    this.statusLine.startSpinner();
  }

  info(componentId, messages) {
    const lines = messages.split(/\n/);
    this.statusLine.stopSpinner();
    lines.filter(line => line.replace(/\s+/, '').length > 0).forEach(line => {
      if (componentId) {
        console.log(_chalk().default.hex((0, _stringToColor().default)(componentId))(`${componentId}, ${line}`));
      } else {
        console.log(line);
      }
    });
    this.statusLine.startSpinner();
  }

  warn(componentId, messages) {
    const lines = messages.split(/\n/);
    this.statusLine.stopSpinner();
    lines.filter(line => line.replace(/\s+/, '').length > 0).forEach(line => {
      // console.log(chalk.yellow('warn:'), chalk.hex(stc(id))(line));
      if (componentId) {
        console.log(_chalk().default.yellow('warn:'), _chalk().default.hex((0, _stringToColor().default)(componentId))(`${componentId}, ${line}`));
      } else {
        console.log(_chalk().default.yellow('warn:'), line);
      }
    });
    this.statusLine.startSpinner();
  }

  error(componentId, messages) {
    const lines = messages.split(/\n/);
    this.statusLine.stopSpinner();
    lines.filter(line => line.replace(/\s+/, '').length > 0).forEach(line => {
      if (componentId) {
        console.log(_chalk().default.red('error:'), _chalk().default.hex((0, _stringToColor().default)(componentId))(`${componentId}, ${line}`));
      } else {
        console.log(_chalk().default.red('error:'), line);
      }
    });
    this.statusLine.startSpinner();
  }

  debug(componentId, messages) {
    const lines = messages.split(/\n/);
    this.statusLine.stopSpinner();
    lines.filter(line => line.replace(/\s+/, '').length > 0).forEach(line => {
      if (componentId) {
        console.log(_chalk().default.hex((0, _stringToColor().default)(componentId))(`${componentId}, ${line}`));
      } else {
        console.log(line);
      }
    });
    this.statusLine.startSpinner();
  }

  subscribe(extensionName) {
    this.logger.subscribe(extensionName, this.loggerCallback.bind(this));
  }

  subscribeAll() {
    this.logger.subscribeAll(this.loggerCallback.bind(this));
  }

  unsubscribe(extensionName) {
    this.logger.unsubscribe(extensionName);
  }

  end() {
    this.statusLine.clear();
  }

  loggerCallback(logEntry) {
    const {
      componentId,
      messages
    } = logEntry;

    switch (logEntry.logLevel) {
      case _logger().LogLevel.INFO:
        this.info(componentId, messages);
        break;

      case _logger().LogLevel.WARN:
        this.warn(componentId, messages);
        break;

      case _logger().LogLevel.ERROR:
        this.error(componentId, messages);
        break;

      case _logger().LogLevel.DEBUG:
        this.debug(componentId, messages);
        break;

      default:
        break;
    }
  }

  get shouldWriteOutput() {
    return !this.outputShouldBeSuppressed;
  }

}

exports.default = Reporter;