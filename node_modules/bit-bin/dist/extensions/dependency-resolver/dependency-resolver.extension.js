"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DependencyResolverExtension = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _harmony() {
  const data = require("@teambit/harmony");

  _harmony = function () {
    return data;
  };

  return data;
}

function _environments() {
  const data = require("../environments");

  _environments = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("../logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _packageManager() {
  const data = _interopRequireDefault(require("./package-manager"));

  _packageManager = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = _interopRequireDefault(require("../../consumer/component"));

  _component = function () {
    return data;
  };

  return data;
}

class DependencyResolverExtension {
  static provider([envs, logger], config, [policiesRegistry]) {
    return (0, _bluebird().coroutine)(function* () {
      const packageManager = new (_packageManager().default)(config.packageManager, logger);
      const dependencyResolver = new DependencyResolverExtension(config, packageManager, policiesRegistry, envs);

      _component().default.registerOnComponentOverridesLoading(DependencyResolverExtension.id, /*#__PURE__*/function () {
        var _ref = (0, _bluebird().coroutine)(function* (configuredExtensions) {
          const policies = yield dependencyResolver.mergeDependencies(configuredExtensions);
          return transformPoliciesToLegacyDepsOverrides(policies);
        });

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());

      return dependencyResolver;
    })();
  }

  constructor(config, packageManager, policiesRegistry, envs) {
    this.config = config;
    this.packageManager = packageManager;
    this.policiesRegistry = policiesRegistry;
    this.envs = envs;
  }

  get packageManagerName() {
    return this.config.packageManager;
  }
  /**
   * register new dependencies policies
   */


  registerDependenciesPolicies(policy) {
    return this.policiesRegistry.register(policy);
  }

  capsulesInstall(capsules, opts = {
    packageManager: this.packageManagerName
  }) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      return _this.packageManager.capsulesInstall(capsules, opts);
    })();
  }

  folderInstall(folder, opts = {
    packageManager: this.packageManagerName
  }) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      return _this2.packageManager.runInstallInFolder(folder, opts);
    })();
  }
  /**
   * Merge the dependencies provided by:
   * 1. envs configured in the component - via dependencies method
   * 2. extensions that registered to the registerDependencyPolicy slot (and configured for the component)
   * 3. props defined by the user (they are the strongest one)
   * @param configuredExtensions
   */


  mergeDependencies(configuredExtensions) {
    var _this3 = this;

    return (0, _bluebird().coroutine)(function* () {
      let policiesFromEnv = {};
      let policiesFromHooks = {};
      let policiesFromConfig = {};

      const env = _this3.envs.getEnvFromExtensions(configuredExtensions);

      if ((env === null || env === void 0 ? void 0 : env.dependencies) && typeof env.dependencies === 'function') {
        policiesFromEnv = yield env.dependencies();
      }

      const configuredIds = configuredExtensions.ids;
      configuredIds.forEach(extId => {
        // Only get props from configured extensions on this specific component
        const currentPolicy = _this3.policiesRegistry.get(extId);

        if (currentPolicy) {
          policiesFromHooks = mergePolices([policiesFromHooks, currentPolicy]);
        }
      });
      const currentExtension = configuredExtensions.findExtension(DependencyResolverExtension.id);
      const currentConfig = currentExtension === null || currentExtension === void 0 ? void 0 : currentExtension.config;

      if (currentConfig && currentConfig.policy) {
        policiesFromConfig = currentConfig.policy;
      }

      const result = mergePolices([policiesFromEnv, policiesFromHooks, policiesFromConfig]);
      return result;
    })();
  }

}

exports.DependencyResolverExtension = DependencyResolverExtension;
(0, _defineProperty2().default)(DependencyResolverExtension, "id", '@teambit/dependency-resolver');
(0, _defineProperty2().default)(DependencyResolverExtension, "dependencies", [_environments().Environments, _logger().Logger]);
(0, _defineProperty2().default)(DependencyResolverExtension, "slots", [_harmony().Slot.withType()]);
(0, _defineProperty2().default)(DependencyResolverExtension, "defaultConfig", {
  /**
   * default package manager.
   */
  packageManager: 'npm',
  policy: {},
  packageManagerArgs: [],
  strictPeerDependencies: true
});

function mergePolices(policies) {
  const result = {
    dependencies: {},
    devDependencies: {},
    peerDependencies: {}
  };
  return _ramda().default.reduce(_ramda().default.mergeDeepRight, result, policies);
}

function transformPoliciesToLegacyDepsOverrides(policy) {
  // TODO: once we support DetailedDependencyPolicy in the object we should do here something
  // TODO: it might be that we will have to return it as is, and handle it in the legacy
  // TODO: since we don't have enough info about handle force here
  return policy;
}