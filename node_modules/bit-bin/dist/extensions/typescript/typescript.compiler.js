"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypescriptCompiler = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _typescript() {
  const data = _interopRequireDefault(require("typescript"));

  _typescript = function () {
    return data;
  };

  return data;
}

class TypescriptCompiler {
  constructor(tsConfig) {
    this.tsConfig = tsConfig;
  }

  compileFile(fileContent, options) {
    const supportedExtensions = ['.ts', '.tsx'];

    const fileExtension = _path().default.extname(options.filePath);

    if (!supportedExtensions.includes(fileExtension)) {
      return null; // file is not supported
    }

    const compilerOptionsFromTsconfig = _typescript().default.convertCompilerOptionsFromJson(this.tsConfig.compilerOptions, '.');

    if (compilerOptionsFromTsconfig.errors.length) {
      throw new Error(`failed parsing the tsconfig.json.\n${compilerOptionsFromTsconfig.errors.join('\n')}`);
    }

    const compilerOptions = compilerOptionsFromTsconfig.options;
    compilerOptions.sourceRoot = options.componentDir;

    const result = _typescript().default.transpileModule(fileContent, {
      compilerOptions,
      fileName: options.filePath,
      reportDiagnostics: true
    });

    if (result.diagnostics && result.diagnostics.length) {
      const formatHost = {
        getCanonicalFileName: p => p,
        getCurrentDirectory: _typescript().default.sys.getCurrentDirectory,
        getNewLine: () => _typescript().default.sys.newLine
      };

      const error = _typescript().default.formatDiagnosticsWithColorAndContext(result.diagnostics, formatHost);

      throw new Error(error);
    }

    const replaceExtToJs = filePath => filePath.replace(new RegExp(`${fileExtension}$`), '.js'); // makes sure it's the last occurrence


    const outputPath = replaceExtToJs(options.filePath);
    const outputFiles = [{
      outputText: result.outputText,
      outputPath
    }];

    if (result.sourceMapText) {
      outputFiles.push({
        outputText: result.sourceMapText,
        outputPath: `${outputPath}.map`
      });
    }

    return outputFiles;
  }

  compileOnCapsules({
    capsuleGraph
  }) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      const capsules = capsuleGraph.capsules;
      const capsuleDirs = capsules.getAllCapsuleDirs();
      capsuleDirs.forEach(capsuleDir => _fsExtra().default.writeFileSync(_path().default.join(capsuleDir, 'tsconfig.json'), JSON.stringify(_this.tsConfig, undefined, 2)));

      const compilerOptionsFromTsconfig = _typescript().default.convertCompilerOptionsFromJson(_this.tsConfig.compilerOptions, '.');

      if (compilerOptionsFromTsconfig.errors.length) {
        throw new Error(`failed parsing the tsconfig.json.\n${compilerOptionsFromTsconfig.errors.join('\n')}`);
      }

      const diagnostics = [];

      const diagAccumulator = diag => diagnostics.push(diag);

      const host = _typescript().default.createSolutionBuilderHost(undefined, undefined, diagAccumulator);

      const solutionBuilder = _typescript().default.createSolutionBuilder(host, capsuleDirs, {
        dry: false,
        verbose: false
      });

      solutionBuilder.clean();
      const result = solutionBuilder.build();

      if (result > 0 && !diagnostics.length) {
        throw new Error(`typescript exited with status code ${result}, however, no errors are found in the diagnostics`);
      }

      const formatHost = {
        getCanonicalFileName: p => p,
        getCurrentDirectory: () => '',
        // it helps to get the files with absolute paths
        getNewLine: () => _typescript().default.sys.newLine
      };
      const componentsErrors = diagnostics.map(diagnostic => {
        const errorStr = process.stdout.isTTY ? _typescript().default.formatDiagnosticsWithColorAndContext([diagnostic], formatHost) : _typescript().default.formatDiagnostic(diagnostic, formatHost);

        if (!diagnostic.file) {
          // this happens for example if one of the components and is not TS
          throw new Error(errorStr);
        }

        const componentId = capsules.getIdByPathInCapsule(diagnostic.file.fileName);
        if (!componentId) throw new Error(`unable to find the componentId by the filename ${diagnostic.file.fileName}`);
        return {
          componentId,
          error: errorStr
        };
      });
      const components = capsules.map(capsule => {
        const id = capsule.id;
        const errors = componentsErrors.filter(c => c.componentId.isEqual(id)).map(c => c.error);
        return {
          id,
          errors
        };
      });
      return {
        artifacts: [{
          dirName: 'dist'
        }],
        components
      };
    })();
  }

}

exports.TypescriptCompiler = TypescriptCompiler;