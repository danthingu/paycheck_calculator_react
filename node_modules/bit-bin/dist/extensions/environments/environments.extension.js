"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Environments = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _harmony() {
  const data = require("@teambit/harmony");

  _harmony = function () {
    return data;
  };

  return data;
}

function _runtime() {
  const data = require("./runtime");

  _runtime = function () {
    return data;
  };

  return data;
}

class Environments {
  constructor(config, envSlot) {
    this.config = config;
    this.envSlot = envSlot;
  }
  /**
   * create a development runtime environment.
   */


  dev(components) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      // :TODO how to standardize this? we need to make sure all validation errors will throw nicely at least.
      return _this.createRuntime(components);
    })();
  }

  createEnvironment(components) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      return _this2.createRuntime(components);
    })();
  } // @todo remove duplications from `aggregateByDefs`, it was copied and pasted


  getEnvFromExtensions(extensions) {
    const extension = extensions.findExtension(Environments.id);
    if (!extension) return null;
    const envId = extension.config.env; // here wen can do some better error handling from the harmony API with abit wrapper (next two lines)

    const env = this.envSlot.get(envId);
    if (!env) throw new Error(`an environment was not registered in extension ${envId}`);
    return env;
  }
  /**
   * register an environment.
   */


  registerEnv(env) {
    // @ts-ignore
    return this.envSlot.register(env);
  } // refactor here


  createRuntime(components) {
    return new (_runtime().Runtime)(this.aggregateByDefs(components));
  } // :TODO can be refactorerd to few utilities who will make repeating this very easy.


  aggregateByDefs(components) {
    const map = {};
    components.forEach(current => {
      // :TODO fix this api. replace with `this.id` and improve naming.
      // const extension = current.config.extensions.findExtension(this.id);
      const extension = current.config.extensions.findExtension(Environments.id); // this can also be handled better

      if (!extension) return;
      const envId = extension.config.env; // here wen can do some better error handling from the harmony API with abit wrapper (next two lines)

      const env = this.envSlot.get(envId);
      if (!env) throw new Error(`an environment was not registered in extension ${envId}`); // handle config as well when aggregating envs.

      if (map[envId]) map[envId].components.push(current);else map[envId] = {
        components: [current],
        env
      };
    }, {});
    return Object.keys(map).map(key => {
      return new (_runtime().EnvRuntime)(key, map[key].env, map[key].components);
    });
  }

  static provider(_deps, config, [envSlot]) {
    return (0, _bluebird().coroutine)(function* () {
      const envs = new Environments(config, envSlot);
      return envs;
    })();
  }

}

exports.Environments = Environments;
(0, _defineProperty2().default)(Environments, "id", '@teambit/envs');
(0, _defineProperty2().default)(Environments, "dependencies", []);
(0, _defineProperty2().default)(Environments, "slots", [_harmony().Slot.withType()]);
(0, _defineProperty2().default)(Environments, "defaultConfig", {});