"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = writeComponentsToCapsules;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _linkGenerator() {
  const data = require("../../links/link-generator");

  _linkGenerator = function () {
    return data;
  };

  return data;
}

function _manipulateDir() {
  const data = require("../../consumer/component-ops/manipulate-dir");

  _manipulateDir = function () {
    return data;
  };

  return data;
}

function _scope() {
  const data = require("../../scope");

  _scope = function () {
    return data;
  };

  return data;
}

function _manyComponentsWriter() {
  const data = _interopRequireDefault(require("../../consumer/component-ops/many-components-writer"));

  _manyComponentsWriter = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = require("../component");

  _component = function () {
    return data;
  };

  return data;
}

function writeComponentsToCapsules(_x, _x2, _x3, _x4, _x5) {
  return _writeComponentsToCapsules.apply(this, arguments);
}

function _writeComponentsToCapsules() {
  _writeComponentsToCapsules = (0, _bluebird().coroutine)(function* (components, graph, capsules, capsuleList, packageManager) {
    components = components.map(c => c.clone());
    const writeToPath = '.';
    const componentsWithDependencies = components.map(component => {
      const getClonedFromGraph = id => {
        const consumerComponent = graph.node(id.toString());

        if (!consumerComponent) {
          throw new Error(`unable to find the dependency "${id.toString()}" of "${component.id.toString()}" in the graph`);
        }

        return consumerComponent.clone();
      };

      const getDeps = dependencies => dependencies.get().map(dep => getClonedFromGraph(dep.id));

      const dependencies = getDeps(component.dependencies);
      const devDependencies = getDeps(component.devDependencies);
      const extensionDependencies = component.extensions.extensionsBitIds.map(getClonedFromGraph);
      return new (_scope().ComponentWithDependencies)({
        component,
        dependencies,
        devDependencies,
        extensionDependencies
      });
    });
    const concreteOpts = {
      componentsWithDependencies,
      writeToPath,
      override: false,
      writePackageJson: true,
      writeConfig: false,
      writeBitDependencies: false,
      createNpmLinkFiles: true,
      saveDependenciesAsComponents: false,
      writeDists: true,
      installNpmPackages: false,
      installPeerDependencies: false,
      addToRootPackageJson: false,
      verbose: false,
      excludeRegistryPrefix: false,
      silentPackageManagerResult: false,
      isolated: true,
      packageManager,
      applyExtensionsAddedConfig: true
    };
    componentsWithDependencies.map(cmp => normalizeComponentDir(cmp));
    const manyComponentsWriter = new (_manyComponentsWriter().default)(concreteOpts);
    yield manyComponentsWriter._populateComponentsFilesToWrite();
    componentsWithDependencies.forEach(componentWithDependencies => {
      const links = (0, _linkGenerator().getComponentLinks)({
        component: componentWithDependencies.component,
        dependencies: componentWithDependencies.allDependencies,
        createNpmLinkFiles: true,
        bitMap: manyComponentsWriter.bitMap
      });
      componentWithDependencies.component.dataToPersist.addManyFiles(links.files);
    }); // write data to capsule

    yield Promise.all(manyComponentsWriter.writtenComponents.map( /*#__PURE__*/function () {
      var _ref = (0, _bluebird().coroutine)(function* (componentToWrite) {
        const capsule = capsuleList.getCapsule(new (_component().ComponentID)(componentToWrite.id));
        if (!capsule) return;
        yield componentToWrite.dataToPersist.persistAllToCapsule(capsule, {
          keepExistingCapsule: true
        });
      });

      return function (_x6) {
        return _ref.apply(this, arguments);
      };
    }()));
    return manyComponentsWriter.writtenComponents;
  });
  return _writeComponentsToCapsules.apply(this, arguments);
}

function normalizeComponentDir(componentWithDependencies) {
  const allComponents = [componentWithDependencies.component, ...componentWithDependencies.allDependencies];
  const manipulateDirData = (0, _manipulateDir().getManipulateDirForComponentWithDependencies)(componentWithDependencies);
  allComponents.forEach(component => {
    component.stripOriginallySharedDir(manipulateDirData);
  });
}