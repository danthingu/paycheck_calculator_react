"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _execa() {
  const data = _interopRequireDefault(require("execa"));

  _execa = function () {
    return data;
  };

  return data;
}

function _anyFs() {
  const data = require("@teambit/any-fs");

  _anyFs = function () {
    return data;
  };

  return data;
}

function _containerExec() {
  const data = _interopRequireDefault(require("./container-exec"));

  _containerExec = function () {
    return data;
  };

  return data;
}

const debug = require('debug')('fs-container');

class FsContainer {
  constructor(wrkDir) {
    this.wrkDir = wrkDir;
    (0, _defineProperty2().default)(this, "id", 'FS Container');
    (0, _defineProperty2().default)(this, "fs", new (_anyFs().NodeFS)(this.wrkDir));
  } // TODO: do we need this?


  getPath() {
    return this.wrkDir;
  }

  composePath(pathToCompose) {
    return path().join(this.getPath(), pathToCompose);
  }

  outputFile(file, data, options) {
    const filePath = this.composePath(file);
    debug(`writing file on ${filePath}`);
    return _fsExtra().default.outputFile(filePath, data, options);
  }

  removePath(dir) {
    const pathToRemove = this.composePath(dir);
    return _fsExtra().default.remove(pathToRemove);
  }

  symlink(src, dest) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      const srcPath = _this.composePath(src);

      const destPath = _this.composePath(dest);

      yield _fsExtra().default.ensureDir(path().dirname(destPath));
      return _fsExtra().default.ensureSymlink(srcPath, destPath);
    })();
  }

  exec(execOptions, exec = new (_containerExec().default)()) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      var _subprocessP$stderr, _subprocessP$stdout;

      const cwd = execOptions.cwd ? _this2.composePath(execOptions.cwd) : _this2.getPath();
      debug(`executing the following command: ${execOptions.command.join(' ')}, on cwd: ${cwd}`);

      const subprocessP = _execa().default.command(execOptions.command.join(' '), {
        shell: true,
        cwd,
        stdio: ['ipc']
      });

      subprocessP.on('message', function (msg) {
        exec.emit('message', msg);
      });
      /* eslint-disable @typescript-eslint/no-non-null-assertion */

      (_subprocessP$stderr = subprocessP.stderr) === null || _subprocessP$stderr === void 0 ? void 0 : _subprocessP$stderr.pipe(exec.stderr);
      (_subprocessP$stdout = subprocessP.stdout) === null || _subprocessP$stdout === void 0 ? void 0 : _subprocessP$stdout.pipe(exec.stdout);
      ['close', 'exit'].forEach(function (eventName) {
        subprocessP.on(eventName, function (statusCode) {
          exec.setStatus(statusCode);
        });
      });
      return exec;
    })();
  }

  execP(execOptions) {
    var _this3 = this;

    // eslint-disable-next-line no-async-promise-executor
    return new Promise( /*#__PURE__*/function () {
      var _ref = (0, _bluebird().coroutine)(function* (resolve, reject) {
        let hasError = false;
        const exec = yield _this3.exec(execOptions);
        exec.stdout.on('error', () => {
          hasError = true;
        });
        exec.on('close', () => {
          if (hasError) reject(exec.stderr.getContents(exec.stderr.size).toString());
          resolve(exec.stdout.getContents(exec.stdout.size).toString());
        });
      });

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }());
  }

  terminal() {
    var _this4 = this;

    return (0, _bluebird().coroutine)(function* () {
      const cwd = _this4.getPath();

      return _execa().default.command(process.env.SHELL || '/bin/zsh', {
        cwd,
        stdio: 'inherit'
      });
    })();
  }

  start() {
    return _fsExtra().default.ensureDir(this.wrkDir);
  } // @ts-ignore


  inspect() {// todo: probably not needed for this container

    return (0, _bluebird().coroutine)(function* () {})();
  }

  pause() {// do nothing

    return (0, _bluebird().coroutine)(function* () {})();
  }

  resume() {
    return (0, _bluebird().coroutine)(function* () {})();
  } // do nothing
  // eslint-disable-next-line


  stop(ttl) {
    return _fsExtra().default.remove(this.wrkDir);
  }

  destroy() {
    var _this5 = this;

    return (0, _bluebird().coroutine)(function* () {
      yield _this5.stop();
    })();
  }

  log() {
    throw new Error('Method not implemented.');
  }

  on(event, fn) {
    return fn(event); // throw new Error('Method not implemented.');
  }

}

exports.default = FsContainer;