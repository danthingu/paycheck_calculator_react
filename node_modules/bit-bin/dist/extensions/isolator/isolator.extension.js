"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IsolatorExtension = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _objectHash() {
  const data = _interopRequireDefault(require("object-hash"));

  _objectHash = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = require("ramda");

  _ramda = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = require("../component");

  _component = function () {
    return data;
  };

  return data;
}

function _dependencyResolver() {
  const data = require("../dependency-resolver");

  _dependencyResolver = function () {
    return data;
  };

  return data;
}

function _capsule() {
  const data = require("./capsule");

  _capsule = function () {
    return data;
  };

  return data;
}

function _writeComponentsToCapsules() {
  const data = _interopRequireDefault(require("./write-components-to-capsules"));

  _writeComponentsToCapsules = function () {
    return data;
  };

  return data;
}

function _capsuleList() {
  const data = _interopRequireDefault(require("./capsule-list"));

  _capsuleList = function () {
    return data;
  };

  return data;
}

function _capsuleList2() {
  const data = require("./capsule-list.cmd");

  _capsuleList2 = function () {
    return data;
  };

  return data;
}

function _capsuleCreate() {
  const data = require("./capsule-create.cmd");

  _capsuleCreate = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _componentsGraph() {
  const data = require("../../scope/graph/components-graph");

  _componentsGraph = function () {
    return data;
  };

  return data;
}

function _packageJsonFile() {
  const data = _interopRequireDefault(require("../../consumer/component/package-json-file"));

  _packageJsonFile = function () {
    return data;
  };

  return data;
}

function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("../../utils/bit/component-id-to-package-name"));

  _componentIdToPackageName = function () {
    return data;
  };

  return data;
}

function _symlinkDependenciesToCapsules() {
  const data = require("./symlink-dependencies-to-capsules");

  _symlinkDependenciesToCapsules = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("../cli");

  _cli = function () {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const CAPSULES_BASE_DIR = _path().default.join(_constants().CACHE_ROOT, 'capsules'); // TODO: move elsewhere


function createCapsulesFromComponents(_x, _x2, _x3) {
  return _createCapsulesFromComponents.apply(this, arguments);
}

function _createCapsulesFromComponents() {
  _createCapsulesFromComponents = (0, _bluebird().coroutine)(function* (components, baseDir, orchOptions) {
    const capsules = yield Promise.all((0, _ramda().map)(component => {
      return _capsule().Capsule.createFromComponent(component, baseDir, orchOptions);
    }, components));
    return capsules;
  });
  return _createCapsulesFromComponents.apply(this, arguments);
}

function findSuccessorsInGraph(graph, seeders) {
  const dependenciesFromAllIds = (0, _ramda().flatten)(seeders.map(bitId => graph.getSuccessorsByEdgeTypeRecursively(bitId)));
  const components = (0, _ramda().filter)(val => val, (0, _ramda().uniq)((0, _ramda().concat)(dependenciesFromAllIds, seeders)).map(id => graph.node(id)));
  return components;
}

class IsolatorExtension {
  static provide([dependencyResolver, cli]) {
    return (0, _bluebird().coroutine)(function* () {
      const isolator = new IsolatorExtension(dependencyResolver);
      const capsuleListCmd = new (_capsuleList2().CapsuleListCmd)(isolator);
      const capsuleCreateCmd = new (_capsuleCreate().CapsuleCreateCmd)(isolator);
      cli.register(capsuleListCmd);
      cli.register(capsuleCreateCmd);
      return isolator;
    })();
  }

  constructor(dependencyResolver) {
    this.dependencyResolver = dependencyResolver;
  }

  createNetworkFromConsumer(seeders, consumer, opts) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      _logger().default.debug(`isolatorExt, createNetworkFromConsumer ${seeders.join(', ')}`);

      const seedersIds = seeders.map(seeder => consumer.getParsedId(seeder));
      const graph = yield (0, _componentsGraph().buildOneGraphForComponents)(seedersIds, consumer);

      const baseDir = _path().default.join(CAPSULES_BASE_DIR, (0, _objectHash().default)(consumer.projectPath)); // TODO: move this logic elsewhere


      return _this.createNetwork(seedersIds, graph, baseDir, opts);
    })();
  }

  createNetworkFromScope(seeders, scope, opts) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      _logger().default.debug(`isolatorExt, createNetworkFromScope ${seeders.join(', ')}`);

      const seedersIds = yield Promise.all(seeders.map(seeder => scope.getParsedId(seeder)));
      const graph = yield (0, _componentsGraph().buildOneGraphForComponentsUsingScope)(seedersIds, scope);

      const baseDir = _path().default.join(CAPSULES_BASE_DIR, (0, _objectHash().default)(scope.path)); // TODO: move this logic elsewhere


      return _this2.createNetwork(seedersIds, graph, baseDir, opts);
    })();
  }

  getBitIdsIncludeVersionsFromGraph(seedersIds, graph) {
    const components = graph.nodes().map(n => graph.node(n));
    return seedersIds.map(seederId => {
      const component = components.find(c => c.id.isEqual(seederId) || c.id.isEqualWithoutVersion(seederId));
      if (!component) throw new Error(`unable to find ${seederId.toString()} in the graph`);
      return component.id;
    });
  }

  createNetwork(seedersIds, graph, baseDir, opts) {
    var _this3 = this;

    return (0, _bluebird().coroutine)(function* () {
      const seederIds = _this3.getBitIdsIncludeVersionsFromGraph(seedersIds, graph);

      const seeders = seederIds.map(s => s.toString());
      const config = Object.assign({}, {
        installPackages: true,
        packageManager: undefined
      }, opts);
      const components = findSuccessorsInGraph(graph, seeders);
      const capsules = yield createCapsulesFromComponents(components, baseDir, config);
      const capsuleList = new (_capsuleList().default)(...capsules.map(c => {
        const id = c.component.id instanceof _bitId().BitId ? new (_component().ComponentID)(c.component.id) : c.component.id;
        return {
          id,
          capsule: c
        };
      }));
      const capsulesWithPackagesData = yield getCapsulesPreviousPackageJson(capsules);
      yield (0, _writeComponentsToCapsules().default)(components, graph, capsules, capsuleList, _this3.dependencyResolver.packageManagerName);
      updateWithCurrentPackageJsonData(capsulesWithPackagesData, capsules);

      if (config.installPackages) {
        const capsulesToInstall = capsulesWithPackagesData.filter(capsuleWithPackageData => {
          const packageJsonHasChanged = wereDependenciesInPackageJsonChanged(capsuleWithPackageData); // @todo: when a component is tagged, it changes all package-json of its dependents, but it
          // should not trigger any "npm install" because they dependencies are symlinked by us

          return packageJsonHasChanged;
        }).map(capsuleWithPackageData => capsuleWithPackageData.capsule);
        yield _this3.dependencyResolver.capsulesInstall(capsulesToInstall, {
          packageManager: config.packageManager
        });
        yield (0, _symlinkDependenciesToCapsules().symlinkDependenciesToCapsules)(capsulesToInstall, capsuleList);
      } // rewrite the package-json with the component dependencies in it. the original package.json
      // that was written before, didn't have these dependencies in order for the package-manager to
      // be able to install them without crushing when the versions don't exist yet


      capsulesWithPackagesData.forEach(capsuleWithPackageData => {
        capsuleWithPackageData.capsule.fs.writeFileSync(_constants().PACKAGE_JSON, JSON.stringify(capsuleWithPackageData.currentPackageJson, null, 2));
      });
      return {
        capsules: capsuleList,
        components: graph
      };
    })();
  }

  list(consumer) {
    return (0, _bluebird().coroutine)(function* () {
      const workspacePath = consumer.getPath();

      try {
        const workspaceCapsuleFolder = _path().default.join(CAPSULES_BASE_DIR, (0, _objectHash().default)(workspacePath));

        const capsules = yield _fsExtra().default.readdir(workspaceCapsuleFolder);
        const capsuleFullPaths = capsules.map(c => _path().default.join(workspaceCapsuleFolder, c));
        return {
          workspace: workspacePath,
          capsules: capsuleFullPaths
        };
      } catch (e) {
        if (e.code === 'ENOENT') {
          return {
            workspace: workspacePath,
            capsules: []
          };
        }

        throw e;
      }
    })();
  }

}

exports.IsolatorExtension = IsolatorExtension;
(0, _defineProperty2().default)(IsolatorExtension, "id", '@teambit/isolator');
(0, _defineProperty2().default)(IsolatorExtension, "dependencies", [_dependencyResolver().DependencyResolverExtension, _cli().CLIExtension]);
(0, _defineProperty2().default)(IsolatorExtension, "defaultConfig", {});

function wereDependenciesInPackageJsonChanged(capsuleWithPackageData) {
  const {
    previousPackageJson,
    currentPackageJson
  } = capsuleWithPackageData;
  if (!previousPackageJson) return true; // @ts-ignore at this point, currentPackageJson is set

  return _constants().DEPENDENCIES_FIELDS.some(field => !(0, _ramda().equals)(previousPackageJson[field], currentPackageJson[field]));
}

function getCapsulesPreviousPackageJson(_x4) {
  return _getCapsulesPreviousPackageJson.apply(this, arguments);
}

function _getCapsulesPreviousPackageJson() {
  _getCapsulesPreviousPackageJson = (0, _bluebird().coroutine)(function* (capsules) {
    return Promise.all(capsules.map( /*#__PURE__*/function () {
      var _ref = (0, _bluebird().coroutine)(function* (capsule) {
        const packageJsonPath = _path().default.join(capsule.wrkDir, 'package.json');

        let previousPackageJson = null;

        try {
          const previousPackageJsonRaw = yield capsule.fs.promises.readFile(packageJsonPath, {
            encoding: 'utf8'
          });
          previousPackageJson = JSON.parse(previousPackageJsonRaw);
        } catch (e) {// package-json doesn't exist in the capsule, that's fine, it'll be considered as a cache miss
        }

        return {
          capsule,
          previousPackageJson
        };
      });

      return function (_x5) {
        return _ref.apply(this, arguments);
      };
    }()));
  });
  return _getCapsulesPreviousPackageJson.apply(this, arguments);
}

function updateWithCurrentPackageJsonData(capsulesWithPackagesData, capsules) {
  capsules.forEach(capsule => {
    // @ts-ignore
    const component = capsule.component;
    const packageJson = getCurrentPackageJson(component, capsule);
    const found = capsulesWithPackagesData.find(c => c.capsule.component.id.isEqual(capsule.component.id));
    if (!found) throw new Error(`updateWithCurrentPackageJsonData unable to find ${capsule.component.id}`);
    found.currentPackageJson = packageJson.packageJsonObject;
  });
}

function getCurrentPackageJson(component, capsule) {
  const newVersion = '0.0.1-new';

  const getBitDependencies = dependencies => {
    return dependencies.reduce((acc, depId) => {
      const packageDependency = depId.hasVersion() ? depId.version : newVersion;
      const packageName = (0, _componentIdToPackageName().default)(depId, component.bindingPrefix, component.defaultScope);
      acc[packageName] = packageDependency;
      return acc;
    }, {});
  };

  const bitDependencies = getBitDependencies(component.dependencies.getAllIds());
  const bitDevDependencies = getBitDependencies(component.devDependencies.getAllIds());
  const bitExtensionDependencies = getBitDependencies(component.extensions.extensionsBitIds); // unfortunately, component.packageJsonFile is not available here.
  // the reason is that `writeComponentsToCapsules` clones the component before writing them
  // also, don't use `PackageJsonFile.createFromComponent`, as it looses the intermediate changes
  // such as postInstall scripts for custom-module-resolution.

  const packageJson = _packageJsonFile().default.loadFromCapsuleSync(capsule);

  const addDependencies = packageJsonFile => {
    packageJsonFile.addDependencies(bitDependencies);
    packageJsonFile.addDevDependencies(_objectSpread({}, bitDevDependencies, {}, bitExtensionDependencies));
  };

  addDependencies(packageJson);
  packageJson.addOrUpdateProperty('version', component.id.hasVersion() ? component.id.version : newVersion);
  packageJson.removeDependency('bit-bin');
  return packageJson;
}