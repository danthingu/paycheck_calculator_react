"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("./exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _tagMap() {
  const data = _interopRequireDefault(require("./tag-map"));

  _tagMap = function () {
    return data;
  };

  return data;
}

function _snap() {
  const data = _interopRequireDefault(require("./snap"));

  _snap = function () {
    return data;
  };

  return data;
}

// eslint-disable-next-line import/no-cycle
// eslint-disable-next-line import/no-cycle

/**
 * in-memory representation of a component.
 */
class Component {
  constructor(id, head = null, state, tags = new (_tagMap().default)()) {
    this.id = id;
    this.head = head;
    this.state = state;
    this.tags = tags;
  }
  /**
   * component configuration which is later generated to a component `package.json` and `bit.json`.
   */


  get config() {
    return this.state.config;
  }
  /**
   * in-memory representation of the component current filesystem.
   */


  get filesystem() {
    return this.state.filesystem;
  }

  stringify() {
    return JSON.stringify({
      id: this.id,
      head: this.head // TODO - laly add stringify of this.state and this.tags

    });
  }
  /**
   * dependency graph of the component current. ideally package dependencies would be also placed
   * here through an external extension.
   */


  graph() {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      return _this.state.dependencyGraph();
    })();
  }

  capsule() {}
  /**
   * record component changes in the `Scope`.
   */


  snap(author, message = '') {
    if (!this.isModified()) throw new (_exceptions().NothingToSnap)();

    const snap = _snap().default.create(this, author, message);

    return new Component(this.id, snap, snap.state, this.tags);
  }
  /**
   * tag a component `Snap` with a semantic version. we follow SemVer specs as defined [here](https://semver.org/)).
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  tag(version) {} // const snap = this.snap();
  // const tag = new Tag(version, snap);
  // this.tags.set(tag);

  /**
   * determines whether this component is modified in the workspace.
   */


  isModified() {
    if (!this.head) return true;
    return this.state.hash !== this.head.hash;
  }
  /**
   * determines whether this component is new.
   */


  isNew() {
    return this.head === null;
  }
  /**
   * checkout the component to a different version in its working tree.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  checkout(version) {} // const version = this.tags.get(version);

  /**
   * examine difference between two components.
   */
  // diff(other: Component): Difference {}

  /**
   * merge two different components
   */
  // merge(other: Component): Component {}

  /**
   * write a component to a given file system.
   * @param path root path to write the component
   * @param fs instance of any fs to use.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  write(path, fs) {}

  fromString(str) {
    const object = JSON.parse(str);
    return new Component(object.name, null, object.state, object.tags);
  }
  /**
   *
   * Check if 2 components are equal
   * @param {Component} component
   * @returns {boolean}
   * @memberof Component
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  equals(component) {
    return true;
  }

}

exports.default = Component;