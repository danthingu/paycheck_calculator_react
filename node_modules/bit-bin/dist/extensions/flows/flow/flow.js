"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Flow = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _rxjs() {
  const data = require("rxjs");

  _rxjs = function () {
    return data;
  };

  return data;
}

function _task() {
  const data = require("../task");

  _task = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

/* eslint-disable @typescript-eslint/no-this-alias */

/* eslint-disable no-plusplus */

/* eslint-disable max-len */
class Flow {
  constructor(tasks) {
    this.tasks = tasks;
    (0, _defineProperty2().default)(this, "result", []);
  }
  /**
   * Takes a capsule and return a stream of streams.
   * Return value represent the execution of tasks.
   *
   * @param capsule ComponentCapsule to execute tasks
   */


  execute(capsule) {
    const id = capsule.component.id.toString();
    const startTime = new Date();
    const subject = new (_rxjs().ReplaySubject)();
    subject.next({
      type: 'flow:start',
      id,
      startTime
    });

    if (this.tasks && this.tasks.length) {
      _logger().default.debug(`flowsExt, flow.execute of ${id}. tasks: ${this.tasks.join(', ')}`);

      this.execSequence(capsule, subject, startTime, 0);
    } else {
      _logger().default.debug(`flowsExt, flow.execute of ${id}. no tasks. handleDone`);

      setImmediate(() => this.handleDone(subject, capsule, startTime));
    }

    return subject;
  }

  execSequence(capsule, subject, start, index) {
    const id = capsule.component.id.toString();

    _logger().default.debug(`flowsExt, flow.execSequence of ${id}. index: ${index}`);

    const that = this;
    const task = (0, _task().executeTask)(this.tasks[index], capsule);
    subject.next(task);
    task.subscribe({
      next(data) {
        if (data.type === 'task:result') {
          that.result.push(data);

          if (data.code) {
            index = that.handleError(index, capsule, data, subject, start);
          }
        }
      },

      complete() {
        if (that.tasks.length > index + 1) {
          that.execSequence(capsule, subject, start, ++index);
        } else {
          that.handleDone(subject, capsule, start);
        }
      }

    });
  }

  handleError(index, capsule, data, subject, start) {
    for (let i = index + 1; i < this.tasks.length; ++i) {
      this.result.push({
        type: 'task:error',
        id: `${capsule.component.id.toString()}:${this.tasks[i]}`,
        value: new Error(`Error by ${data.id}`),
        errorBy: data
      });
    }

    const isError = true;
    this.handleDone(subject, capsule, start, isError);
    return this.tasks.length;
  }

  handleDone(subject, capsule, startTime, isError = false) {
    const endTime = new Date();

    _logger().default.debug(`flowsExt, flow.handleDone of ${capsule.component.id.toString()}. isError: ${isError}`);

    subject[isError ? 'error' : 'next']({
      type: 'flow:result',
      id: capsule.component.id,
      value: {
        capsule,
        tasks: this.result
      },
      code: isError ? 1 : 0,
      startTime,
      duration: endTime.getTime() - startTime.getTime()
    });
    setTimeout(subject.complete.bind(subject), 0);
    this.result = [];
  }

}

exports.Flow = Flow;