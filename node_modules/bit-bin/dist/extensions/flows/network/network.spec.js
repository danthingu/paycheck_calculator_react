"use strict";

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _chai() {
  const data = require("chai");

  _chai = function () {
    return data;
  };

  return data;
}

function _operators() {
  const data = require("rxjs/operators");

  _operators = function () {
    return data;
  };

  return data;
}

function _createFakeNetwork() {
  const data = require("../util/create-fake-network");

  _createFakeNetwork = function () {
    return data;
  };

  return data;
}

function _flattenNestedMap() {
  const data = require("../util/flatten-nested-map");

  _flattenNestedMap = function () {
    return data;
  };

  return data;
}

//
// a graph of inter connected capsules where a->b if a is liable for b (b depends on a).
//
//
describe('Network', () => {
  function getTestCaseFunc(toExpect, graph = {
    'bit/a': []
  }, input = ['bit/a']) {
    return /*#__PURE__*/function () {
      var _ref = (0, _bluebird().coroutine)(function* () {
        const testCase = {
          graph,
          input,
          options: {
            concurrency: 4,
            traverse: 'both',
            caching: true
          }
        };
        const stream = yield (0, _createFakeNetwork().createTestNetworkStream)(testCase);
        const report = yield (0, _flattenNestedMap().flattenReplaySubject)(stream).pipe( // tap((x:any)=> console.log('===>>>', x.type, 'from', typeof x.id ==='string'? x.id : x.id && x.id.toString())),
        (0, _operators().filter)(x => x.type === 'flow:result'), (0, _operators().map)(x => x.id.toString()), (0, _operators().reduce)((acc, val) => {
          return acc ? `${acc}-->${val}` : val;
        }, '')).toPromise();
        return (0, _chai().expect)(report).to.equal(toExpect);
      });

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();
  }

  describe('sanity', function () {
    it('should support 1 component graph', function () {
      return getTestCaseFunc('bit/a')();
    });
    it('should support 0 component graph', function () {
      return getTestCaseFunc('', {}, [])();
    });
  });
  it('structure is c-->b-->a seeder is a ', function () {
    return getTestCaseFunc('bit/c-->bit/b-->bit/a', {
      'bit/a': [],
      'bit/b': ['bit/a'],
      'bit/c': ['bit/b']
    }, ['bit/a'])();
  });
  it('structure is c-->b-->a seeder is b', function () {
    return getTestCaseFunc('bit/c-->bit/b-->bit/a', {
      'bit/a': [],
      'bit/b': ['bit/a'],
      'bit/c': ['bit/b']
    }, ['bit/b'])();
  });
  it('structure is c-->b-->a seeder is c ', function () {
    return getTestCaseFunc('bit/c-->bit/b-->bit/a', {
      'bit/a': [],
      'bit/b': ['bit/a'],
      'bit/c': ['bit/b']
    }, ['bit/c'])();
  });
  it('structure is l->a c->h c->a c->l', function () {
    // this.timeout(1000 * 100)
    return getTestCaseFunc('bit/c-->bit/l-->bit/a-->bit/h', {
      'bit/a': [],
      'bit/l': ['bit/a'],
      'bit/h': [],
      'bit/c': ['bit/a', 'bit/l', 'bit/h']
    }, []).bind(this)();
  }); // currently fails on circular

  it.skip('circular structure is b-->c-->b-->a seeder is a', getTestCaseFunc('bit/c-->bit/b-->bit/a', {
    'bit/a': [],
    'bit/b': ['bit/a', 'bit/c'],
    'bit/c': ['bit/b']
  }, ['bit/a'])); // currently fails on circular

  it.skip('circular structure is a-->b-->c-->b seeder is c', function () {});
});