"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getExecutionCache = getExecutionCache;
exports.ExecutionCache = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _crypto() {
  const data = require("crypto");

  _crypto = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = require("ramda");

  _ramda = function () {
    return data;
  };

  return data;
}

function _fs() {
  const data = require("fs");

  _fs = function () {
    return data;
  };

  return data;
}

function _properLockfile() {
  const data = require("proper-lockfile");

  _properLockfile = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

/* eslint-disable no-nested-ternary */

/* eslint-disable @typescript-eslint/no-non-null-assertion */

/* eslint-disable @typescript-eslint/no-unused-vars */
class ExecutionCache {
  constructor(pathToCache) {
    this.pathToCache = pathToCache;
  }

  hash(capsule, name) {
    const configString = JSON.stringify((0, _ramda().path)(['component', 'extensions'], capsule)); // for some reason in this point i get consumerComponent and not a component

    const consumerComponent = capsule.component;
    const {
      files,
      packageJsonFile
    } = consumerComponent;
    const vinylFiles = [...files];
    if (packageJsonFile) vinylFiles.push(packageJsonFile.toVinylFile());
    const content = `${configString}\n${capsule.wrkDir}\n${vinylFiles.map(file => (file.contents || '').toString()).join('\n')}`;
    const md5 = (0, _crypto().createHash)('md5', {
      encoding: 'utf8'
    }).update(content).digest('base64').toString();
    return md5;
  }

  saveHashValue(capsule, name) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      yield safeGetLock(_this.pathToCache);
      const file = yield safeReadFile(_this.pathToCache);
      const content = file ? JSON.parse(file) : {};

      const hash = _this.hash(capsule, name);

      content[capsule.wrkDir] = content[capsule.wrkDir] || {};
      content[capsule.wrkDir][name] = hash;
      yield _fs().promises.writeFile(_this.pathToCache, JSON.stringify(content, null, 2));
      return (0, _properLockfile().unlock)(_this.pathToCache);
    })();
  }

  getCacheValue(wrkDir, name) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      yield safeGetLock(_this2.pathToCache);
      const file = yield safeReadFile(_this2.pathToCache);
      const content = file ? JSON.parse(file) : {};
      const cacheValue = (0, _ramda().path)([wrkDir, name], content);
      yield (0, _properLockfile().unlock)(_this2.pathToCache);
      return cacheValue;
    })();
  }

  compareToCache(capsule, name) {
    var _this3 = this;

    return (0, _bluebird().coroutine)(function* () {
      const inCache = yield _this3.getCacheValue(capsule.wrkDir, name);

      const hashValue = _this3.hash(capsule, name);

      return (0, _ramda().equals)(inCache, hashValue);
    })();
  }

}

exports.ExecutionCache = ExecutionCache;

function getExecutionCache() {
  const pathToCache = (0, _path().join)(_constants().CACHE_ROOT, 'capsules', 'cache-flow.json');
  return new ExecutionCache(pathToCache);
}

function safeReadFile(_x) {
  return _safeReadFile.apply(this, arguments);
}

function _safeReadFile() {
  _safeReadFile = (0, _bluebird().coroutine)(function* (filePath) {
    let content = null;

    try {
      content = yield _fs().promises.readFile(filePath, {
        encoding: 'utf8'
      }); // eslint-disable-next-line no-empty
    } catch (e) {}

    return content;
  });
  return _safeReadFile.apply(this, arguments);
}

function safeGetLock(_x2) {
  return _safeGetLock.apply(this, arguments);
}

function _safeGetLock() {
  _safeGetLock = (0, _bluebird().coroutine)(function* (cachePath, options = {
    init: somePath => _fs().promises.writeFile(somePath, '{}', 'utf8'),
    timeout: 100
  }) {
    let lockState = 'UNLOCK';

    try {
      yield (0, _properLockfile().lock)(cachePath, {
        retries: 5,
        update: options.timeout
      });
      lockState = 'LOCK';
    } catch (e) {
      if (e.code === 'ENOENT') {
        yield options.init(cachePath);
      } else {
        lockState = 'UNLOCKERROR';
      }
    }

    return lockState === 'UNLOCK' ? safeGetLock(cachePath) : lockState === 'UNLOCKERROR' ? new Promise(function (resolve) {
      setTimeout(function () {
        return safeGetLock(cachePath).then(() => resolve());
      }, options.timeout);
    }) : undefined;
  });
  return _safeGetLock.apply(this, arguments);
}