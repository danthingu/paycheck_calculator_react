"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IdsAndFlows = exports.Flows = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _events() {
  const data = require("events");

  _events = function () {
    return data;
  };

  return data;
}

function _network() {
  const data = require("./network");

  _network = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = require("../component");

  _component = function () {
    return data;
  };

  return data;
}

function _flow() {
  const data = require("./flow/flow");

  _flow = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _network2() {
  const data = require("./network/network");

  _network2 = function () {
    return data;
  };

  return data;
}

function _cache() {
  const data = require("./cache");

  _cache = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

/* eslint-disable @typescript-eslint/no-unused-vars */

/* eslint-disable max-classes-per-file */
class Flows {
  constructor(workspace) {
    this.workspace = workspace;
    (0, _defineProperty2().default)(this, "emitter", new (_events().EventEmitter)());
  }

  getIds(ids) {
    return ids.map(id => new (_component().ComponentID)(this.workspace.consumer.getParsedId(id)));
  }
  /**
   * Creates a custom network from workspace.
   *
   * @param seeders - array of components to build.
   * @param getFlow - function which provide component flow.
   * @param postFlow - postFlow callback.
   */


  createNetwork(seeders, getFlow, postFlow = () => Promise.resolve()) {
    const network = new (_network().Network)(this.workspace, seeders, getFlow, _network2().getWorkspaceGraph, postFlow);
    network.onWorkspaceLoaded((...args) => {
      this.emitter.emit('workspaceLoaded', args);
    });
    return network;
  }
  /**
   * Creates network which runs named flow according to project configuration.
   *
   * @param seeders array of components to build
   * @param name flow name
   * @param options
   */


  createNetworkByFlowName(seeders, name = 'build', options) {
    var _this = this;

    const getFlow = /*#__PURE__*/function () {
      var _ref = (0, _bluebird().coroutine)(function* (capsule) {
        var _component$config$ext;

        const seed = capsule.component.id;
        const id = seed instanceof _bitId().BitId ? seed : seed._legacy;
        const component = yield _this.workspace.get(id);

        if (!component) {
          return new (_flow().Flow)([]);
        }

        const isCached = yield (0, _cache().getExecutionCache)().compareToCache(capsule, name);
        const flowsConfig = (_component$config$ext = component.config.extensions.findCoreExtension('flows')) === null || _component$config$ext === void 0 ? void 0 : _component$config$ext.config;
        const tasks = flowsConfig && flowsConfig.tasks ? flowsConfig.tasks[name] : [];
        const flow = isCached && options.caching ? new (_flow().Flow)([]) : new (_flow().Flow)(tasks);
        return flow;
      });

      return function getFlow(_x) {
        return _ref.apply(this, arguments);
      };
    }();

    const postFlow = /*#__PURE__*/function () {
      var _ref2 = (0, _bluebird().coroutine)(function* (capsule) {
        const cache = (0, _cache().getExecutionCache)();
        return cache.saveHashValue(capsule, name);
      });

      return function postFlow(_x2) {
        return _ref2.apply(this, arguments);
      };
    }();

    return this.createNetwork(seeders, getFlow, postFlow);
  }
  /**
   * Executes named flow on network and returns a promise with network:result message.
   *
   * @param seeders array of components to build
   * @param name flow name
   * @param options
   * @param network optional custom network
   */


  runToPromise(seeders, name = 'build', options, network) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      _logger().default.debug(`flowsExt, runToPromise is running ${name} on ${seeders.map(s => s.toString()).join(', ')}`);

      const resultStream = yield _this2.run(seeders, name, options, network);

      _logger().default.debug(`flowsExt, runToPromise got resultStream`);

      return new Promise((resolve, reject) => {
        resultStream.subscribe({
          next(data) {
            if (data.type === 'network:result') {
              _logger().default.debug(`flowsExt, runToPromise going to resolve the promise.`);

              resolve(data);
            } else {
              _logger().default.debug(`flowsExt, runToPromise data.type is ${data.type}. the promise is not resolved nor rejected`);
            }
          },

          error(err) {
            _logger().default.debug(`flowsExt, runToPromise going to reject the promise.`);

            reject(err);
          },

          complete() {
            _logger().default.debug(`flowsExt, runToPromise in complete()`);
          }

        });
      });
    })();
  }
  /**
   * Executes named flow on network and returns an execution stream.
   *
   * @param seeders array of components to build
   * @param name flow name
   * @param options
   * @param network optional custom network
   */
  // @todo: @qballer please add return type


  run(seeders, name = 'build', options, network) {
    var _this3 = this;

    return (0, _bluebird().coroutine)(function* () {
      const opts = Object.assign({
        caching: true,
        concurrency: 4,
        traverse: 'both'
      }, options);
      network = network || _this3.createNetworkByFlowName(seeders, name, opts);
      const resultStream = yield network.execute(opts);
      return resultStream;
    })();
  }
  /**
   *  runs custom flow on network.
   *
   * @param flowsWithIds
   * @param options
   */


  runMultiple(flowsWithIds, options) {
    var _this4 = this;

    return (0, _bluebird().coroutine)(function* () {
      const getFlow = capsule => {
        const id = capsule.component.id; // @ts-ignore for some reason the capsule.component here is ConsumerComponent

        const value = flowsWithIds.getFlows(id);
        return Promise.resolve(new (_flow().Flow)(value || []));
      };

      const ids = flowsWithIds.map(withID => new (_component().ComponentID)(withID.id));

      const network = _this4.createNetwork(ids, getFlow);

      return _this4.runToPromise(ids, '', options || {}, network);
    })();
  }

  onWorkspaceLoaded(cb) {
    this.emitter.on('workspaceLoaded', cb);
  }

}

exports.Flows = Flows;

class IdsAndFlows extends Array {
  getFlows(id) {
    const found = this.find(item => item.id.isEqual(id));
    return found ? found.value : null;
  }

  getFlowsIgnoreVersion(id) {
    const found = this.find(item => item.id.isEqualWithoutVersion(id));
    return found ? found.value : null;
  }

  getFlowsIgnoreScopeAndVersion(id) {
    const found = this.find(item => item.id.isEqualWithoutScopeAndVersion(id));
    return found ? found.value : null;
  }

  toString() {
    return this.map(({
      id,
      value
    }) => `id: ${id}, task: ${value.join(', ')}`).join('; ');
  }

}

exports.IdsAndFlows = IdsAndFlows;