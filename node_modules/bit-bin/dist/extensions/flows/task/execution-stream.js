"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.listenToExecutionStream = listenToExecutionStream;

function _rxjs() {
  const data = require("rxjs");

  _rxjs = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function listenToExecutionStream(exec, id, time = new Date()) {
  _logger().default.debug(`flowsExt, createExecutionStream of ${id} started`);

  let message = null;
  const subscriber = new (_rxjs().ReplaySubject)();
  subscriber.next({
    type: 'task:start',
    id,
    startTime: time
  });
  exec.stdout.on('data', function (data) {
    subscriber.next({
      type: 'task:stdout',
      id,
      value: data.toString()
    });
  });
  exec.stderr.on('data', function (data) {
    _logger().default.error(`flowsExt, createExecutionStream of ${id} got error: ${data.toString()}`);

    subscriber.next({
      type: 'task:stderr',
      id,
      value: data.toString()
    });
  });
  exec.on('message', function (data) {
    message = data;
  });
  exec.on('close', function () {
    _logger().default.debug(`flowsExt, createExecutionStream of ${id} completed!`);

    const streamMessage = {
      type: 'task:result',
      id,
      value: message,
      startTime: time,
      duration: new Date().getTime() - time.getTime(),
      code: exec.code
    };
    subscriber.next(streamMessage);
    subscriber.complete();
  });
  return subscriber;
}