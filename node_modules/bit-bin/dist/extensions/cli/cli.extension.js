"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CLIProvider = CLIProvider;
exports.CLIExtension = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _commander() {
  const data = _interopRequireDefault(require("commander"));

  _commander = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = require("ramda");

  _ramda = function () {
    return data;
  };

  return data;
}

function _didyoumean() {
  const data = _interopRequireDefault(require("didyoumean"));

  _didyoumean = function () {
    return data;
  };

  return data;
}

function _registry() {
  const data = _interopRequireDefault(require("./registry"));

  _registry = function () {
    return data;
  };

  return data;
}

function _reporter() {
  const data = require("../reporter");

  _reporter = function () {
    return data;
  };

  return data;
}

function _commandRegistry() {
  const data = require("../../cli/command-registry");

  _commandRegistry = function () {
    return data;
  };

  return data;
}

function _alreadyExists() {
  const data = require("./exceptions/already-exists");

  _alreadyExists = function () {
    return data;
  };

  return data;
}

function _help() {
  const data = require("./commands/help.cmd");

  _help = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("../../cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _extensionsLoader() {
  const data = _interopRequireDefault(require("../../legacy-extensions/extensions-loader"));

  _extensionsLoader = function () {
    return data;
  };

  return data;
}

function _legacyCommandAdapter() {
  const data = require("./legacy-command-adapter");

  _legacyCommandAdapter = function () {
    return data;
  };

  return data;
}

function _commandNotFound() {
  const data = require("./exceptions/command-not-found");

  _commandNotFound = function () {
    return data;
  };

  return data;
}

class CLIExtension {
  static provider([reporter]) {
    const cli = new CLIExtension(new (_registry().default)({}), reporter);
    return CLIProvider([cli]);
  }

  constructor(registry, reporter) {
    this.registry = registry;
    this.reporter = reporter;
    (0, _defineProperty2().default)(this, "groups", {});
  }

  setDefaults(command) {
    command.alias = command.alias || '';
    command.description = command.description || '';
    command.shortDescription = command.shortDescription || '';
    command.group = command.group || 'ungrouped';
    command.options = command.options || [];
    command.private = command.private || false;
    command.commands = command.commands || [];

    if (command.loader === undefined) {
      if (command.internal) {
        command.loader = false;
      } else {
        command.loader = true;
      }
    }
  }
  /**
   * registers a new command in to `Paper`.
   */


  register(command) {
    this.setDefaults(command); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

    command.commands.forEach(cmd => this.setDefaults(cmd));
    this.registry.register(command);
  }
  /**
   * list of all registered commands. (legacy and new).
   */


  get commands() {
    return this.registry.commands;
  }
  /**
   * execute commands registered to `Paper` and the legacy bit cli.
   */


  run() {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      const args = process.argv.slice(2); // remove the first two arguments, they're not relevant

      if (!args[0] || ['-h', '--help'].includes(args[0])) {
        (0, _help().Help)()(_this.commands, _this.groups);
        return;
      }

      const [params, packageManagerArgs] = (0, _ramda().splitWhen)((0, _ramda().equals)('--'), process.argv);

      if (packageManagerArgs && packageManagerArgs.length) {
        packageManagerArgs.shift(); // remove the -- delimiter
      }

      Object.values(_this.commands).forEach(command => (0, _commandRegistry().register)(command, _commander().default, packageManagerArgs));

      _this.throwForNonExistsCommand(args[0]); // this is what runs the `execAction` of the specific command and eventually exits the process


      _commander().default.parse(params);

      if (_this.shouldOutputJson()) {
        _this.reporter.suppressOutput();
      }
    })();
  }

  shouldOutputJson() {
    const showCommand = _commander().default.commands.find(c => c._name === 'show');

    return showCommand.versions;
  }

  throwForNonExistsCommand(commandName) {
    const commands = Object.keys(this.commands);
    const aliases = commands.map(c => this.commands[c].alias).filter(a => a);
    const globalFlags = ['-V', '--version'];
    const validCommands = [...commands, ...aliases, ...globalFlags];
    const commandExist = validCommands.includes(commandName);

    if (!commandExist) {
      _didyoumean().default.returnFirstMatch = true;
      const suggestions = (0, _didyoumean().default)(commandName, Object.keys(this.commands).filter(c => !this.commands[c].private));
      const suggestion = suggestions && Array.isArray(suggestions) ? suggestions[0] : suggestions;
      throw new (_commandNotFound().CommandNotFound)(commandName, suggestion);
    }
  }

  registerGroup(name, description) {
    if (this.groups[name]) {
      throw new (_alreadyExists().AlreadyExistsError)('group', name);
    }

    this.groups[name] = description;
  }

}

exports.CLIExtension = CLIExtension;
(0, _defineProperty2().default)(CLIExtension, "dependencies", [_reporter().ReporterExt]);

function CLIProvider(_x) {
  return _CLIProvider.apply(this, arguments);
}

function _CLIProvider() {
  _CLIProvider = (0, _bluebird().coroutine)(function* ([cliExtension]) {
    const legacyExtensions = yield (0, _extensionsLoader().default)(); // Make sure to register all the hooks actions in the global hooks manager

    legacyExtensions.forEach(extension => {
      extension.registerHookActionsOnHooksManager();
    });
    const extensionsCommands = legacyExtensions.reduce((acc, curr) => {
      if (curr.commands && curr.commands.length) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        acc = acc.concat(curr.commands);
      }

      return acc;
    }, []);
    const legacyRegistry = (0, _cli().buildRegistry)(extensionsCommands);
    const allCommands = legacyRegistry.commands.concat(legacyRegistry.extensionsCommands || []);
    allCommands.forEach(command => {
      const legacyCommandAdapter = new (_legacyCommandAdapter().LegacyCommandAdapter)(command, cliExtension);
      cliExtension.register(legacyCommandAdapter);
    });
    return cliExtension;
  });
  return _CLIProvider.apply(this, arguments);
}