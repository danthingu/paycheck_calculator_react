"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Registry = exports.Create = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _vinyl() {
  const data = _interopRequireDefault(require("vinyl"));

  _vinyl = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _composeComponentPath() {
  const data = require("../../utils/bit/compose-component-path");

  _composeComponentPath = function () {
    return data;
  };

  return data;
}

function _dataToPersist() {
  const data = _interopRequireDefault(require("../../consumer/component/sources/data-to-persist"));

  _dataToPersist = function () {
    return data;
  };

  return data;
}

function _sources() {
  const data = require("../../consumer/component/sources");

  _sources = function () {
    return data;
  };

  return data;
}

/* eslint max-classes-per-file: 0 */
class Create {
  constructor(config, workspace, registry) {
    this.config = config;
    this.workspace = workspace;
    this.registry = registry;
  }

  register(manifest, template) {
    this.registry.set(manifest, template);
    return this;
  }

  create(name) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      var _this$config;

      const templateExtName = (_this$config = _this.config) === null || _this$config === void 0 ? void 0 : _this$config.template;

      if (!templateExtName) {
        throw new Error(`please add the following configuration: "create: { "template": "your-template-extension" }" `);
      }

      const templateFunc = _this.registry.get(templateExtName);

      const nameSplit = name.split('/');
      const compName = nameSplit.pop(); // last item is the name, the rest are the namespace

      const templateResults = _this.getTemplateResults(templateFunc, compName, templateExtName);

      const componentPath = _this.getComponentPath(name);

      yield _this.writeComponentFiles(componentPath, templateResults.files);
      return _this.workspace.add([componentPath], name, templateResults.main);
    })();
  }

  getComponentPath(name) {
    return (0, _composeComponentPath().composeComponentPath)(new (_bitId().BitId)({
      name
    }), this.workspace.legacyDefaultDirectory);
  }

  getTemplateResults(templateFunc, compName, templateExtName) {
    if (typeof templateFunc !== 'function') {
      throw new Error(`failed to get a template function from "${templateExtName}. got ${typeof templateFunc} instead"`);
    }

    try {
      return templateFunc(compName);
    } catch (err) {
      throw new Error(`got an error "${err.message}" while running the template function of ${templateExtName}.`);
    }
  }
  /**
   * writes the generated template files to the default directory set in the workspace config
   */


  writeComponentFiles(componentPath, templateFiles) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      const dataToPersist = new (_dataToPersist().default)();
      const vinylFiles = templateFiles.map(templateFile => {
        const templateFileVinyl = new (_vinyl().default)({
          base: componentPath,
          path: _path().default.join(componentPath, templateFile.path),
          contents: Buffer.from(templateFile.content)
        });
        return _sources().AbstractVinyl.fromVinyl(templateFileVinyl);
      });
      const results = vinylFiles.map(v => v.path);
      dataToPersist.addManyFiles(vinylFiles);
      dataToPersist.addBasePath(_this2.workspace.path);
      yield dataToPersist.persistAllToFS();
      return results;
    })();
  }

}

exports.Create = Create;

const DEFAULT_TEMPLATE = name => [{
  path: `${name}.js`,
  content: `export default function ${name} { console.log('I am the default template'); }`
}];

class Registry {
  constructor(harmony) {
    this.harmony = harmony;
    (0, _defineProperty2().default)(this, "templates", {});
  }

  /**
   * get a template from the registry.
   */
  get(name) {
    const scripts = this.templates[name];
    if (!scripts) throw new Error('no scripts found');
    return this.templates[name] || DEFAULT_TEMPLATE;
  }
  /**
   * set a script to the registry.
   */


  set(manifest, templateFunc) {
    // TODO: is this really needed? maybe it's just a template name and not must be a real extension id / manifest?
    // TODO: why we need to fetch it from harmony at all?
    const extensionConfig = this.harmony.config.get(manifest.name);
    if (!extensionConfig) throw new Error(manifest.name);
    if (!this.templates[manifest.name]) this.templates[manifest.name] = {};
    this.templates[manifest.name] = templateFunc;
    return this;
  }

}

exports.Registry = Registry;