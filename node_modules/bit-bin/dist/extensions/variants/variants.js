"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Variants = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _consumerOverrides() {
  const data = _interopRequireDefault(require("../../consumer/config/consumer-overrides"));

  _consumerOverrides = function () {
    return data;
  };

  return data;
}

class Variants {
  constructor(patterns, hostConfig) {
    this.patterns = patterns;
    this.hostConfig = hostConfig;
    (0, _defineProperty2().default)(this, "componentsCache", void 0);
    (0, _defineProperty2().default)(this, "_loadedLegacy", void 0);
    this.componentsCache = new Map();
    this._loadedLegacy = _consumerOverrides().default.load(this.patterns);
  }

  raw() {
    return this.patterns;
  }
  /**
   * Get all the patterns defined in the variants section of the workspace as the legacy ConsumerOverrides format
   */


  legacy() {
    // return ConsumerOverrides.load(this.patterns);
    return this._loadedLegacy;
  }

  legacyById(componentId) {
    var _this$hostConfig$work;

    const rawConfig = this.byId(componentId);
    let config = rawConfig || {};

    if (!((_this$hostConfig$work = this.hostConfig.workspaceConfig) === null || _this$hostConfig$work === void 0 ? void 0 : _this$hostConfig$work.isLegacy)) {
      config = transformConfigToLegacy(rawConfig);
    }

    return config;
  }
  /**
   * Gets the config for specific component after merge all matching patterns of the component id in the variants section
   * @param componentId
   */


  byId(componentId) {
    var _this$legacy;

    if (this.componentsCache.has(componentId.toString())) {
      return this.componentsCache.get(componentId.toString());
    }

    const config = ((_this$legacy = this.legacy()) === null || _this$legacy === void 0 ? void 0 : _this$legacy.getOverrideComponentData(componentId)) || {}; // We cache this results since this is something with state (it has - hasChanged prop which should be consistent)

    this.componentsCache.set(componentId.toString(), config); // TODO: transform to new format (only once we support storing all requireld fields under extensions -
    // 'dependencies',
    // 'devDependencies',
    // 'peerDependencies',
    // 'env',
    // 'propagate',
    // 'defaultScope' // or just scope
    // 'owner'

    return config;
  }

}

exports.Variants = Variants;

function transformConfigToLegacy(config) {
  if (!config) {
    return {};
  } // TODO: handle specific fields from the extensions like taking deps from the dependency-resolver
  // and scope / owner from somewhere


  const res = {
    extensions: config
  };
  return res;
}