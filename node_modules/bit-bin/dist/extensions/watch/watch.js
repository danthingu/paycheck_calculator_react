"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _chokidar() {
  const data = _interopRequireDefault(require("chokidar"));

  _chokidar = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

/* eslint no-console: 0 */
class Watch {
  constructor(compile, workspace, trackDirs = {}, verbose = false, multipleWatchers = []) {
    this.compile = compile;
    this.workspace = workspace;
    this.trackDirs = trackDirs;
    this.verbose = verbose;
    this.multipleWatchers = multipleWatchers;
  }

  watch(opts) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      _this.verbose = Boolean(opts.verbose);
      yield _this.watchAll();
    })();
  }

  get consumer() {
    return this.workspace.consumer;
  }

  watchAll() {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      // TODO: run build in the beginning of process (it's work like this in other envs)
      const watcher = _this2._getWatcher();

      console.log(_chalk().default.yellow(`bit binary version: ${_constants().BIT_VERSION}`));
      console.log(_chalk().default.yellow(`node version: ${process.version}`));
      const log = console.log.bind(console);
      return new Promise((resolve, reject) => {
        // prefix your command with "BIT_LOG=*" to see all watch events
        if (process.env.BIT_LOG) {
          watcher.on('all', (event, path) => {
            log(event, path);
          });
        }

        watcher.on('ready', () => {
          log(_chalk().default.yellow(_constants().STARTED_WATCHING_MSG));
        });
        watcher.on('change', p => {
          log(`file ${p} has been changed`);

          _this2._handleChange(p).catch(err => reject(err));
        });
        watcher.on('add', p => {
          log(`file ${p} has been added`);

          _this2._handleChange(p, true).catch(err => reject(err));
        });
        watcher.on('unlink', p => {
          log(`file ${p} has been removed`);

          _this2._handleChange(p).catch(err => reject(err));
        });
        watcher.on('error', err => {
          log(`Watcher error ${err}`);
          reject(err);
        });
      });
    })();
  }

  _handleChange(filePath, isNew = false) {
    var _this3 = this;

    return (0, _bluebird().coroutine)(function* () {
      const start = new Date().getTime();
      const componentId = yield _this3._getBitIdByPathAndReloadConsumer(filePath, isNew);
      let resultMsg;

      if (componentId) {
        if (_this3.isComponentWatchedExternally(componentId)) {
          // update capsule, once done, it automatically triggers the external watcher
          yield _this3.workspace.load([componentId]);
        } else {
          const idStr = componentId.toString();
          console.log(`running build for ${_chalk().default.bold(idStr)}`); // TODO: Make sure the log for build is printed to console

          const buildResults = yield _this3.compile.compileOnWorkspace([idStr], false, _this3.verbose);
          const buildPaths = buildResults[0].buildResults;

          if (buildPaths && buildPaths.length) {
            resultMsg = `\t${_chalk().default.cyan(buildPaths.join('\n\t'))}`;
          } else {
            resultMsg = `${idStr} doesn't have a compiler, nothing to build`;
          }
        }
      } else {
        resultMsg = `file ${filePath} is not part of any component, ignoring it`;
      }

      const duration = new Date().getTime() - start;

      _loader().default.stop(); // @ts-ignore


      console.log(resultMsg);
      console.log(`took ${duration}ms`);
      console.log(_chalk().default.yellow(_constants().WATCHER_COMPLETED_MSG));
    })();
  }

  isComponentWatchedExternally(componentId) {
    const watcherData = this.multipleWatchers.find(m => m.componentIds.find(id => id.isEqual(componentId)));

    if (watcherData) {
      console.log(`${componentId.toString()} is watched by ${watcherData.compilerId.toString()}`);
      return true;
    }

    return false;
  }

  _getBitIdByPathAndReloadConsumer(filePath, isNew) {
    var _this4 = this;

    return (0, _bluebird().coroutine)(function* () {
      const relativeFile = (0, _utils().pathNormalizeToLinux)(_this4.consumer.getPathRelativeToConsumer(filePath));

      let componentId = _this4.consumer.bitMap.getComponentIdByPath(relativeFile);

      if (!isNew && !componentId) {
        return null;
      } // @todo: improve performance. probably only bit-map and the component itself need to be updated


      yield _this4.workspace._reloadConsumer();

      if (!componentId) {
        componentId = _this4.consumer.bitMap.getComponentIdByPath(relativeFile);
      }

      if (isNew && !componentId) {
        const trackDir = Object.keys(_this4.trackDirs).find(dir => relativeFile.startsWith(dir));

        if (trackDir) {
          const id = _this4.trackDirs[trackDir];

          const bitId = _this4.consumer.getParsedId(id); // loading the component causes the bitMap to be updated with the new path


          yield _this4.consumer.loadComponent(bitId);
          componentId = _this4.consumer.bitMap.getComponentIdByPath(relativeFile);
        }
      }

      return componentId;
    })();
  }

  _getWatcher() {
    const pathsToWatch = this._getPathsToWatch();

    return _chokidar().default.watch(pathsToWatch, {
      ignoreInitial: true,
      // Using the function way since the regular way not working as expected
      // It might be solved when upgrading to chokidar > 3.0.0
      // See:
      // https://github.com/paulmillr/chokidar/issues/773
      // https://github.com/paulmillr/chokidar/issues/492
      // https://github.com/paulmillr/chokidar/issues/724
      ignored: path => {
        // Ignore package.json temporarily since it cerates endless loop since it's re-written after each build
        if (path.includes('dist') || path.includes('node_modules') || path.includes('package.json')) {
          return true;
        }

        return false;
      },
      persistent: true,
      useFsEvents: false
    });
  }

  _getPathsToWatch() {
    const componentsFromBitMap = this.consumer.bitMap.getAllComponents();
    const paths = componentsFromBitMap.map(componentMap => {
      const componentId = componentMap.id.toString();
      const trackDir = componentMap.getTrackDir();

      if (trackDir) {
        this.trackDirs[trackDir] = componentId;
      }

      const relativePaths = trackDir ? [trackDir] : componentMap.getFilesRelativeToConsumer();
      const absPaths = relativePaths.map(relativePath => this.consumer.toAbsolutePath(relativePath));

      if (this.verbose) {
        console.log(`watching ${_chalk().default.bold(componentId)}\n${absPaths.join('\n')}`);
      }

      return absPaths;
    });
    return _ramda().default.flatten(paths);
  }

}

exports.default = Watch;