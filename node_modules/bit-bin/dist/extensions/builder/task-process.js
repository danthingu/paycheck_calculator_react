"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TaskProcess = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _glob() {
  const data = _interopRequireDefault(require("glob"));

  _glob = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = require("ramda");

  _ramda = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _extensionData() {
  const data = require("../../consumer/config/extension-data");

  _extensionData = function () {
    return data;
  };

  return data;
}

function _artifact() {
  const data = require("../../consumer/component/sources/artifact");

  _artifact = function () {
    return data;
  };

  return data;
}

class TaskProcess {
  constructor(task, taskResult, buildContext, extensionId = task.extensionId) {
    this.task = task;
    this.taskResult = taskResult;
    this.buildContext = buildContext;
    this.extensionId = extensionId;
  }

  throwIfErrorsFound() {
    const compsWithErrors = this.taskResult.components.filter(c => c.errors.length);

    if (compsWithErrors.length) {
      const title = `Builder found the following errors while running "${this.task.extensionId}" task\n`;
      const errorsStr = compsWithErrors.map(c => {
        const errors = c.errors.map(e => typeof e === 'string' ? e : e.toString());
        return `${c.id.toString()}\n${errors.join('\n')}`;
      }).join('\n\n');
      throw new (_generalError().default)(title + errorsStr);
    }
  }

  saveTaskResults() {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      const {
        components
      } = _this.buildContext;
      const resultsP = components.map( /*#__PURE__*/function () {
        var _ref = (0, _bluebird().coroutine)(function* (component) {
          _this.saveDataToComponent(component);

          yield _this.saveArtifactsToComponent(component);
        });

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());
      yield Promise.all(resultsP);
    })();
  }

  saveDataToComponent(component) {
    const componentResult = this.taskResult.components.find(c => c.id.isEqual(component.id));
    const data = componentResult && componentResult.data;

    if (data) {
      const extensionDataEntry = this.getExtensionDataEntry(component);
      extensionDataEntry.data = data;
    }
  }

  saveArtifactsToComponent(component) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      const {
        artifacts
      } = _this2.taskResult;

      if (artifacts.length) {
        const extensionDataEntry = _this2.getExtensionDataEntry(component);

        const capsule = _this2.buildContext.capsuleGraph.capsules.getCapsule(component.id);

        if (!capsule) throw new Error(`unable to find the capsule for ${component.id.toString()}`);
        const files = yield _this2.getFilesByArtifacts(capsule);
        const artifactsVinyl = files.map(file => new (_artifact().Artifact)({
          path: file,
          contents: capsule.fs.readFileSync(file)
        }));
        extensionDataEntry.artifacts = artifactsVinyl;
      }
    })();
  }

  getExtensionDataEntry(component) {
    const existingExtensionDataEntry = component.config.extensions.findCoreExtension(this.extensionId) || component.config.extensions.findExtension(this.extensionId);
    if (existingExtensionDataEntry) return existingExtensionDataEntry;
    const extensionDataEntry = new (_extensionData().ExtensionDataEntry)(undefined, undefined, this.extensionId);
    component.config.extensions.push(extensionDataEntry);
    return extensionDataEntry;
  }

  getFilesByArtifacts(capsule) {
    var _this3 = this;

    return (0, _bluebird().coroutine)(function* () {
      const filesP = _this3.taskResult.artifacts.map( /*#__PURE__*/function () {
        var _ref2 = (0, _bluebird().coroutine)(function* (artifact) {
          return getFilesFromCapsule(capsule, artifact.dirName);
        });

        return function (_x2) {
          return _ref2.apply(this, arguments);
        };
      }());

      return (0, _ramda().flatten)(yield Promise.all(filesP));
    })();
  }

} // @todo: fix.
// it skips the capsule fs because for some reason `capsule.fs.promises.readdir` doesn't work
// the same as `capsule.fs.readdir` and it doesn't have the capsule dir as pwd.

/**
 * returns the paths inside the capsule
 */


exports.TaskProcess = TaskProcess;

function getFilesFromCapsule(_x3, _x4) {
  return _getFilesFromCapsule.apply(this, arguments);
}

function _getFilesFromCapsule() {
  _getFilesFromCapsule = (0, _bluebird().coroutine)(function* (capsule, dir) {
    const files = _glob().default.sync('*', {
      cwd: _path().default.join(capsule.wrkDir, dir)
    });

    return files.map(file => _path().default.join(dir, file));
  });
  return _getFilesFromCapsule.apply(this, arguments);
}