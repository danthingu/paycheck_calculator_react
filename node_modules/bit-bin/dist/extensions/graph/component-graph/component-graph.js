"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ComponentGraph = exports.DEPENDENCIES_TYPES = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _cleargraph() {
  const data = require("cleargraph");

  _cleargraph = function () {
    return data;
  };

  return data;
}

function _dependency() {
  const data = require("../dependency");

  _dependency = function () {
    return data;
  };

  return data;
}

function _componentsGraph() {
  const data = require("../../../scope/graph/components-graph");

  _componentsGraph = function () {
    return data;
  };

  return data;
}

function _duplicateDependency() {
  const data = require("../duplicate-dependency");

  _duplicateDependency = function () {
    return data;
  };

  return data;
}

const DEPENDENCIES_TYPES = ['dependencies', 'devDependencies'];
exports.DEPENDENCIES_TYPES = DEPENDENCIES_TYPES;

class ComponentGraph extends _cleargraph().Graph {
  constructor(nodes = [], edges = []) {
    super(nodes, edges);
    (0, _defineProperty2().default)(this, "versionMap", void 0);
    this.versionMap = new Map();
  }

  static buildFromLegacy(legacyGraph, componentFactory) {
    const newGraph = new ComponentGraph();
    legacyGraph.nodes().forEach(nodeId => {
      newGraph.setNode(nodeId, componentFactory.fromLegacyComponent(legacyGraph.node(nodeId)));
    });
    legacyGraph.edges().forEach(edgeId => {
      const source = edgeId.v;
      const target = edgeId.w;
      const edgeObj = legacyGraph.edge(source, target) === 'dependencies' ? new (_dependency().Dependency)('runtime') : new (_dependency().Dependency)('dev');
      newGraph.setEdge(source, target, edgeObj);
    });
    newGraph.versionMap = newGraph._calculateVersionMap();
    return newGraph;
  }

  static build(workspace, componentFactory) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      const ids = (yield workspace.list()).map(comp => comp.id);
      const bitIds = ids.map(id => id._legacy);
      const initialGraph = yield (0, _componentsGraph().buildOneGraphForComponents)(bitIds, workspace.consumer);
      return _this.buildFromLegacy(initialGraph, componentFactory);
    })();
  }

  findDuplicateDependencies() {
    const duplicateDependencies = new Map();

    for (const [compFullName, versions] of this.versionMap) {
      if (versions.allVersionNodes.length > 1) {
        const versionSubgraphs = [];
        const notLatestVersions = versions.allVersionNodes.filter(version => version !== versions.latestVersionNode);
        notLatestVersions.forEach(version => {
          const predecessors = this.predecessorsSubgraph(version);
          const immediatePredecessors = [...this.predecessors(version).keys()];
          const subGraph = this.buildFromCleargraph(predecessors);
          const versionSubgraph = {
            versionId: version,
            subGraph,
            immediateDependents: immediatePredecessors
          };
          versionSubgraphs.push(versionSubgraph);
        });

        if (versionSubgraphs.length > 0) {
          const duplicateDep = new (_duplicateDependency().DuplicateDependency)(versions.latestVersionNode, versionSubgraphs);
          duplicateDependencies.set(compFullName, duplicateDep);
        }
      }
    }

    return duplicateDependencies;
  }

  buildFromCleargraph(graph) {
    const newGraph = new ComponentGraph();
    const newGraphNodes = [];
    const newGraphEdges = [];

    for (const [nodeId, node] of graph.nodes.entries()) {
      newGraphNodes.push({
        id: nodeId,
        node
      });
    }

    for (const [edgeId, edge] of graph.edges.entries()) {
      const {
        sourceId,
        targetId
      } = graph.edgeNodesById(edgeId);

      if (!!sourceId && !!targetId) {
        newGraphEdges.push({
          sourceId,
          targetId,
          edge
        });
      }
    }

    newGraph.setNodes(newGraphNodes);
    newGraph.setEdges(newGraphEdges);
    return newGraph;
  }

  _calculateVersionMap() {
    const versionMap = new Map();

    for (const [compKey, comp] of this.nodes.entries()) {
      const compFullName = comp.id._legacy.toStringWithoutVersion();

      if (!versionMap.has(compFullName)) {
        versionMap.set(compFullName, {
          allVersionNodes: [compKey],
          latestVersionNode: compKey
        });
      } else {
        const value = versionMap.get(compFullName);

        if (value) {
          var _this$node, _this$node2;

          if (Object.prototype.hasOwnProperty.call(value, 'allVersionNodes')) {
            value.allVersionNodes.push(compKey);
          }

          const currentCompVersion = (_this$node = this.node(compKey)) === null || _this$node === void 0 ? void 0 : _this$node.id._legacy.getVersion();
          const latestCompVersion = (_this$node2 = this.node(value.latestVersionNode)) === null || _this$node2 === void 0 ? void 0 : _this$node2.id._legacy.getVersion();

          if (!!currentCompVersion && !!latestCompVersion && currentCompVersion.isLaterThan(latestCompVersion)) {
            value.latestVersionNode = compKey;
          }
        }
      }
    }

    return versionMap;
  }

}

exports.ComponentGraph = ComponentGraph;