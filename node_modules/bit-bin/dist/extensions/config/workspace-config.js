"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformLegacyPropsToExtensions = transformLegacyPropsToExtensions;
exports.WorkspaceConfig = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function fs() {
  const data = _interopRequireWildcard(require("fs-extra"));

  fs = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = require("ramda");

  _ramda = function () {
    return data;
  };

  return data;
}

function _commentJson() {
  const data = require("comment-json");

  _commentJson = function () {
    return data;
  };

  return data;
}

function _workspaceConfig() {
  const data = _interopRequireDefault(require("../../consumer/config/workspace-config"));

  _workspaceConfig = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _invalidConfigFile() {
  const data = _interopRequireDefault(require("./exceptions/invalid-config-file"));

  _invalidConfigFile = function () {
    return data;
  };

  return data;
}

function _dataToPersist() {
  const data = _interopRequireDefault(require("../../consumer/component/sources/data-to-persist"));

  _dataToPersist = function () {
    return data;
  };

  return data;
}

function _sources() {
  const data = require("../../consumer/component/sources");

  _sources = function () {
    return data;
  };

  return data;
}

function _featureToggle() {
  const data = require("../../api/consumer/lib/feature-toggle");

  _featureToggle = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("../../consumer/config/exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _config() {
  const data = require("../../consumer/config");

  _config = function () {
    return data;
  };

  return data;
}

const INTERNAL_CONFIG_PROPS = ['$schema', '$schemaVersion'];

class WorkspaceConfig {
  constructor(data, legacyConfig) {
    this.data = data;
    this.legacyConfig = legacyConfig;
    (0, _defineProperty2().default)(this, "_path", void 0);
    (0, _defineProperty2().default)(this, "_extensions", void 0);
    (0, _defineProperty2().default)(this, "_legacyProps", void 0);
    (0, _defineProperty2().default)(this, "_getVariantsConfig", void 0);
    (0, _defineProperty2().default)(this, "_getVariantConfig", void 0);
    (0, _defineProperty2().default)(this, "isLegacy", void 0);

    if (data) {
      const withoutInternalConfig = (0, _ramda().omit)(INTERNAL_CONFIG_PROPS, data);
      this._extensions = withoutInternalConfig;
      this.isLegacy = false;
    } else {
      this.isLegacy = true; // We know we have either data or legacy config
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

      this._extensions = transformLegacyPropsToExtensions(legacyConfig);

      if (legacyConfig) {
        this._legacyProps = {
          dependenciesDirectory: legacyConfig.dependenciesDirectory,
          resolveModules: legacyConfig.resolveModules,
          saveDependenciesAsComponents: legacyConfig.saveDependenciesAsComponents,
          distEntry: legacyConfig.distEntry,
          distTarget: legacyConfig.distTarget
        };
      }
    }
  }

  get path() {
    var _this$legacyConfig;

    return this._path || ((_this$legacyConfig = this.legacyConfig) === null || _this$legacyConfig === void 0 ? void 0 : _this$legacyConfig.path) || '';
  }

  set path(configPath) {
    this._path = configPath;
  }

  get extensions() {
    const res = _config().ExtensionConfigList.fromObject(this._extensions);

    return res;
  }

  extension(extensionId, ignoreVersion) {
    const existing = this.extensions.findExtension(extensionId, ignoreVersion);
    return existing === null || existing === void 0 ? void 0 : existing.config;
  }

  registerGetVariantsConfig(fn) {
    this._getVariantsConfig = fn;
  }

  registerGetVariantConfig(fn) {
    this._getVariantConfig = fn;
  }

  getVariantsConfig() {
    if (this._getVariantsConfig && typeof this._getVariantsConfig === 'function') {
      return this._getVariantsConfig();
    }

    return undefined;
  }

  getVariantConfig(componentId) {
    if (this._getVariantConfig && typeof this._getVariantConfig === 'function') {
      return this._getVariantConfig(componentId);
    }

    return undefined;
  }
  /**
   * Create an instance of the WorkspaceConfig by an instance of the legacy config
   *
   * @static
   * @param {*} legacyConfig
   * @returns
   * @memberof WorkspaceConfig
   */


  static fromLegacyConfig(legacyConfig) {
    return new WorkspaceConfig(undefined, legacyConfig);
  }
  /**
   * Create an instance of the WorkspaceConfig by data
   *
   * @static
   * @param {WorkspaceConfigFileProps} data
   * @returns
   * @memberof WorkspaceConfig
   */


  static fromObject(data) {
    return new WorkspaceConfig(data, undefined);
  }
  /**
   * Create an instance of the WorkspaceConfig by the workspace config template and override values
   *
   * @static
   * @param {WorkspaceConfigFileProps} data values to override in the default template
   * @returns
   * @memberof WorkspaceConfig
   */


  static create(props, dirPath, legacyInitProps) {
    return (0, _bluebird().coroutine)(function* () {
      var _legacyInitProps$stan;

      if ((0, _featureToggle().isFeatureEnabled)(_featureToggle().HARMONY_FEATURE)) {
        const getTemplateFile = /*#__PURE__*/function () {
          var _ref = (0, _bluebird().coroutine)(function* () {
            try {
              return yield fs().readFile(path().join(__dirname, 'workspace-template.jsonc'));
            } catch (err) {
              if (err.code !== 'ENOENT') throw err; // when the extension is compiled by tsc, it doesn't copy .jsonc files into the dists, grab it from src

              return fs().readFile(path().join(__dirname, '..', 'workspace-template.jsonc'));
            }
          });

          return function getTemplateFile() {
            return _ref.apply(this, arguments);
          };
        }();

        const templateFile = yield getTemplateFile();
        const templateStr = templateFile.toString();
        const template = (0, _commentJson().parse)(templateStr); // TODO: replace this assign with some kind of deepAssign that keeps the comments
        // right now the comments above the internal props are overrides after the assign

        const merged = (0, _commentJson().assign)(template, props);
        const instance = new WorkspaceConfig(merged, undefined);

        if (dirPath) {
          instance.path = WorkspaceConfig.composeWorkspaceJsoncPath(dirPath);
        }

        return instance;
      } // @todo: once harmony is stable, revert the if, and use this 'legacy-workspace-config' feature.
      // if (isFeatureEnabled('legacy-workspace-config') && dirPath) {


      if (!dirPath) throw new Error('workspace-config, dirPath is missing'); // Only support here what needed for e2e tests

      const legacyProps = {};

      if (props['@teambit/dependency-resolver']) {
        legacyProps.packageManager = props['@teambit/dependency-resolver'].packageManager;
      }

      if (props['@teambit/workspace']) {
        legacyProps.componentsDefaultDirectory = props['@teambit/workspace'].defaultDirectory;
      }

      const standAlone = (_legacyInitProps$stan = legacyInitProps === null || legacyInitProps === void 0 ? void 0 : legacyInitProps.standAlone) !== null && _legacyInitProps$stan !== void 0 ? _legacyInitProps$stan : false;
      const legacyConfig = yield _workspaceConfig().default._ensure(dirPath, standAlone, legacyProps);
      const instance = WorkspaceConfig.fromLegacyConfig(legacyConfig);
      return instance; // }
    })();
  }
  /**
   * Ensure the given directory has a workspace config
   * Load if existing and create new if not
   *
   * @static
   * @param {PathOsBasedAbsolute} dirPath
   * @param {WorkspaceConfigFileProps} [workspaceConfigProps={} as any]
   * @returns {Promise<WorkspaceConfig>}
   * @memberof WorkspaceConfig
   */


  static ensure(dirPath, workspaceConfigProps = {}, legacyInitProps) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      try {
        let workspaceConfig = yield _this.loadIfExist(dirPath);

        if (workspaceConfig) {
          return workspaceConfig;
        }

        workspaceConfig = yield _this.create(workspaceConfigProps, dirPath, legacyInitProps);
        return workspaceConfig;
      } catch (err) {
        if (err instanceof _exceptions().InvalidBitJson || err instanceof _invalidConfigFile().default) {
          const workspaceConfig = _this.create(workspaceConfigProps, dirPath);

          return workspaceConfig;
        }

        throw err;
      }
    })();
  }
  /**
   * A function that register to the legacy ensure function in order to transform old props structure
   * to the new one
   * @param dirPath
   * @param standAlone
   * @param legacyWorkspaceConfigProps
   */


  static onLegacyEnsure(dirPath, standAlone, legacyWorkspaceConfigProps = {}) {
    return (0, _bluebird().coroutine)(function* () {
      const newProps = transformLegacyPropsToExtensions(legacyWorkspaceConfigProps); // TODO: gilad move to constants file

      newProps.$schemaVersion = '1.0.0';
      return WorkspaceConfig.ensure(dirPath, newProps, {
        standAlone
      });
    })();
  }

  static reset(dirPath, resetHard) {
    return (0, _bluebird().coroutine)(function* () {
      const workspaceJsoncPath = WorkspaceConfig.composeWorkspaceJsoncPath(dirPath);

      if (resetHard) {
        // Call the legacy reset hard to make sure there is no old bit.json kept
        _workspaceConfig().default.reset(dirPath, true);

        if (workspaceJsoncPath) {
          _logger().default.info(`deleting the consumer bit.jsonc file at ${workspaceJsoncPath}`);

          yield fs().remove(workspaceJsoncPath);
        }
      }
    })();
  }
  /**
   * Get the path of the bit.jsonc file by a containing folder
   *
   * @static
   * @param {PathOsBased} dirPath containing dir of the bit.jsonc file
   * @returns {PathOsBased}
   * @memberof WorkspaceConfig
   */


  static composeWorkspaceJsoncPath(dirPath) {
    return path().join(dirPath, _constants().WORKSPACE_JSONC);
  }

  static pathHasWorkspaceJsonc(dirPath) {
    return (0, _bluebird().coroutine)(function* () {
      const isExist = yield fs().pathExists(WorkspaceConfig.composeWorkspaceJsoncPath(dirPath));
      return isExist;
    })();
  }
  /**
   * Check if the given dir has workspace config (new or legacy)
   * @param dirPath
   */


  static isExist(dirPath) {
    return (0, _bluebird().coroutine)(function* () {
      const jsoncExist = yield WorkspaceConfig.pathHasWorkspaceJsonc(dirPath);

      if (jsoncExist) {
        return true;
      }

      return _workspaceConfig().default._isExist(dirPath);
    })();
  }
  /**
   * Load the workspace configuration if it's exist
   *
   * @static
   * @param {PathOsBased} dirPath
   * @returns {(Promise<WorkspaceConfig | undefined>)}
   * @memberof WorkspaceConfig
   */


  static loadIfExist(dirPath) {
    return (0, _bluebird().coroutine)(function* () {
      const jsoncExist = yield WorkspaceConfig.pathHasWorkspaceJsonc(dirPath);

      if (jsoncExist) {
        const jsoncPath = WorkspaceConfig.composeWorkspaceJsoncPath(dirPath);
        const instance = yield WorkspaceConfig._loadFromWorkspaceJsonc(jsoncPath);
        instance.path = jsoncPath;
        return instance;
      }

      const legacyConfig = yield _workspaceConfig().default._loadIfExist(dirPath);

      if (legacyConfig) {
        return WorkspaceConfig.fromLegacyConfig(legacyConfig);
      }

      return undefined;
    })();
  }

  static _loadFromWorkspaceJsonc(workspaceJsoncPath) {
    return (0, _bluebird().coroutine)(function* () {
      const contentBuffer = yield fs().readFile(workspaceJsoncPath);

      try {
        const parsed = (0, _commentJson().parse)(contentBuffer.toString());
        return WorkspaceConfig.fromObject(parsed);
      } catch (e) {
        throw new (_invalidConfigFile().default)(workspaceJsoncPath);
      }
    })();
  }

  write({
    workspaceDir
  }) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      var _this2$legacyConfig;

      if (_this2.data) {
        const files = yield _this2.toVinyl(workspaceDir);
        const dataToPersist = new (_dataToPersist().default)();

        if (files) {
          dataToPersist.addManyFiles(files);
          return dataToPersist.persistAllToFS();
        }
      }

      yield (_this2$legacyConfig = _this2.legacyConfig) === null || _this2$legacyConfig === void 0 ? void 0 : _this2$legacyConfig.write({
        workspaceDir
      });
      return undefined;
    })();
  }

  toVinyl(workspaceDir) {
    var _this3 = this;

    return (0, _bluebird().coroutine)(function* () {
      var _this3$legacyConfig;

      if (_this3.data) {
        const jsonStr = (0, _commentJson().stringify)(_this3.data, undefined, 2);
        const base = workspaceDir;
        const fullPath = workspaceDir ? WorkspaceConfig.composeWorkspaceJsoncPath(workspaceDir) : _this3.path;
        const jsonFile = new (_sources().AbstractVinyl)({
          base,
          path: fullPath,
          contents: Buffer.from(jsonStr)
        });
        return [jsonFile];
      }

      return (_this3$legacyConfig = _this3.legacyConfig) === null || _this3$legacyConfig === void 0 ? void 0 : _this3$legacyConfig.toVinyl({
        workspaceDir
      });
    })();
  }

  _legacyPlainObject() {
    if (this.legacyConfig) {
      return this.legacyConfig.toPlainObject();
    }

    return undefined;
  }

  toLegacy() {
    var _this$extension, _this$legacyConfig4, _this$extension2, _this$extension3, _this$extension4, _this$extension5, _this$_legacyProps, _this$_legacyProps2, _this$_legacyProps3, _this$_legacyProps4, _this$_legacyProps5, _this$extension6, _this$extension7, _this$legacyConfig5, _this$legacyConfig6, _this$legacyConfig7;

    const _setCompiler = compiler => {
      if (this.legacyConfig) {
        this.legacyConfig.setCompiler(compiler);
      }
    };

    const _setTester = tester => {
      if (this.legacyConfig) {
        this.legacyConfig.setTester(tester);
      }
    };

    const _getEnvsByType = type => {
      var _this$legacyConfig3;

      if (type === _constants().COMPILER_ENV_TYPE) {
        var _this$legacyConfig2;

        return (_this$legacyConfig2 = this.legacyConfig) === null || _this$legacyConfig2 === void 0 ? void 0 : _this$legacyConfig2.compiler;
      }

      return (_this$legacyConfig3 = this.legacyConfig) === null || _this$legacyConfig3 === void 0 ? void 0 : _this$legacyConfig3.tester;
    };

    let componentsDefaultDirectory = (_this$extension = this.extension('@teambit/workspace', true)) === null || _this$extension === void 0 ? void 0 : _this$extension.defaultDirectory;

    if (componentsDefaultDirectory && !componentsDefaultDirectory.includes('{name}')) {
      componentsDefaultDirectory = `${componentsDefaultDirectory}/{name}`;
    }

    return {
      lang: ((_this$legacyConfig4 = this.legacyConfig) === null || _this$legacyConfig4 === void 0 ? void 0 : _this$legacyConfig4.lang) || _constants().DEFAULT_LANGUAGE,
      defaultScope: (_this$extension2 = this.extension('@teambit/workspace', true)) === null || _this$extension2 === void 0 ? void 0 : _this$extension2.defaultScope,
      _useWorkspaces: (_this$extension3 = this.extension('@teambit/dependency-resolver', true)) === null || _this$extension3 === void 0 ? void 0 : _this$extension3.useWorkspaces,
      dependencyResolver: this.extension('@teambit/dependency-resolver', true),
      packageManager: (_this$extension4 = this.extension('@teambit/dependency-resolver', true)) === null || _this$extension4 === void 0 ? void 0 : _this$extension4.packageManager,
      _bindingPrefix: (_this$extension5 = this.extension('@teambit/workspace', true)) === null || _this$extension5 === void 0 ? void 0 : _this$extension5.defaultOwner,
      _distEntry: (_this$_legacyProps = this._legacyProps) === null || _this$_legacyProps === void 0 ? void 0 : _this$_legacyProps.distEntry,
      _distTarget: (_this$_legacyProps2 = this._legacyProps) === null || _this$_legacyProps2 === void 0 ? void 0 : _this$_legacyProps2.distTarget,
      _saveDependenciesAsComponents: (_this$_legacyProps3 = this._legacyProps) === null || _this$_legacyProps3 === void 0 ? void 0 : _this$_legacyProps3.saveDependenciesAsComponents,
      _dependenciesDirectory: (_this$_legacyProps4 = this._legacyProps) === null || _this$_legacyProps4 === void 0 ? void 0 : _this$_legacyProps4.dependenciesDirectory,
      componentsDefaultDirectory,
      _resolveModules: (_this$_legacyProps5 = this._legacyProps) === null || _this$_legacyProps5 === void 0 ? void 0 : _this$_legacyProps5.resolveModules,
      _manageWorkspaces: (_this$extension6 = this.extension('@teambit/dependency-resolver', true)) === null || _this$extension6 === void 0 ? void 0 : _this$extension6.manageWorkspaces,
      defaultOwner: (_this$extension7 = this.extension('@teambit/workspace', true)) === null || _this$extension7 === void 0 ? void 0 : _this$extension7.defaultOwner,
      extensions: this.extensions.toObject(),
      // @ts-ignore
      path: this.path,
      _getEnvsByType,
      isLegacy: this.isLegacy,
      write: this.write.bind(this),
      toVinyl: this.toVinyl.bind(this),
      componentsConfig: this.getVariantsConfig(),
      getComponentConfig: this.getVariantConfig.bind(this),
      _legacyPlainObject: this.legacyConfig ? (_this$legacyConfig5 = this.legacyConfig) === null || _this$legacyConfig5 === void 0 ? void 0 : _this$legacyConfig5.toPlainObject.bind(this.legacyConfig) : () => undefined,
      _compiler: (_this$legacyConfig6 = this.legacyConfig) === null || _this$legacyConfig6 === void 0 ? void 0 : _this$legacyConfig6.compiler,
      _setCompiler,
      _tester: (_this$legacyConfig7 = this.legacyConfig) === null || _this$legacyConfig7 === void 0 ? void 0 : _this$legacyConfig7.tester,
      _setTester
    };
  }

}

exports.WorkspaceConfig = WorkspaceConfig;

function transformLegacyPropsToExtensions(legacyConfig) {
  var _legacyConfig$overrid;

  // TODO: move to utils
  const removeUndefined = obj => {
    // const res = omit(mapObjIndexed((val) => val === undefined))(obj);
    // return res;
    Object.entries(obj).forEach(e => {
      if (e[1] === undefined) delete obj[e[0]];
    });
    return obj;
  };

  const workspace = removeUndefined({
    defaultScope: legacyConfig.defaultScope,
    defaultDirectory: legacyConfig.componentsDefaultDirectory,
    defaultOwner: legacyConfig.bindingPrefix
  });
  const dependencyResolver = removeUndefined({
    packageManager: legacyConfig.packageManager,
    // strictPeerDependencies: false,
    extraArgs: legacyConfig.packageManagerArgs,
    packageManagerProcessOptions: legacyConfig.packageManagerProcessOptions,
    manageWorkspaces: legacyConfig.manageWorkspaces,
    useWorkspaces: legacyConfig.useWorkspaces
  });
  const variants = (_legacyConfig$overrid = legacyConfig.overrides) === null || _legacyConfig$overrid === void 0 ? void 0 : _legacyConfig$overrid.overrides;
  const data = {};

  if (workspace && !(0, _ramda().isEmpty)(workspace)) {
    data['@teambit/workspace'] = workspace;
  }

  if (dependencyResolver && !(0, _ramda().isEmpty)(dependencyResolver)) {
    data['@teambit/dependency-resolver'] = dependencyResolver;
  } // TODO: add variants here once we have a way to pass the deps overrides and general key vals for package.json to
  // TODO: new extensions (via dependency-resolver extension and pkg extensions)
  // TODO: transform legacy props to new one once dependency-resolver extension and pkg extensions are ready


  if (variants && !(0, _ramda().isEmpty)(variants)) {
    data['@teambit/variants'] = variants;
  } // @ts-ignore


  return data;
}