"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = require("ramda");

  _ramda = function () {
    return data;
  };

  return data;
}

function _ramdaAdjunct() {
  const data = require("ramda-adjunct");

  _ramdaAdjunct = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = require("../component");

  _component = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _resolvedComponent() {
  const data = require("../utils/resolved-component/resolved-component");

  _resolvedComponent = function () {
    return data;
  };

  return data;
}

function _addComponents() {
  const data = _interopRequireDefault(require("../../consumer/component-ops/add-components"));

  _addComponents = function () {
    return data;
  };

  return data;
}

function _loadExtensions() {
  const data = require("../utils/load-extensions");

  _loadExtensions = function () {
    return data;
  };

  return data;
}

function _config() {
  const data = _interopRequireDefault(require("../../consumer/config"));

  _config = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("./utils");

  _utils = function () {
    return data;
  };

  return data;
}

/**
 * API of the Bit Workspace
 */
class Workspace {
  constructor(config, consumer, scope, componentFactory, isolateEnv, dependencyResolver, variants, logger, componentList = new (_componentsList().default)(consumer), harmony) {
    var _this$config, _this$config2;

    this.config = config;
    this.consumer = consumer;
    this.scope = scope;
    this.componentFactory = componentFactory;
    this.isolateEnv = isolateEnv;
    this.dependencyResolver = dependencyResolver;
    this.variants = variants;
    this.logger = logger;
    this.componentList = componentList;
    this.harmony = harmony;
    (0, _defineProperty2().default)(this, "owner", void 0);
    (0, _defineProperty2().default)(this, "componentsScopeDirsMap", void 0);
    this.owner = (_this$config = this.config) === null || _this$config === void 0 ? void 0 : _this$config.defaultOwner;
    this.componentsScopeDirsMap = ((_this$config2 = this.config) === null || _this$config2 === void 0 ? void 0 : _this$config2.components) || [];
  }
  /**
   * root path of the Workspace.
   */


  get path() {
    return this.consumer.getPath();
  }
  /**
   * provides status of all components in the workspace.
   */


  status() {}
  /**
   * list all workspace components.
   */


  list() {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      const consumerComponents = yield _this.componentList.getAuthoredAndImportedFromFS();
      return _this.transformLegacyComponents(consumerComponents);
    })();
  }

  transformLegacyComponents(consumerComponents) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      const transformP = consumerComponents.map(consumerComponent => {
        return _this2.componentFactory.fromLegacyComponent(consumerComponent);
      });
      return Promise.all(transformP);
    })();
  }
  /**
   * list all modified components in the workspace.
   */


  modified() {
    var _this3 = this;

    return (0, _bluebird().coroutine)(function* () {
      const consumerComponents = yield _this3.componentList.listModifiedComponents(true); // @ts-ignore

      return _this3.transformLegacyComponents(consumerComponents);
    })();
  }
  /**
   * list all new components in the workspace.
   */


  newComponents() {
    var _this4 = this;

    return (0, _bluebird().coroutine)(function* () {
      const consumerComponents = yield _this4.componentList.listNewComponents(true); // @ts-ignore

      return _this4.transformLegacyComponents(consumerComponents);
    })();
  }

  loadCapsules(bitIds) {
    var _this5 = this;

    return (0, _bluebird().coroutine)(function* () {
      // throw new Error("Method not implemented.");
      const components = yield _this5.load(bitIds);
      return components.map(comp => comp.capsule);
    })();
  }
  /**
   * fully load components, including dependency resolution and prepare them for runtime.
   * @todo: remove the string option, use only BitId
   * fully load components, including dependency resolution and prepare them for runtime.
   */


  load(ids) {
    var _this6 = this;

    return (0, _bluebird().coroutine)(function* () {
      const components = yield _this6.getMany(ids);
      const isolatedEnvironment = yield _this6.isolateEnv.createNetworkFromConsumer(components.map(c => c.id.toString()), _this6.consumer, {
        packageManager: 'npm'
      });
      const capsulesMap = isolatedEnvironment.capsules.reduce((accum, curr) => {
        accum[curr.id.toString()] = curr.capsule;
        return accum;
      }, {});
      const ret = components.map(component => new (_resolvedComponent().ResolvedComponent)(component, capsulesMap[component.id.toString()]));
      return ret;
    })();
  }
  /**
   * @todo: remove the string option, use only BitId
   * get a component from workspace
   * @param id component ID
   */


  get(id) {
    var _this7 = this;

    return (0, _bluebird().coroutine)(function* () {
      const getBitId = () => {
        if (id instanceof _component().ComponentID) return id._legacy;
        if (typeof id === 'string') return _this7.consumer.getParsedId(id);
        return id;
      };

      const componentId = getBitId();
      if (!componentId) return undefined;
      const legacyComponent = yield _this7.consumer.loadComponent(componentId);
      return _this7.componentFactory.fromLegacyComponent(legacyComponent);
    })();
  } // @gilad needs to implment on variants
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  byPattern(pattern) {
    var _this8 = this;

    return (0, _bluebird().coroutine)(function* () {
      // @todo: this is a naive implementation, replace it with a real one.
      const all = yield _this8.list();
      return all.filter(c => c.id.toString() === pattern);
    })();
  }
  /**
   * @todo: remove the string option, use only BitId
   */


  getMany(ids) {
    var _this9 = this;

    return (0, _bluebird().coroutine)(function* () {
      const componentIds = ids.map(id => typeof id === 'string' ? _this9.consumer.getParsedId(id) : id);
      const idsWithoutEmpty = (0, _ramdaAdjunct().compact)(componentIds);
      const legacyComponents = yield _this9.consumer.loadComponents(_bitId().BitIds.fromArray(idsWithoutEmpty)); // @ts-ignore

      return _this9.transformLegacyComponents(legacyComponents.components);
    })();
  }
  /**
   * track a new component. (practically, add it to .bitmap).
   *
   * @param componentPaths component paths relative to the workspace dir
   * @param id if not set, will be concluded from the filenames
   * @param main if not set, will try to guess according to some strategies and throws if failed
   * @param override whether add details to an existing component or re-define it
   */


  add(componentPaths, id, main, override = false) {
    var _this10 = this;

    return (0, _bluebird().coroutine)(function* () {
      const addComponent = new (_addComponents().default)({
        consumer: _this10.consumer
      }, {
        componentPaths,
        id,
        main,
        override
      });
      const addResults = yield addComponent.add(); // @todo: the legacy commands have `consumer.onDestroy()` on command completion, it writes the
      //  .bitmap file. workspace needs a similar mechanism. once done, remove the next line.

      yield _this10.consumer.bitMap.write();
      return addResults;
    })();
  }
  /**
   * Get the component root dir in the file system (relative to workspace or full)
   * @param componentId
   * @param relative return the path relative to the workspace or full path
   */


  componentDir(componentId, relative = false) {
    const componentMap = this.consumer.bitMap.getComponent(componentId);
    const relativeComponentDir = componentMap.getComponentDir();

    if (relative) {
      return relativeComponentDir;
    }

    if (relativeComponentDir) {
      return _path().default.join(this.path, relativeComponentDir);
    }

    return undefined;
  } // TODO: gilad - add return value

  /**
   * Calculate the component config based on the component.json file in the component folder and the matching
   * pattern in the variants config
   * @param componentId
   */
  // componentConfig(componentId: BitId) {
  // TODO: read the component.json file and merge it inside
  // const inlineConfig = this.inlineComponentConfig(componentId);
  // const variantConfig = this.variants.getComponentConfig(componentId);
  // For legacy configs it will be undefined.
  // This should be changed once we have basic dependnecy-resolver and pkg extensions see more at src/extensions/config/workspace-config.ts
  // under transformLegacyPropsToExtensions
  // if (!variantConfig) {
  // }
  // }
  // TODO: gilad - add return value

  /**
   * return the component config from its folder (bit.json / package.json / component.json)
   * @param componentId
   */


  inlineComponentConfig(componentId) {
    // TODO: Load from component.json file
    const legacyConfigProps = _config().default.loadConfigFromFolder({
      workspaceDir: this.path,
      componentDir: this.componentDir(componentId)
    }); // TODO: make sure it's a new format


    return legacyConfigProps;
  } // async loadComponentExtensions(componentId: BitId): Promise<void> {
  //   const config = this.componentConfig(componentId);
  //   const extensions = config.extensions
  //     ? ExtensionConfigList.fromObject(config.extensions)
  //     : ExtensionConfigList.fromArray([]);
  //   return this.loadExtensions(extensions);
  // }

  /**
   * Load all unloaded extensions from a list
   * @param extensions list of extensions with config to load
   */


  loadExtensions(extensions) {
    var _this11 = this;

    return (0, _bluebird().coroutine)(function* () {
      const extensionsIds = extensions.ids;
      const loadedExtensions = _this11.harmony.extensionsIds;
      const extensionsToLoad = (0, _ramda().difference)(extensionsIds, loadedExtensions);
      if (!extensionsToLoad.length) return;
      let resolvedExtensions = [];
      resolvedExtensions = yield _this11.load(extensionsToLoad); // TODO: change to use the new reporter API, in order to implement this
      // we would have to have more than 1 instance of the Reporter extension (one for the workspace and one for the CLI command)
      //
      // We need to think of a facility to show "system messages that do not stop execution" like this. We might want to (for example)
      // have each command query the logger for such messages and decide whether to display them or not (according to the verbosity
      // level passed to it).

      yield (0, _loadExtensions().loadResolvedExtensions)(_this11.harmony, resolvedExtensions, _logger().default);
    })();
  }
  /**
   * Install dependencies for all components in the workspace
   *
   * @returns
   * @memberof Workspace
   */


  install() {
    var _this12 = this;

    return (0, _bluebird().coroutine)(function* () {
      //      this.reporter.info('Installing component dependencies');
      //      this.reporter.setStatusText('Installing');
      const components = yield _this12.list(); // this.reporter.info('Isolating Components');

      const isolatedEnvs = yield _this12.load(components.map(c => c.id.toString())); // this.reporter.info('Installing workspace dependencies');

      yield (0, _utils().removeExistingLinksInNodeModules)(isolatedEnvs);
      yield _this12.dependencyResolver.folderInstall(process.cwd());
      yield (0, _utils().symlinkCapsulesInNodeModules)(isolatedEnvs); // this.reporter.end();

      return isolatedEnvs;
    })();
  }
  /**
   * this should be rarely in-use.
   * it's currently used by watch extension as a quick workaround to load .bitmap and the components
   */


  _reloadConsumer() {
    var _this13 = this;

    return (0, _bluebird().coroutine)(function* () {
      _this13.consumer = yield (0, _consumer().loadConsumer)(_this13.path, true);
    })();
  } // TODO: should we return here the dir as it defined (aka components) or with /{name} prefix (as it used in legacy)


  get defaultDirectory() {
    return this.config.defaultDirectory;
  }

  get legacyDefaultDirectory() {
    if (this.defaultDirectory && !this.defaultDirectory.includes('{name}')) {
      return `${this.defaultDirectory}/{name}`;
    }

    return this.defaultDirectory;
  }

}

exports.default = Workspace;