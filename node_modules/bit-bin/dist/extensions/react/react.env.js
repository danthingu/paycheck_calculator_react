"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactEnv = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _webpack() {
  const data = _interopRequireDefault(require("webpack"));

  _webpack = function () {
    return data;
  };

  return data;
}

function _http() {
  const data = _interopRequireDefault(require("http"));

  _http = function () {
    return data;
  };

  return data;
}

function _fs() {
  const data = _interopRequireDefault(require("fs"));

  _fs = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function () {
    return data;
  };

  return data;
}

function _socket() {
  const data = _interopRequireDefault(require("socket.io"));

  _socket = function () {
    return data;
  };

  return data;
}

function _webpackDevServer() {
  const data = _interopRequireDefault(require("webpack-dev-server"));

  _webpackDevServer = function () {
    return data;
  };

  return data;
}

function _webpack2() {
  const data = _interopRequireDefault(require("./webpack.config"));

  _webpack2 = function () {
    return data;
  };

  return data;
}

function _extensionData() {
  const data = require("../../consumer/config/extension-data");

  _extensionData = function () {
    return data;
  };

  return data;
}

function _docs() {
  const data = require("./docs.tpl");

  _docs = function () {
    return data;
  };

  return data;
}

class ReactEnv {
  constructor(logger, jest, ts, compiler, tester) {
    this.logger = logger;
    this.jest = jest;
    this.ts = ts;
    this.compiler = compiler;
    this.tester = tester;
  } // this should happen on component load.


  patchComponents(components, workspace) {
    return components.map(component => {
      var _component$state$_con;

      const docs = component.filesystem.readdirSync('/').filter(path => path.includes('.docs.'))[0];
      if (!docs) return component; // @ts-ignore

      const filepath = (0, _path().join)(workspace.path, (_component$state$_con = component.state._consumer.componentMap) === null || _component$state$_con === void 0 ? void 0 : _component$state$_con.getComponentDir(), docs);
      component.state.store.push(new (_extensionData().ExtensionDataEntry)(undefined, undefined, '@teambit/docs', {}, {
        filepath
      }));
      return component;
    });
  }
  /**
   * returns the component linter.
   */


  getLinter() {}
  /**
   * returns a component tester.
   */


  getTester() {
    return this.jest.createTester(require.resolve('./jest/jest.config'));
  }
  /**
   * returns a component compiler.
   */


  getCompiler() {
    // eslint-disable-next-line global-require
    const tsConfig = require('./typescript/tsconfig.json');

    return this.ts.createCompiler(tsConfig);
  }

  dependencies() {
    return (0, _bluebird().coroutine)(function* () {
      return {
        dependencies: {
          react: '-'
        },
        // TODO: add this only if using ts
        devDependencies: {
          '@types/react': '^16.9.17'
        },
        // TODO: take version from workspace.json config
        peerDependencies: {
          react: '^16.12.0'
        }
      };
    })();
  }
  /**
   * returns a build pipeline.
   */


  getPipe() {
    // return BuildPipe.from([this.compiler.task, this.tester.task]);
    // return BuildPipe.from([this.tester.task]);
    return [this.compiler.task];
  }

  dev(workspace, components) {
    // if (config.compiler.watch) {
    //   this.typescript.watch();
    // }
    // remove once gilad has metadata
    const patchedComponent = this.patchComponents(components, workspace);
    const config = (0, _webpack2().default)(workspace.path, this.getEntries(patchedComponent));
    const compiler = (0, _webpack().default)(config);
    const devSever = new (_webpackDevServer().default)(compiler, {
      publicPath: config.output.publicPath,
      hot: true,
      historyApiFallback: true,

      before(app) {
        const server = new (_http().default.Server)(app);
        const io = (0, _socket().default)(server);
        io.on('connection', () => {
          io.sockets.emit('components', patchedComponent.map(component => {
            var _component$state$_con2;

            // refactor to compositions
            const docs = component.filesystem.readdirSync('/').filter(path => path.includes('.docs.'))[0];
            const componentDir = (_component$state$_con2 = component.state._consumer.componentMap) === null || _component$state$_con2 === void 0 ? void 0 : _component$state$_con2.getComponentDir();
            if (!componentDir) throw new Error(`React.dev: component ${component.id.name} is missing componentMap`);
            return {
              id: component.id.toString(),
              docs: docs ? (0, _path().join)(workspace.path, componentDir, docs) : null
            };
          }));
        });
        server.listen(4000, () => {// console.log('listening on *:4000');
        });
      },

      proxy: {
        '/api': {
          target: 'http://localhost:4000',
          pathRewrite: {
            '^/api': ''
          }
        },
        '/socket.io': {
          target: 'http://localhost:4000',
          ws: true
        }
      }
    });
    devSever.listen(3000, 'localhost', err => {
      if (err) {
        this.logger.error(err);
      }
    });
  }

  getEntries(components) {
    const docs = (0, _docs().docsTemplate)(components);
    const docsPath = (0, _path().resolve)((0, _path().join)(__dirname, '/__docs.js'));

    _fs().default.writeFileSync(docsPath, docs);

    const paths = components.map(component => {
      var _component$state$_con3;

      const path = (0, _path().join)( // :TODO check how it works with david. Feels like a side-effect.
      // @ts-ignore
      (_component$state$_con3 = component.state._consumer.componentMap) === null || _component$state$_con3 === void 0 ? void 0 : _component$state$_con3.getComponentDir(), // @ts-ignore
      component.config.main);
      return path;
    });
    return paths.concat(docsPath);
  }

}

exports.ReactEnv = ReactEnv;