"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Compile = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("./../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _buildComponent() {
  const data = _interopRequireDefault(require("../../consumer/component-ops/build-component"));

  _buildComponent = function () {
    return data;
  };

  return data;
}

function _dataToPersist() {
  const data = _interopRequireDefault(require("../../consumer/component/sources/data-to-persist"));

  _dataToPersist = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _sources() {
  const data = require("../../consumer/component/sources");

  _sources = function () {
    return data;
  };

  return data;
}

function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("../../utils/bit/component-id-to-package-name"));

  _componentIdToPackageName = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _packageJsonFile() {
  const data = _interopRequireDefault(require("../../consumer/component/package-json-file"));

  _packageJsonFile = function () {
    return data;
  };

  return data;
}

class Compile {
  constructor(workspace, envs, task) {
    this.workspace = workspace;
    this.envs = envs;
    this.task = task;
  }

  compileOnWorkspace(componentsIds, // when empty, it compiles all
  noCache, verbose, dontPrintEnvMsg) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      const bitIds = getBitIds(componentsIds, _this.workspace);
      const {
        components
      } = yield _this.workspace.consumer.loadComponents(_bitId().BitIds.fromArray(bitIds));
      const componentsWithLegacyCompilers = [];
      const componentsAndNewCompilers = [];
      components.forEach(c => {
        var _c$componentMap;

        const environment = _this.envs.getEnvFromExtensions(c.extensions);

        const compilerInstance = environment === null || environment === void 0 ? void 0 : environment.getCompiler(); // if there is no componentDir (e.g. author that added files, not dir), then we can't write the dists
        // inside the component dir.

        if (compilerInstance && ((_c$componentMap = c.componentMap) === null || _c$componentMap === void 0 ? void 0 : _c$componentMap.getComponentDir())) {
          const compilerName = compilerInstance.constructor.name || 'compiler';
          componentsAndNewCompilers.push({
            component: c,
            compilerInstance,
            compilerName
          });
        } else {
          componentsWithLegacyCompilers.push(c);
        }
      });
      let newCompilersResultOnWorkspace = [];
      let oldCompilersResult = [];

      if (componentsAndNewCompilers.length) {
        newCompilersResultOnWorkspace = yield _this.compileWithNewCompilersOnWorkspace(componentsAndNewCompilers);
      }

      if (componentsWithLegacyCompilers.length) {
        oldCompilersResult = yield _this.compileWithLegacyCompilers(componentsWithLegacyCompilers, noCache, verbose, dontPrintEnvMsg);
      }

      return [...newCompilersResultOnWorkspace, ...oldCompilersResult];
    })();
  }

  compileWithNewCompilersOnWorkspace(componentsAndNewCompilers) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      const build = /*#__PURE__*/function () {
        var _ref = (0, _bluebird().coroutine)(function* ({
          component,
          compilerName: compilerId,
          compilerInstance
        }) {
          if (!compilerInstance.compileFile) {
            throw new Error(`compiler ${compilerId.toString()} doesn't implement "compileFile" interface`);
          }

          const packageName = (0, _componentIdToPackageName().default)(component.id, component.bindingPrefix, component.defaultScope);

          const packageDir = _path().default.join('node_modules', packageName);

          const distDirName = _constants().DEFAULT_DIST_DIRNAME;

          const distDir = _path().default.join(packageDir, distDirName);

          const dists = [];
          const compileErrors = [];
          yield Promise.all(component.files.map( /*#__PURE__*/function () {
            var _ref2 = (0, _bluebird().coroutine)(function* (file) {
              var _component$componentM;

              const relativeComponentDir = (_component$componentM = component.componentMap) === null || _component$componentM === void 0 ? void 0 : _component$componentM.getComponentDir();
              if (!relativeComponentDir) throw new Error(`compileWithNewCompilersOnWorkspace expect to get only components with rootDir`);

              const componentDir = _path().default.join(_this2.workspace.path, relativeComponentDir);

              const options = {
                componentDir,
                filePath: file.relative
              };
              let compileResults;

              try {
                compileResults = compilerInstance.compileFile(file.contents.toString(), options);
              } catch (error) {
                compileErrors.push({
                  path: file.path,
                  error
                });
                return;
              }

              const base = distDir;

              if (compileResults) {
                dists.push(...compileResults.map(result => new (_sources().Dist)({
                  base,
                  path: _path().default.join(base, result.outputPath),
                  contents: Buffer.from(result.outputText)
                })));
              } else {
                // compiler doesn't support this file type. copy the file as is to the dist dir.
                dists.push(new (_sources().Dist)({
                  base,
                  path: _path().default.join(base, file.relative),
                  contents: file.contents
                }));
              }
            });

            return function (_x2) {
              return _ref2.apply(this, arguments);
            };
          }()));

          if (compileErrors.length) {
            const formatError = errorItem => `${errorItem.path}\n${errorItem.error}`;

            throw new Error(`compilation failed. see the following errors from the compiler
${compileErrors.map(formatError).join('\n')}`);
          } // writing the dists with `component.setDists(dists); component.dists.writeDists` is tricky
          // as it uses other base-paths and doesn't respect the new node-modules base path.


          const dataToPersist = new (_dataToPersist().default)();
          dataToPersist.addManyFiles(dists);
          const found = (0, _utils().searchFilesIgnoreExt)(dists, component.mainFile, 'relative');
          if (!found) throw new Error(`unable to find dist main file for ${component.id.toString()}`);

          const packageJson = _packageJsonFile().default.loadFromPathSync(_this2.workspace.path, packageDir);

          if (!packageJson.fileExist) {
            throw new Error(`failed finding package.json file in ${packageDir}, please run "bit link"`);
          }

          packageJson.addOrUpdateProperty('main', (0, _utils().pathJoinLinux)(distDirName, found));
          dataToPersist.addFile(packageJson.toVinylFile());
          dataToPersist.addBasePath(_this2.workspace.path);
          yield dataToPersist.persistAllToFS();
          const oneBuildResults = dists.map(distFile => distFile.path);
          if (component.compiler) _loader().default.succeed();
          return {
            component: component.id.toString(),
            buildResults: oneBuildResults
          };
        });

        return function build(_x) {
          return _ref.apply(this, arguments);
        };
      }();

      const allBuildResults = yield (0, _pMapSeries().default)(componentsAndNewCompilers, build);
      return allBuildResults;
    })();
  }

  compileWithLegacyCompilers(components, noCache, verbose, dontPrintEnvMsg) {
    var _this3 = this;

    return (0, _bluebird().coroutine)(function* () {
      _logger().default.debugAndAddBreadCrumb('scope.buildMultiple', 'using the legacy build mechanism');

      const build = /*#__PURE__*/function () {
        var _ref3 = (0, _bluebird().coroutine)(function* (component) {
          if (component.compiler) _loader().default.start(`building component - ${component.id}`);
          yield component.build({
            scope: _this3.workspace.consumer.scope,
            consumer: _this3.workspace.consumer,
            noCache,
            verbose,
            dontPrintEnvMsg
          });
          const buildResults = yield component.dists.writeDists(component, _this3.workspace.consumer, false);
          if (component.compiler) _loader().default.succeed();
          return {
            component: component.id.toString(),
            buildResults
          };
        });

        return function build(_x3) {
          return _ref3.apply(this, arguments);
        };
      }();

      const writeLinks = /*#__PURE__*/function () {
        var _ref4 = (0, _bluebird().coroutine)(function* (component) {
          return component.dists.writeDistsLinks(component, _this3.workspace.consumer);
        });

        return function writeLinks(_x4) {
          return _ref4.apply(this, arguments);
        };
      }();

      const buildResults = yield (0, _pMapSeries().default)(components, build);
      yield (0, _pMapSeries().default)(components, writeLinks);
      return buildResults;
    })();
  }

  populateComponentDist(params, component) {
    return (0, _buildComponent().default)({
      component: component.consumerComponent,
      scope: this.workspace.consumer.scope,
      consumer: this.workspace.consumer,
      verbose: params.verbose,
      noCache: params.noCache
    });
  }

  writeComponentDist(componentAndCapsule) {
    return (0, _bluebird().coroutine)(function* () {
      const dataToPersist = new (_dataToPersist().default)();
      const distsFiles = componentAndCapsule.consumerComponent.dists.get();
      distsFiles.map(d => d.updatePaths({
        newBase: 'dist'
      }));
      dataToPersist.addManyFiles(distsFiles);
      yield dataToPersist.persistAllToCapsule(componentAndCapsule.capsule);
      return distsFiles.map(d => d.path);
    })();
  }

}

exports.Compile = Compile;

function getBitIds(componentsIds, workspace) {
  if (componentsIds.length) {
    return componentsIds.map(compId => compId instanceof _bitId().BitId ? compId : workspace.consumer.getParsedId(compId));
  }

  return workspace.consumer.bitMap.getAuthoredAndImportedBitIds();
}