"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.execAction = execAction;
exports.register = register;
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _commander() {
  const data = _interopRequireDefault(require("commander"));

  _commander = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("./loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _globalFlags() {
  const data = _interopRequireDefault(require("./global-flags"));

  _globalFlags = function () {
    return data;
  };

  return data;
}

function _commandRunner() {
  const data = require("./command-runner");

  _commandRunner = function () {
    return data;
  };

  return data;
}

function parseSubcommandFromArgs(args) {
  if (typeof (0, _utils().first)(args) === 'string') return (0, _utils().first)(args);
  return null;
}

function parseCommandName(commandName) {
  if (!commandName) return '';
  return (0, _utils().first)(commandName.split(' '));
}

function getOpts(c, opts) {
  const options = {};
  opts.forEach(([, name]) => {
    const parsedName = parseCommandName(name);
    const camelCaseName = (0, _utils().camelCase)(parsedName);

    if (name.startsWith('no-')) {
      // from commander help: "Note that multi-word options starting with --no prefix negate the boolean value of the following word. For example, --no-sauce sets the value of program.sauce to false."
      // we don't want this feature, so we do the opposite action.
      options[camelCaseName] = !c[(0, _utils().camelCase)(parsedName.replace('no-', ''))];
    } else {
      options[camelCaseName] = c[camelCaseName];
    }
  });
  return options;
}
/**
 * execute the command.
 * the stack trace up to this point is confusing, it's helpful to outline it here:
 * CLIExtension.run => commander.parse(params) => commander-pkg.parse => commander-pkg.parseArgs => execAction
 */


function execAction(_x, _x2, _x3) {
  return _execAction.apply(this, arguments);
}
/**
 * register the action of each one of the commands.
 * at this point, it doesn't run any `execAction`, it only register it.
 * the actual running of `execAction` happens once `commander.parse(params)` is called.
 */


function _execAction() {
  _execAction = (0, _bluebird().coroutine)(function* (command, concrete, args) {
    const flags = getOpts(concrete, command.options);
    const relevantArgs = args.slice(0, args.length - 1);

    _analytics().Analytics.init(concrete.name(), flags, relevantArgs);

    _logger().default.info(`[*] started a new command: "${command.name}" with the following data:`, {
      args: relevantArgs,
      flags
    });

    if (command.loader && !flags.json) {
      _loader().default.on();
    }

    if (flags[_constants().TOKEN_FLAG_NAME]) {
      _globalFlags().default.token = flags[_constants().TOKEN_FLAG_NAME].toString();
    }

    _logger().default.shouldWriteToConsole = !flags.json;
    const commandRunner = new (_commandRunner().CommandRunner)(command, relevantArgs, flags);
    return commandRunner.runCommand();
  });
  return _execAction.apply(this, arguments);
}

function registerAction(command, concrete) {
  concrete.action((...args) => {
    const subCommands = command.commands;

    if (subCommands === null || subCommands === void 0 ? void 0 : subCommands.length) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const subcommandName = parseSubcommandFromArgs(args);
      const subcommand = subCommands.find(cmd => {
        return subcommandName === (parseCommandName(cmd.name) || cmd.alias);
      });
      args.shift();
      if (subcommand) return execAction(subcommand, concrete, args);
    }

    return execAction(command, concrete, args);
  });
}

function createOptStr(alias, name) {
  if (alias) {
    return `-${alias}, --${name}`;
  }

  return `--${name}`;
}

function register(command, commanderCmd, packageManagerArgs) {
  const concrete = commanderCmd.command(command.name, null, {
    noHelp: command.private
  }).description(command.description).alias(command.alias);

  if (command.remoteOp) {
    command.options.push(['', _constants().TOKEN_FLAG, 'authentication token']);
  }

  if (packageManagerArgs) {
    command._packageManagerArgs = packageManagerArgs;
  }

  command.options.forEach(([alias, name, description]) => {
    concrete.option(createOptStr(alias, name), description);
  }); // attach skip-update to all commands

  concrete.option(_constants().SKIP_UPDATE_FLAG, 'Skips auto updates');

  if (command.commands) {
    command.commands.forEach(nestedCmd => {
      register(nestedCmd, concrete);
    });
  }

  return registerAction(command, concrete);
}

class CommandRegistry {
  registerBaseCommand() {
    _commander().default.version(this.version).usage(this.usage).option(_constants().SKIP_UPDATE_FLAG, 'Skips auto updates for a command').description(this.description);
  }

  constructor(usage, description, version, commands, extensionsCommands) {
    (0, _defineProperty2().default)(this, "version", void 0);
    (0, _defineProperty2().default)(this, "usage", void 0);
    (0, _defineProperty2().default)(this, "description", void 0);
    (0, _defineProperty2().default)(this, "commands", void 0);
    (0, _defineProperty2().default)(this, "extensionsCommands", void 0);
    this.usage = usage;
    this.description = description;
    this.version = version;
    this.commands = commands; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    this.extensionsCommands = extensionsCommands;
  }

}

exports.default = CommandRegistry;