"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleErrorAndExit = handleErrorAndExit;
exports.handleUnhandledRejection = handleUnhandledRejection;
exports.logErrAndExit = logErrAndExit;
exports.CommandRunner = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _serializeError() {
  const data = require("serialize-error");

  _serializeError = function () {
    return data;
  };

  return data;
}

function _ink() {
  const data = require("ink");

  _ink = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../api/consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _defaultErrorHandler() {
  const data = _interopRequireDefault(require("./default-error-handler"));

  _defaultErrorHandler = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("./loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

class CommandRunner {
  constructor(command, args, flags) {
    this.command = command;
    this.args = args;
    this.flags = flags;
  }
  /**
   * run command using one of the handler, "json"/"report"/"render". once done, exit the process.
   */


  runCommand() {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      try {
        yield _this.runMigrateIfNeeded();

        if (_this.flags.json) {
          return yield _this.runJsonHandler();
        }

        if (_this.shouldRunRender()) {
          return yield _this.runRenderHandler();
        }

        if (_this.command.report) {
          return yield _this.runReportHandler();
        }
      } catch (err) {
        return handleErrorAndExit(err, _this.command.name, _this.command.internal);
      }

      throw new Error(`command "${_this.command.name}" doesn't implement "render" nor "report" methods`);
    })();
  }
  /**
   * when both "render" and "report" were implemented, check whether it's a terminal.
   * if it's a terminal, use "render", if not, use "report" because "report" is just a string
   */


  shouldRunRender() {
    const isTerminal = process.stdout.isTTY;

    if (this.command.report && !isTerminal) {
      return false;
    }

    return Boolean(this.command.render);
  }

  runJsonHandler() {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      if (!_this2.flags.json) return null;
      if (!_this2.command.json) throw new Error(`command "${_this2.command.name}" doesn't implement "json" method`);
      const result = yield _this2.command.json(_this2.args, _this2.flags);

      _loader().default.off();

      const code = result.code || 0;
      const data = result.data || result;
      return _this2.writeAndExit(JSON.stringify(data, null, 2), code);
    })();
  }

  runRenderHandler() {
    var _this3 = this;

    return (0, _bluebird().coroutine)(function* () {
      if (!_this3.command.render) throw new Error('runRenderHandler expects command.render to be implemented');
      const result = yield _this3.command.render(_this3.args, _this3.flags);

      _loader().default.off();

      const {
        waitUntilExit
      } = (0, _ink().render)(result);
      yield waitUntilExit();
      return _logger().default.exitAfterFlush(result.props.code, _this3.command.name);
    })();
  }

  runReportHandler() {
    var _this4 = this;

    return (0, _bluebird().coroutine)(function* () {
      if (!_this4.command.report) throw new Error('runReportHandler expects command.report to be implemented');
      const result = yield _this4.command.report(_this4.args, _this4.flags);

      _loader().default.off();

      const data = typeof result === 'string' ? result : result.data;
      const exitCode = typeof result === 'string' ? 0 : result.code;
      return _this4.writeAndExit(`${data}\n`, exitCode);
    })();
  }

  writeAndExit(data, exitCode) {
    return process.stdout.write(data, () => _logger().default.exitAfterFlush(exitCode, this.command.name));
  }

  runMigrateIfNeeded() {
    var _this5 = this;

    return (0, _bluebird().coroutine)(function* () {
      // @ts-ignore LegacyCommandAdapter has .migration
      if (_this5.command.migration) {
        _logger().default.debug('Checking if a migration is needed'); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


        return (0, _consumer().migrate)(null, false);
      }

      return null;
    })();
  }

}

exports.CommandRunner = CommandRunner;

function serializeErrAndExit(err, commandName) {
  const data = (0, _utils().packCommand)((0, _utils().buildCommandMessage)((0, _serializeError().serializeError)(err), undefined, false), false, false);
  const code = err.code && (0, _utils().isNumeric)(err.code) ? err.code : 1;
  return process.stderr.write(data, () => _logger().default.exitAfterFlush(code, commandName));
}

function handleErrorAndExit(err, commandName, shouldSerialize = false) {
  _loader().default.off();

  _logger().default.error(`got an error from command ${commandName}: ${err}`);

  _logger().default.error(err.stack || '<no error stack was found>');

  const {
    message,
    error
  } = (0, _defaultErrorHandler().default)(err);
  if (shouldSerialize) return serializeErrAndExit(error, commandName);
  return logErrAndExit(message, commandName);
}

function handleUnhandledRejection(err) {
  // eslint-disable-next-line no-console
  console.error('** unhandled rejection found, please make sure the promise is resolved/rejected correctly! **');

  if (err instanceof Error) {
    return handleErrorAndExit(err, process.argv[2]);
  }

  console.error(err); // eslint-disable-line

  return handleErrorAndExit(new Error(`unhandledRejections found. err ${err}`), process.argv[2]);
}

function logErrAndExit(err, commandName) {
  if (!err) throw new Error(`logErrAndExit expects to get either an Error or a string, got nothing`);
  console.error(err); // eslint-disable-line

  _logger().default.exitAfterFlush(1, commandName);
}