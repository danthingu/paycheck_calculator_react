"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

function _bluebird() {
  const data = _interopRequireWildcard(require("bluebird"));

  _bluebird = function () {
    return data;
  };

  return data;
}

function _harmony() {
  const data = _interopRequireDefault(require("@teambit/harmony"));

  _harmony = function () {
    return data;
  };

  return data;
}

function _hooks() {
  const data = _interopRequireDefault(require("./hooks"));

  _hooks = function () {
    return data;
  };

  return data;
}

function _commandRunner() {
  const data = require("./cli/command-runner");

  _commandRunner = function () {
    return data;
  };

  return data;
}

function _config() {
  const data = require("./extensions/config");

  _config = function () {
    return data;
  };

  return data;
}

function _bit() {
  const data = require("./extensions/bit");

  _bit = function () {
    return data;
  };

  return data;
}

process.env.MEMFS_DONT_WARN = 'true'; // suppress fs experimental warnings from memfs
// by default Bluebird enables the longStackTraces when env is `development`, or when
// BLUEBIRD_DEBUG is set.
// the drawback of enabling it all the time is a performance hit. (see http://bluebirdjs.com/docs/api/promise.longstacktraces.html)
// some commands are slower by 20% with this enabled.

_bluebird().default.config({
  longStackTraces: Boolean(process.env.BLUEBIRD_DEBUG || process.env.BIT_LOG)
});

initApp();

function initApp() {
  return _initApp.apply(this, arguments);
}

function _initApp() {
  _initApp = (0, _bluebird().coroutine)(function* () {
    try {
      _hooks().default.init();

      yield _harmony().default.run(_config().ConfigExt);
      yield _harmony().default.set([_bit().BitExt]);

      const cli = _harmony().default.get('CLIExtension');

      if (!cli) throw new Error(`failed to get CLIExtension from Harmony`);
      yield cli.run();
    } catch (err) {
      const originalError = err.originalError || err;
      (0, _commandRunner().handleErrorAndExit)(originalError, process.argv[2]);
    }
  });
  return _initApp.apply(this, arguments);
}

process.on('unhandledRejection', err => (0, _commandRunner().handleUnhandledRejection)(err));