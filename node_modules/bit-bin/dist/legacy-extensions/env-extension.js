"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _baseExtension() {
  const data = _interopRequireDefault(require("./base-extension"));

  _baseExtension = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = _interopRequireDefault(require("../bit-id/bit-id"));

  _bitId = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _extensionGetDynamicPackagesError() {
  const data = _interopRequireDefault(require("./exceptions/extension-get-dynamic-packages-error"));

  _extensionGetDynamicPackagesError = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _extensionGetDynamicConfigError() {
  const data = _interopRequireDefault(require("./exceptions/extension-get-dynamic-config-error"));

  _extensionGetDynamicConfigError = function () {
    return data;
  };

  return data;
}

function _installExtensions() {
  const data = _interopRequireDefault(require("../scope/extensions/install-extensions"));

  _installExtensions = function () {
    return data;
  };

  return data;
}

function _abstractConfig() {
  const data = _interopRequireDefault(require("../consumer/config/abstract-config"));

  _abstractConfig = function () {
    return data;
  };

  return data;
}

function _envFactory() {
  const data = _interopRequireDefault(require("./env-factory"));

  _envFactory = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class EnvExtension extends _baseExtension().default {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  /**
   * Return the action
   */
  get action() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (this.script && this.script.action && typeof this.script.action === 'function') {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return this.script.action;
    }

    return undefined;
  }
  /**
   * return old actions (to support old compilers / testers which uses run / compile functions)
   */
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  get oldAction() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (this.script && this.script.run && typeof this.script.run === 'function') {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return this.script.run;
    } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    if (this.script && this.script.compile && typeof this.script.compile === 'function') {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return this.script.compile;
    }

    return undefined;
  }

  constructor(extensionProps) {
    super(extensionProps);
    (0, _defineProperty2().default)(this, "envType", void 0);
    (0, _defineProperty2().default)(this, "dynamicPackageDependencies", void 0);
    (0, _defineProperty2().default)(this, "dataToPersist", void 0);
    this.envType = extensionProps.envType;
    this.dynamicPackageDependencies = extensionProps.dynamicPackageDependencies;
  }

  install(scope, opts, context) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      _logger().default.debugAndAddBreadCrumb('env-extension', 'install env extension'); // Skip the installation in case of using specific file
      // options.file usually used for develop your extension
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      if (_this.options.file) {
        return undefined;
      }

      const dependentId = _ramda().default.path(['dependentId'], context);

      const installOpts = _objectSpread({
        ids: [{
          componentId: _bitId().default.parse(_this.name, true),
          type: _this.envType.toLowerCase()
        }],
        // @todo: make sure it always has a scope name
        dependentId,
        scope
      }, opts); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      const installResult = yield (0, _installExtensions().default)(installOpts);

      _this.setExtensionPathInScope(scope.getPath());

      yield _this.reload(scope.getPath(), context);
      return installResult;
    })();
  }

  toModelObject() {
    const baseObject = super.toModelObject();

    const modelObject = _objectSpread({}, baseObject);

    return modelObject;
  }

  toObject() {
    const baseObject = super.toObject();

    const object = _objectSpread({}, baseObject);

    return object;
  }
  /**
   * Get a bit.json representation of the env instance
   * @param {string} ejectedEnvDirectory - The base path of where the env config files are stored
   * $FlowFixMe seems to be an issue opened for this https://github.com/facebook/flow/issues/4953
   */
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  toBitJsonObject() {
    _logger().default.silly('env-extension, toBitJsonObject');

    const envVal = {
      rawConfig: this.dynamicConfig,
      options: this.options
    }; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return {
      [this.name]: envVal
    };
  }

  reload(scopePath, context) {
    var _superprop_getReload = () => super.reload,
        _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      _logger().default.silly('env-extension, reload');

      if (context) {
        _this2.context = context;
      }

      const throws = true;
      yield _superprop_getReload().call(_this2, scopePath, {
        throws
      }); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const dynamicPackageDependencies = EnvExtension.loadDynamicPackageDependencies(_this2);
      _this2.dynamicPackageDependencies = dynamicPackageDependencies;
    })();
  }
  /**
   * Loading from props (usually from bit.json)
   * @param {*} props
   * $FlowFixMe seems to be an issue opened for this https://github.com/facebook/flow/issues/4953
   */


  static load(props) {
    var _superprop_getLoad = () => super.load,
        _this3 = this;

    return (0, _bluebird().coroutine)(function* () {
      const baseExtensionProps = yield _superprop_getLoad().call(_this3, props);

      const envExtensionProps = _objectSpread({
        envType: props.envType
      }, baseExtensionProps);

      const dynamicPackageDependencies = EnvExtension.loadDynamicPackageDependencies(envExtensionProps);
      envExtensionProps.dynamicPackageDependencies = dynamicPackageDependencies;
      const dynamicConfig = EnvExtension.loadDynamicConfig(envExtensionProps); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      envExtensionProps.dynamicConfig = dynamicConfig;
      return envExtensionProps;
    })();
  }

  static loadDynamicPackageDependencies(envExtensionProps) {
    const getDynamicPackageDependencies = _ramda().default.path(['script', 'getDynamicPackageDependencies'], envExtensionProps);

    if (!getDynamicPackageDependencies || typeof getDynamicPackageDependencies !== 'function') {
      return undefined;
    }

    let dynamicPackageDependencies;

    try {
      dynamicPackageDependencies = getDynamicPackageDependencies({
        rawConfig: envExtensionProps.rawConfig,
        dynamicConfig: envExtensionProps.dynamicConfig,
        context: envExtensionProps.context
      });
    } catch (err) {
      throw new (_extensionGetDynamicPackagesError().default)(err, envExtensionProps.name);
    }

    if (!dynamicPackageDependencies) return undefined;

    if (typeof dynamicPackageDependencies !== 'object') {
      throw new (_generalError().default)('expect getDynamicPackageDependencies to return an object');
    } // old format returned an object of the packages, without any separation between
    // dependencies, devDependencies and peerDependencies


    const usesOldFormat = Object.keys(dynamicPackageDependencies).some(field => !_constants().DEPENDENCIES_FIELDS.includes(field));

    if (usesOldFormat) {
      throw new (_generalError().default)(`getDynamicPackageDependencies expects to return the following keys only: [${_constants().DEPENDENCIES_FIELDS.join(', ')}]`);
    }

    return dynamicPackageDependencies;
  }

  static loadDynamicConfig(envExtensionProps) {
    const getDynamicConfig = _ramda().default.path(['script', 'getDynamicConfig'], envExtensionProps);

    if (getDynamicConfig && typeof getDynamicConfig === 'function') {
      try {
        const dynamicConfig = getDynamicConfig({
          rawConfig: envExtensionProps.rawConfig,
          context: envExtensionProps.context
        });
        return dynamicConfig;
      } catch (err) {
        throw new (_extensionGetDynamicConfigError().default)(err, envExtensionProps.name);
      }
    }

    return undefined;
  }

  static loadFromModelObject(modelObject) {
    var _superprop_getLoadFromModelObjectBase = () => super.loadFromModelObjectBase,
        _this4 = this;

    return (0, _bluebird().coroutine)(function* () {
      const baseExtensionProps = _superprop_getLoadFromModelObjectBase().call(_this4, modelObject);

      const envExtensionProps = _objectSpread({
        envType: modelObject.envType
      }, baseExtensionProps);

      return envExtensionProps;
    })();
  }

  static loadFromSerializedModelObject(modelObject) {
    var _superprop_getLoadFromModelObjectBase2 = () => super.loadFromModelObjectBase,
        _this5 = this;

    return (0, _bluebird().coroutine)(function* () {
      _logger().default.silly('env-extension, loadFromModelObject');

      const baseExtensionProps = _superprop_getLoadFromModelObjectBase2().call(_this5, modelObject);

      const envExtensionProps = _objectSpread({
        envType: modelObject.envType
      }, baseExtensionProps);

      return envExtensionProps;
    })();
  }
  /**
   * load the compiler/tester according to the following strategies:
   * 1. from component config (bit.json/package.json of the component) if it was written.
   * 2. from component model. an imported component might not have the config written.
   * for author, it's irrelevant, because upon import it's written to consumer config (if changed).
   * 3. from consumer config overrides. (bit.json/package.json of the consumer when this component
   * overrides the general env config).
   * 4. from consumer config.
   */


  static loadFromCorrectSource({
    consumerPath,
    scopePath,
    componentOrigin,
    componentFromModel,
    componentConfig,
    overrides,
    workspaceConfig,
    envType,
    context
  }) {
    return (0, _bluebird().coroutine)(function* () {
      _logger().default.silly(`env-extension (${envType}) loadFromCorrectSource`);

      const isAuthor = componentOrigin === _constants().COMPONENT_ORIGINS.AUTHORED;

      const componentHasWrittenConfig = componentConfig && componentConfig.componentHasWrittenConfig; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      if (componentHasWrittenConfig && componentConfig[envType]) {
        // load from component config.
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        if (Object.keys(componentConfig[envType])[0] === _constants().MANUALLY_REMOVE_ENVIRONMENT) {
          _logger().default.debug(`env-extension, ${envType} was manually removed from the component config`);

          return null;
        } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


        const envConfig = {
          [envType]: componentConfig[envType]
        }; // $FlowFixMe we made sure before that componentConfig is defined
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        const configPath = path().dirname(componentConfig.path);

        _logger().default.silly(`env-extension loading ${envType} from component config`);

        return loadFromConfig({
          envConfig,
          envType,
          consumerPath,
          scopePath,
          configPath,
          context
        });
      }

      if (isAuthor && componentConfig && componentConfig[envType]) {
        // load from component config.
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        if (Object.keys(componentConfig[envType])[0] === _constants().MANUALLY_REMOVE_ENVIRONMENT) {
          _logger().default.debug(`env-extension, ${envType} was manually removed from the component config`);

          return null;
        } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


        const envConfig = {
          [envType]: componentConfig[envType]
        };

        _logger().default.silly(`env-extension loading ${envType} from component config in workspace config`);

        return loadFromConfig({
          envConfig,
          envType,
          consumerPath,
          scopePath,
          configPath: consumerPath,
          context
        });
      }

      if (!componentHasWrittenConfig && !isAuthor && componentFromModel && componentFromModel[envType]) {
        // config was not written into component dir, load the config from the model
        _logger().default.silly(`env-extension, loading ${envType} from the model`);

        return componentFromModel[envType];
      }

      const envFromOverride = overrides.getEnvByType(envType);

      if (envFromOverride) {
        if (envFromOverride === _constants().MANUALLY_REMOVE_ENVIRONMENT) {
          _logger().default.debug(`env-extension, ${envType} was manually removed from the overrides`);

          return null;
        }

        _logger().default.silly(`env-extension, loading ${envType} from the overrides`);

        const envConfig = {
          [envType]: _abstractConfig().default.transformEnvToObject(envFromOverride)
        };
        return loadFromConfig({
          envConfig,
          envType,
          consumerPath,
          scopePath,
          configPath: consumerPath,
          context
        });
      }

      if (isAuthor && workspaceConfig[`_${envType}`]) {
        _logger().default.silly(`env-extension, loading ${envType} from the consumer config`);

        const envConfig = {
          [envType]: workspaceConfig[`_${envType}`]
        };
        return loadFromConfig({
          envConfig,
          envType,
          consumerPath,
          scopePath,
          configPath: consumerPath,
          context
        });
      }

      return null;
    })();
  }
  /**
   * are two envs (in the model/scope format) different
   */


  static areEnvsDifferent(envModelA, envModelB) {
    const sortEnv = env => {
      env.config = (0, _utils().sortObject)(env.config);
      const result = (0, _utils().sortObject)(env);
      return result;
    };

    const stringifyEnv = env => {
      if (!env) {
        return '';
      }

      if (typeof env === 'string') {
        return env;
      }

      return JSON.stringify(sortEnv(env));
    };

    const envModelAString = stringifyEnv(envModelA);
    const envModelBString = stringifyEnv(envModelB); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return (0, _utils().sha1)(envModelAString) !== (0, _utils().sha1)(envModelBString);
  }

}

exports.default = EnvExtension;

function loadFromConfig(_x) {
  return _loadFromConfig.apply(this, arguments);
}

function _loadFromConfig() {
  _loadFromConfig = (0, _bluebird().coroutine)(function* ({
    envConfig,
    envType,
    consumerPath,
    scopePath,
    configPath,
    context
  }) {
    const env = envConfig[envType];
    if (!env) return null;
    const envName = Object.keys(env)[0];
    const envObject = env[envName];
    const envProps = {
      name: envName,
      consumerPath,
      scopePath,
      rawConfig: envObject.rawConfig,
      files: envObject.files,
      bitJsonPath: configPath,
      options: envObject.options,
      envType,
      context
    };
    return (0, _envFactory().default)(envType, envProps);
  });
  return _loadFromConfig.apply(this, arguments);
}