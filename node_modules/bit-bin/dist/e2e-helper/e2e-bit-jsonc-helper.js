"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _commentJson() {
  const data = require("comment-json");

  _commentJson = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

// TODO: improve this by combine into a base class shared between this and e2e-bit-json-helper
class BitJsoncHelper {
  constructor(scopes) {
    (0, _defineProperty2().default)(this, "scopes", void 0);
    this.scopes = scopes;
  }

  read(bitJsoncDir = this.scopes.localPath) {
    const bitJsoncPath = composePath(bitJsoncDir);

    if (_fsExtra().default.existsSync(bitJsoncPath)) {
      const content = _fsExtra().default.readFileSync(bitJsoncPath).toString();

      return (0, _commentJson().parse)(content);
    }

    return {};
  }

  write(bitJsonc, bitJsoncDir = this.scopes.localPath) {
    const bitJsoncPath = composePath(bitJsoncDir);
    const content = (0, _commentJson().stringify)(bitJsonc, null, 2);
    return _fsExtra().default.writeFileSync(bitJsoncPath, content);
  }

  addKeyVal(bitJsoncDir = this.scopes.localPath, key, val) {
    const bitJsonc = this.read(bitJsoncDir); // Using this to keep the comments

    const obj = {
      [key]: val
    };
    const updated = (0, _commentJson().assign)(bitJsonc, obj);
    this.write(updated, bitJsoncDir);
  }

  addToVariant(bitJsoncDir = this.scopes.localPath, variant, key, val) {
    var _variants$variant;

    const bitJsonc = this.read(bitJsoncDir);
    const variants = bitJsonc['@teambit/variants'];
    const newVariant = (_variants$variant = variants[variant]) !== null && _variants$variant !== void 0 ? _variants$variant : {};
    (0, _commentJson().assign)(newVariant, {
      [key]: val
    });
    this.setVariant(bitJsoncDir, variant, newVariant);
  }
  /**
   * Replace the entire variant config with the provided config.
   * In case you only want to add new extension to variant you probably want to use addToVariant
   * @param bitJsoncDir
   * @param variant
   * @param config
   */


  setVariant(bitJsoncDir = this.scopes.localPath, variant, config) {
    const bitJsonc = this.read(bitJsoncDir);
    const variants = bitJsonc['@teambit/variants'];
    const newVariant = config;
    (0, _commentJson().assign)(variants, {
      [variant]: newVariant
    });
    this.addKeyVal(bitJsoncDir, '@teambit/variants', variants);
  }

  addKeyValToWorkspace(key, val, bitJsoncDir = this.scopes.localPath) {
    const bitJsonc = this.read(bitJsoncDir);
    const workspace = bitJsonc['@teambit/workspace'];
    (0, _commentJson().assign)(workspace, {
      [key]: val
    });
    this.addKeyVal(bitJsoncDir, '@teambit/workspace', workspace);
  }

  addDefaultScope(scope = this.scopes.remote) {
    this.addKeyValToWorkspace('defaultScope', scope);
  }

  addDefaultOwner(owner) {
    this.addKeyValToWorkspace('defaultOwner', owner);
  }

}

exports.default = BitJsoncHelper;

function composePath(dir) {
  return path().join(dir, _constants().WORKSPACE_JSONC);
}