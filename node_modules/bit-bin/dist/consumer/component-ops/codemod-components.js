"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.changeCodeFromRelativeToModulePaths = changeCodeFromRelativeToModulePaths;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("../../utils/bit/component-id-to-package-name"));

  _componentIdToPackageName = function () {
    return data;
  };

  return data;
}

function _replacePackageName() {
  const data = _interopRequireDefault(require("../../utils/string/replace-package-name"));

  _replacePackageName = function () {
    return data;
  };

  return data;
}

function _dataToPersist() {
  const data = _interopRequireDefault(require("../component/sources/data-to-persist"));

  _dataToPersist = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _incorrectRootDir() {
  const data = _interopRequireDefault(require("../component/exceptions/incorrect-root-dir"));

  _incorrectRootDir = function () {
    return data;
  };

  return data;
}

function changeCodeFromRelativeToModulePaths(_x, _x2) {
  return _changeCodeFromRelativeToModulePaths.apply(this, arguments);
}

function _changeCodeFromRelativeToModulePaths() {
  _changeCodeFromRelativeToModulePaths = (0, _bluebird().coroutine)(function* (consumer, bitIds) {
    const components = yield loadComponents(consumer, bitIds);
    const componentsWithRelativeIssues = components.filter(c => c.issues && c.issues.relativeComponentsAuthored);
    const dataToPersist = new (_dataToPersist().default)();
    const codemodResults = componentsWithRelativeIssues.map(component => {
      const {
        files,
        warnings
      } = codemodComponent(component);
      dataToPersist.addManyFiles(files);
      return {
        id: component.id,
        changedFiles: files.map(f => f.relative),
        warnings
      };
    });
    yield dataToPersist.persistAllToFS();
    return codemodResults.filter(c => c.changedFiles.length || c.warnings);
  });
  return _changeCodeFromRelativeToModulePaths.apply(this, arguments);
}

function loadComponents(_x3, _x4) {
  return _loadComponents.apply(this, arguments);
}

function _loadComponents() {
  _loadComponents = (0, _bluebird().coroutine)(function* (consumer, bitIds) {
    const componentsIds = bitIds.length ? _bitId().BitIds.fromArray(bitIds) : consumer.bitmapIds;
    const {
      components,
      invalidComponents
    } = yield consumer.loadComponents(componentsIds, false);
    invalidComponents.forEach(invalidComp => {
      if (invalidComp.error instanceof _incorrectRootDir().default) components.push(invalidComp.component);else throw invalidComp.error;
    });
    return components;
  });
  return _loadComponents.apply(this, arguments);
}

function codemodComponent(component) {
  const issues = component.issues;
  const files = [];
  if (!issues || !issues.relativeComponentsAuthored) return {
    files
  };
  const warnings = [];
  component.files.forEach(file => {
    const relativeInstances = issues.relativeComponentsAuthored[(0, _utils().pathNormalizeToLinux)(file.relative)];
    if (!relativeInstances) return; // @ts-ignore

    const fileBefore = file.contents.toString();
    let newFileString = fileBefore;
    relativeInstances.forEach(relativeEntry => {
      const id = relativeEntry.componentId;

      if (isLinkFileHasDifferentImportType(relativeEntry.importSpecifiers)) {
        warnings.push(`"${file.relative}" requires "${id.toString()}" through a link-file ("${relativeEntry.importSource}") and not directly, which makes it difficult change the import, please change your code to require the component directly`);
        return;
      }

      const packageName = (0, _componentIdToPackageName().default)(id, component.bindingPrefix, component.defaultScope);
      const cssFamily = ['.css', '.scss', '.less', '.sass'];
      const isCss = cssFamily.includes(file.extname);
      const packageNameSupportCss = isCss ? `~${packageName}` : packageName;
      newFileString = (0, _replacePackageName().default)(newFileString, relativeEntry.importSource, packageNameSupportCss);
    });

    if (fileBefore !== newFileString) {
      // @ts-ignore
      file.contents = Buffer.from(newFileString);
      files.push(file);
    }
  });
  return {
    files,
    warnings
  };
}
/**
 * if this is a link-file (a file that only import and export other files), bit doesn't require
 * the user to track it and it knows to skip it. If however, the link file uses default import and
 * the real file uses non-default, or vice versa, the codemod will result in an incorrect import
 * statement, and won't work.
 */


function isLinkFileHasDifferentImportType(importSpecifiers) {
  if (!importSpecifiers) return false;
  return importSpecifiers.some(importSpecifier => {
    if (!importSpecifier.linkFile) return false;
    return importSpecifier.linkFile.isDefault !== importSpecifier.mainFile.isDefault;
  });
}