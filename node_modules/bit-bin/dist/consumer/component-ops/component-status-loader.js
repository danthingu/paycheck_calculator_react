"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ComponentStatusLoader = void 0;

function _bluebird() {
  const data = _interopRequireWildcard(require("bluebird"));

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("../bit-map/exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _missingFilesFromComponent() {
  const data = _interopRequireDefault(require("../component/exceptions/missing-files-from-component"));

  _missingFilesFromComponent = function () {
    return data;
  };

  return data;
}

function _componentNotFoundInPath() {
  const data = _interopRequireDefault(require("../component/exceptions/component-not-found-in-path"));

  _componentNotFoundInPath = function () {
    return data;
  };

  return data;
}

function _componentOutOfSync() {
  const data = _interopRequireDefault(require("../exceptions/component-out-of-sync"));

  _componentOutOfSync = function () {
    return data;
  };

  return data;
}

function _componentsPendingImport() {
  const data = _interopRequireDefault(require("../component-ops/exceptions/components-pending-import"));

  _componentsPendingImport = function () {
    return data;
  };

  return data;
}

function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));

  _showDoctorError = function () {
    return data;
  };

  return data;
}

class ComponentStatusLoader {
  // cache loaded components
  constructor(consumer) {
    this.consumer = consumer;
    (0, _defineProperty2().default)(this, "_componentsStatusCache", {});
  }

  getManyComponentsStatuses(ids) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      const results = [];
      yield _bluebird().default.mapSeries(ids, /*#__PURE__*/function () {
        var _ref = (0, _bluebird().coroutine)(function* (id) {
          const status = yield _this.getComponentStatusById(id);
          results.push({
            id,
            status
          });
        });

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());
      return results;
    })();
  }
  /**
   * Get a component status by ID. Return a ComponentStatus object.
   * Keep in mind that a result can be a partial object of ComponentStatus, e.g. { notExist: true }.
   * Each one of the ComponentStatus properties can be undefined, true or false.
   * As a result, in order to check whether a component is not modified use (status.modified === false).
   * Don't use (!status.modified) because a component may not exist and the status.modified will be undefined.
   *
   * The status may have 'true' for several properties. For example, a component can be staged and modified at the
   * same time.
   *
   * The result is cached per ID and can be called several times with no penalties.
   */


  getComponentStatusById(id) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      if (!_this2._componentsStatusCache[id.toString()]) {
        _this2._componentsStatusCache[id.toString()] = yield _this2.getStatus(id);
      }

      return _this2._componentsStatusCache[id.toString()];
    })();
  }

  getStatus(id) {
    var _this3 = this;

    return (0, _bluebird().coroutine)(function* () {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const status = {};
      const componentFromModel = yield _this3.consumer.scope.getModelComponentIfExist(id);
      let componentFromFileSystem;

      try {
        // change to 'latest' before loading from FS. don't change to null, otherwise, it'll cause
        // loadOne to not find model component as it assumes there is no version
        // also, don't leave the id as is, otherwise, it'll cause issues with import --merge, when
        // imported version is bigger than .bitmap, it won't find it and will consider as deleted
        componentFromFileSystem = yield _this3.consumer.loadComponent(id.changeVersion(_constants().LATEST));
      } catch (err) {
        if (err instanceof _missingFilesFromComponent().default || err instanceof _componentNotFoundInPath().default || err instanceof _exceptions().MissingBitMapComponent) {
          // the file/s have been deleted or the component doesn't exist in bit.map file
          if (componentFromModel) status.deleted = true;else status.notExist = true;
          return status;
        }

        if (err instanceof _componentsPendingImport().default) {
          status.missingFromScope;
          return status;
        }

        throw err;
      }

      if (componentFromFileSystem.componentMap.origin === _constants().COMPONENT_ORIGINS.NESTED) {
        status.nested = true;
        return status;
      }

      if (!componentFromModel) {
        status.newlyCreated = true;
        return status;
      }

      status.staged = componentFromModel.isLocallyChanged();
      const versionFromFs = componentFromFileSystem.id.version;
      const idStr = id.toString();

      if (!componentFromFileSystem.id.hasVersion()) {
        throw new (_componentOutOfSync().default)(idStr);
      } // TODO: instead of doing that like this we should use:
      // const versionFromModel = await componentFromModel.loadVersion(versionFromFs, this.consumer.scope.objects);
      // it looks like it's exactly the same code but it's not working from some reason


      const versionRef = componentFromModel.versions[versionFromFs];
      if (!versionRef) throw new (_showDoctorError().default)(`version ${versionFromFs} was not found in ${idStr}`);
      const versionFromModel = yield _this3.consumer.scope.getObject(versionRef.hash);

      if (!versionFromModel) {
        throw new (_showDoctorError().default)(`failed loading version ${versionFromFs} of ${idStr} from the scope`);
      } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      status.modified = yield _this3.consumer.isComponentModified(versionFromModel, componentFromFileSystem);
      return status;
    })();
  }

}

exports.ComponentStatusLoader = ComponentStatusLoader;