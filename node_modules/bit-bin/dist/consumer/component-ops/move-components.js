"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.movePaths = movePaths;
exports.moveExistingComponent = moveExistingComponent;
exports.moveExistingComponentFilesToOneDir = moveExistingComponentFilesToOneDir;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _links() {
  const data = require("../../links");

  _links = function () {
    return data;
  };

  return data;
}

function packageJsonUtils() {
  const data = _interopRequireWildcard(require("../component/package-json-utils"));

  packageJsonUtils = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _path2() {
  const data = require("../../utils/path");

  _path2 = function () {
    return data;
  };

  return data;
}

function _moveSync() {
  const data = _interopRequireDefault(require("../../utils/fs/move-sync"));

  _moveSync = function () {
    return data;
  };

  return data;
}

function _removePath() {
  const data = _interopRequireDefault(require("../component/sources/remove-path"));

  _removePath = function () {
    return data;
  };

  return data;
}

function _bitIds() {
  const data = _interopRequireDefault(require("../../bit-id/bit-ids"));

  _bitIds = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function movePaths(_x, _x2) {
  return _movePaths.apply(this, arguments);
}

function _movePaths() {
  _movePaths = (0, _bluebird().coroutine)(function* (consumer, {
    from,
    to
  }) {
    const fromExists = _fsExtra().default.existsSync(from);

    const toExists = _fsExtra().default.existsSync(to);

    if (fromExists && toExists) {
      throw new (_generalError().default)(`unable to move because both paths from (${from}) and to (${to}) already exist`);
    }

    if (!fromExists && !toExists) throw new (_generalError().default)(`both paths from (${from}) and to (${to}) do not exist`);
    const fromRelative = consumer.getPathRelativeToConsumer(from);
    const toRelative = consumer.getPathRelativeToConsumer(to);
    const fromAbsolute = consumer.toAbsolutePath(fromRelative);
    const toAbsolute = consumer.toAbsolutePath(toRelative);
    const existingPath = fromExists ? fromAbsolute : toAbsolute;
    const changes = consumer.bitMap.updatePathLocation(fromRelative, toRelative, existingPath);

    if (fromExists && !toExists) {
      // user would like to physically move the file. Otherwise (!fromExists and toExists), user would like to only update bit.map
      (0, _moveSync().default)(fromAbsolute, toAbsolute);
    }

    if (!_ramda().default.isEmpty(changes)) {
      const componentsIds = changes.map(c => c.id);
      const {
        components
      } = yield consumer.loadComponents(_bitIds().default.fromArray(componentsIds));
      yield packageJsonUtils().addComponentsToRoot(consumer, components);
      const nodeModuleLinker = new (_links().NodeModuleLinker)(components, consumer, consumer.bitMap);
      yield nodeModuleLinker.link();
      yield (0, _links().reLinkDependents)(consumer, components);
    }

    return changes;
  });
  return _movePaths.apply(this, arguments);
}

function moveExistingComponent(consumer, component, oldPath, newPath) {
  if (_fsExtra().default.existsSync(newPath)) {
    throw new (_generalError().default)(`could not move the component ${component.id.toString()} from ${oldPath} to ${newPath} as the destination path already exists`);
  }

  const componentMap = consumer.bitMap.getComponent(component.id);
  const oldPathRelative = consumer.getPathRelativeToConsumer(oldPath);
  const newPathRelative = consumer.getPathRelativeToConsumer(newPath);
  componentMap.updateDirLocation(oldPathRelative, newPathRelative);
  consumer.bitMap.markAsChanged();

  if (componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED) {
    component.dataToPersist.files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const newRelative = file.relative.replace(oldPathRelative, newPathRelative);
      file.updatePaths({
        newRelative
      });
    });
  } else {
    component.dataToPersist.files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const newBase = file.base.replace(oldPathRelative, newPathRelative);
      file.updatePaths({
        newBase
      });
    });
  }

  component.dataToPersist.removePath(new (_removePath().default)(oldPathRelative));
  component.writtenPath = newPathRelative;
}
/**
 * since v14.8.0 Bit encourages users not to add individual files, only directories.
 * this function helps migrate a component that have files in different directories in the
 * workspace and moves them into one specified directory. this dir will be the rootDir.
 * since it only moves files, one prerequisite is to not have the same filename twice.
 */


function moveExistingComponentFilesToOneDir(_x3, _x4, _x5) {
  return _moveExistingComponentFilesToOneDir.apply(this, arguments);
}

function _moveExistingComponentFilesToOneDir() {
  _moveExistingComponentFilesToOneDir = (0, _bluebird().coroutine)(function* (consumer, id, to) {
    const componentMap = consumer.bitMap.getComponent(id, {
      ignoreVersion: true
    });

    if (componentMap.origin !== _constants().COMPONENT_ORIGINS.AUTHORED) {
      throw new (_generalError().default)(`bit move --component is relevant for authored components only. ${id.toString()} is not an authored component`);
    }

    const existingRootDir = componentMap.hasRootDir() ? componentMap.rootDir : componentMap.trackDir;

    if (existingRootDir) {
      throw new (_generalError().default)(`${id.toString()} has already one directory (${existingRootDir}) for all its files.
to change that directory, use bit move without --component flag`);
    }

    const toRelative = consumer.getPathRelativeToConsumer(to);
    const toAbsolute = consumer.toAbsolutePath(toRelative);

    if (_fsExtra().default.existsSync(toAbsolute)) {
      const stats = _fsExtra().default.statSync(toAbsolute);

      if (stats.isFile()) throw new (_generalError().default)(`unable to move files into "${to}", as this path is a file`);
      const isEmpty = (0, _utils().isDirEmptySync)(toAbsolute);
      if (!isEmpty) throw new (_generalError().default)(`unable to move files into "${to}", the directory is not empty`);
    }

    const fileNames = componentMap.files.map(f => f.name);
    const sameName = fileNames.find(name => fileNames.filter(n => n === name).length > 1);

    if (sameName) {
      throw new (_generalError().default)(`unable to move the files because there are more than one file with the name ${sameName}`);
    }

    const changes = componentMap.files.map(file => {
      const fromAbsolute = consumer.toAbsolutePath(file.relativePath);
      (0, _moveSync().default)(fromAbsolute, _path().default.join(toAbsolute, file.name));
      return {
        from: file.relativePath,
        to: (0, _path2().pathJoinLinux)(toRelative, file.name)
      };
    });
    componentMap.addRootDirToDistributedFiles(to);
    consumer.bitMap.markAsChanged();
    return [{
      id,
      changes
    }];
  });
  return _moveExistingComponentFilesToOneDir.apply(this, arguments);
}