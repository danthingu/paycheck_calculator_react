"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExtensionDataList = exports.ExtensionDataEntry = void 0;

function _ramda() {
  const data = _interopRequireWildcard(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _extensionConfigList() {
  const data = require("./extension-config-list");

  _extensionConfigList = function () {
    return data;
  };

  return data;
}

function _artifact() {
  const data = require("../component/sources/artifact");

  _artifact = function () {
    return data;
  };

  return data;
}

/* eslint-disable max-classes-per-file */
class ExtensionDataEntry {
  constructor(legacyId, extensionId, name, config = {}, data = {}, artifacts = []) {
    this.legacyId = legacyId;
    this.extensionId = extensionId;
    this.name = name;
    this.config = config;
    this.data = data;
    this.artifacts = artifacts;
  }

  get id() {
    if (this.extensionId) return this.extensionId;
    if (this.name) return this.name;
    if (this.legacyId) return this.legacyId;
    return '';
  }

  get stringId() {
    var _this$extensionId;

    if (this.extensionId) return (_this$extensionId = this.extensionId) === null || _this$extensionId === void 0 ? void 0 : _this$extensionId.toString();
    if (this.name) return this.name;
    if (this.legacyId) return this.legacyId;
    return '';
  }

  get isLegacy() {
    var _this$config;

    if ((_this$config = this.config) === null || _this$config === void 0 ? void 0 : _this$config.__legacy) return true;
    return false;
  }

  clone() {
    var _this$extensionId2;

    const clonedArtifacts = this.artifacts.map(artifact => {
      return artifact instanceof _artifact().Artifact ? artifact.clone() : artifact;
    });
    return new ExtensionDataEntry(this.legacyId, (_this$extensionId2 = this.extensionId) === null || _this$extensionId2 === void 0 ? void 0 : _this$extensionId2.clone(), this.name, _ramda().default.clone(this.config), _ramda().default.clone(this.data), clonedArtifacts);
  }

}

exports.ExtensionDataEntry = ExtensionDataEntry;

class ExtensionDataList extends Array {
  get ids() {
    const list = this.map(entry => entry.stringId);
    return list;
  }
  /**
   * returns only new 3rd party extension ids, not core, nor legacy.
   */


  get extensionsBitIds() {
    const bitIds = this.filter(entry => entry.extensionId).map(entry => entry.extensionId);
    return _bitId().BitIds.fromArray(bitIds);
  }

  findExtension(extensionId, ignoreVersion = false) {
    return (0, _ramda().find)(extEntry => {
      var _extEntry$extensionId;

      if (!ignoreVersion) {
        return extEntry.stringId === extensionId;
      }

      return ((_extEntry$extensionId = extEntry.extensionId) === null || _extEntry$extensionId === void 0 ? void 0 : _extEntry$extensionId.toStringWithoutVersion()) === extensionId;
    }, this);
  }

  findCoreExtension(extensionId) {
    return (0, _ramda().find)(extEntry => {
      return extEntry.name === extensionId;
    }, this);
  }

  remove(id) {
    return ExtensionDataList.fromArray(this.filter(entry => {
      return entry.stringId !== id.toString() && entry.stringId !== id.toStringWithoutVersion();
    }));
  }

  toObject() {
    const res = {};
    this.forEach(entry => res[entry.stringId] = entry.config);
    return res;
  }

  toExtensionConfigList() {
    const arr = this.map(entry => {
      return {
        id: entry.stringId,
        config: entry.config
      };
    });
    return _extensionConfigList().ExtensionConfigList.fromArray(arr);
  }

  clone() {
    const extensionDataEntries = this.map(extensionData => extensionData.clone());
    return new ExtensionDataList(...extensionDataEntries);
  }

  _filterLegacy() {
    return ExtensionDataList.fromArray(this.filter(ext => !ext.isLegacy));
  }

  static fromObject(obj, consumer) {
    const arr = [];
    (0, _ramda().forEachObjIndexed)((config, id) => {
      const parsedId = consumer.getParsedIdIfExist(id);
      let entry;

      if (parsedId) {
        entry = new ExtensionDataEntry(undefined, parsedId, undefined, config, undefined);
      } else {
        entry = new ExtensionDataEntry(undefined, undefined, id, config, undefined);
      }

      arr.push(entry);
    }, obj);
    return this.fromArray(arr);
  }

  static fromArray(entries) {
    if (!entries || !entries.length) {
      return new ExtensionDataList();
    }

    return new ExtensionDataList(...entries);
  }

}

exports.ExtensionDataList = ExtensionDataList;