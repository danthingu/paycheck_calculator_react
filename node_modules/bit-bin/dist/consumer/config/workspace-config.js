"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _abstractConfig() {
  const data = _interopRequireDefault(require("./abstract-config"));

  _abstractConfig = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("./exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _filterObject() {
  const data = _interopRequireDefault(require("../../utils/filter-object"));

  _filterObject = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _invalidConfigPropPath() {
  const data = _interopRequireDefault(require("./exceptions/invalid-config-prop-path"));

  _invalidConfigPropPath = function () {
    return data;
  };

  return data;
}

function _consumerOverrides() {
  const data = _interopRequireDefault(require("./consumer-overrides"));

  _consumerOverrides = function () {
    return data;
  };

  return data;
}

function _invalidPackageManager() {
  const data = _interopRequireDefault(require("./exceptions/invalid-package-manager"));

  _invalidPackageManager = function () {
    return data;
  };

  return data;
}

const DEFAULT_USE_WORKSPACES = false;
const DEFAULT_MANAGE_WORKSPACES = true;

class WorkspaceConfig extends _abstractConfig().default {
  // path where to store build artifacts
  // path to remove while storing build artifacts. If, for example the code is in 'src' directory, and the component
  // is-string is in src/components/is-string, the dists files will be in dists/component/is-string (without the 'src')
  // save hub dependencies as bit components rather than npm packages
  // package manager client to use
  // package manager process options
  // Enables integration with Yarn Workspaces
  // manage workspaces with yarn
  // workspace package.json if exists (parsed)
  // default remote scope to export to
  static registerOnWorkspaceConfigIsExist(func) {
    this.workspaceConfigIsExistRegistry = func;
  }

  static registerOnWorkspaceConfigLoading(func) {
    this.workspaceConfigLoadingRegistry = func;
  }

  static registerOnWorkspaceConfigEnsuring(func) {
    this.workspaceConfigEnsuringRegistry = func;
  }

  constructor({
    compiler,
    tester,
    saveDependenciesAsComponents = _constants().DEFAULT_SAVE_DEPENDENCIES_AS_COMPONENTS,
    lang,
    distTarget,
    distEntry,
    componentsDefaultDirectory = _constants().DEFAULT_COMPONENTS_DIR_PATH,
    dependenciesDirectory = _constants().DEFAULT_DEPENDENCIES_DIR_PATH,
    bindingPrefix,
    extensions,
    packageManager = _constants().DEFAULT_PACKAGE_MANAGER,
    packageManagerArgs,
    packageManagerProcessOptions,
    useWorkspaces = DEFAULT_USE_WORKSPACES,
    manageWorkspaces = DEFAULT_MANAGE_WORKSPACES,
    resolveModules,
    defaultScope,
    overrides = _consumerOverrides().default.load()
  }) {
    super({
      compiler,
      tester,
      lang,
      bindingPrefix,
      extensions
    });
    (0, _defineProperty2().default)(this, "distTarget", void 0);
    (0, _defineProperty2().default)(this, "distEntry", void 0);
    (0, _defineProperty2().default)(this, "componentsDefaultDirectory", void 0);
    (0, _defineProperty2().default)(this, "dependenciesDirectory", void 0);
    (0, _defineProperty2().default)(this, "saveDependenciesAsComponents", void 0);
    (0, _defineProperty2().default)(this, "packageManager", void 0);
    (0, _defineProperty2().default)(this, "packageManagerArgs", void 0);
    (0, _defineProperty2().default)(this, "packageManagerProcessOptions", void 0);
    (0, _defineProperty2().default)(this, "useWorkspaces", void 0);
    (0, _defineProperty2().default)(this, "manageWorkspaces", void 0);
    (0, _defineProperty2().default)(this, "resolveModules", void 0);
    (0, _defineProperty2().default)(this, "overrides", void 0);
    (0, _defineProperty2().default)(this, "packageJsonObject", void 0);
    (0, _defineProperty2().default)(this, "defaultScope", void 0);

    if (packageManager !== 'npm' && packageManager !== 'yarn') {
      throw new (_invalidPackageManager().default)(packageManager);
    }

    this.distTarget = distTarget;
    this.distEntry = distEntry;
    this.componentsDefaultDirectory = componentsDefaultDirectory; // Make sure we have the component name in the path. otherwise components will be imported to the same dir.

    if (!componentsDefaultDirectory.includes('{name}')) {
      this.componentsDefaultDirectory = `${this.componentsDefaultDirectory}/{name}`;
    }

    this.dependenciesDirectory = dependenciesDirectory;
    this.saveDependenciesAsComponents = saveDependenciesAsComponents;
    this.packageManager = packageManager;
    this.packageManagerArgs = packageManagerArgs;
    this.packageManagerProcessOptions = packageManagerProcessOptions;
    this.useWorkspaces = useWorkspaces;
    this.manageWorkspaces = manageWorkspaces;
    this.resolveModules = resolveModules;
    this.defaultScope = defaultScope;
    this.overrides = overrides;
  }

  toPlainObject() {
    const superObject = super.toPlainObject();

    let consumerObject = _ramda().default.merge(superObject, {
      componentsDefaultDirectory: this.componentsDefaultDirectory,
      dependenciesDirectory: this.dependenciesDirectory,
      saveDependenciesAsComponents: this.saveDependenciesAsComponents,
      packageManager: this.packageManager,
      packageManagerArgs: this.packageManagerArgs,
      packageManagerProcessOptions: this.packageManagerProcessOptions,
      useWorkspaces: this.useWorkspaces,
      manageWorkspaces: this.manageWorkspaces,
      resolveModules: this.resolveModules,
      defaultScope: this.defaultScope,
      overrides: this.overrides.overrides
    });

    if (this.distEntry || this.distTarget) {
      const dist = {}; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      if (this.distEntry) dist.entry = this.distEntry; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      if (this.distTarget) dist.target = this.distTarget;
      consumerObject = _ramda().default.merge(consumerObject, {
        dist
      });
    }

    const isPropDefault = (val, key) => {
      if (key === 'dependenciesDirectory') return val !== _constants().DEFAULT_DEPENDENCIES_DIR_PATH;
      if (key === 'useWorkspaces') return val !== DEFAULT_USE_WORKSPACES;
      if (key === 'manageWorkspaces') return val !== DEFAULT_MANAGE_WORKSPACES;
      if (key === 'saveDependenciesAsComponents') return val !== _constants().DEFAULT_SAVE_DEPENDENCIES_AS_COMPONENTS;
      if (key === 'resolveModules') return !_ramda().default.isEmpty(val);
      if (key === 'defaultScope') return Boolean(val);
      if (key === 'overrides') return !_ramda().default.isEmpty(val);
      return true;
    };

    return (0, _filterObject().default)(consumerObject, isPropDefault);
  }

  static create(workspaceConfigProps) {
    return new WorkspaceConfig(workspaceConfigProps);
  }

  static ensure(dirPath, standAlone = false, workspaceConfigProps = {}) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      const ensureFunc = _this.workspaceConfigEnsuringRegistry;
      return ensureFunc(dirPath, standAlone, workspaceConfigProps);
    })();
  }

  static _ensure(dirPath, standAlone, workspaceConfigProps = {}) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      try {
        const workspaceConfig = yield _this2.load(dirPath);
        return workspaceConfig;
      } catch (err) {
        if (err instanceof _exceptions().BitConfigNotFound || err instanceof _exceptions().InvalidBitJson) {
          const consumerBitJson = _this2.create(workspaceConfigProps);

          const packageJsonExists = yield _abstractConfig().default.pathHasPackageJson(dirPath);

          if (packageJsonExists && !standAlone) {
            consumerBitJson.writeToPackageJson = true;
          } else {
            consumerBitJson.writeToBitJson = true;
          }

          return consumerBitJson;
        }

        throw err;
      }
    })();
  }

  static reset(dirPath, resetHard) {
    return (0, _bluebird().coroutine)(function* () {
      const deleteBitJsonFile = /*#__PURE__*/function () {
        var _ref = (0, _bluebird().coroutine)(function* () {
          const bitJsonPath = _abstractConfig().default.composeBitJsonPath(dirPath);

          _logger().default.info(`deleting the workspace configuration file at ${bitJsonPath}`);

          yield _fsExtra().default.remove(bitJsonPath);
        });

        return function deleteBitJsonFile() {
          return _ref.apply(this, arguments);
        };
      }();

      if (resetHard) {
        yield deleteBitJsonFile();
      }

      yield WorkspaceConfig.ensure(dirPath);
    })();
  }

  static fromPlainObject(object) {
    this.validate(object);
    const {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      env,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      lang,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      componentsDefaultDirectory,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      dependenciesDirectory,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      dist,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      bindingPrefix,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      extensions,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      saveDependenciesAsComponents,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageManager,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageManagerArgs,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageManagerProcessOptions,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      useWorkspaces,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      manageWorkspaces,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      resolveModules,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      defaultScope,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      overrides
    } = object;
    return new WorkspaceConfig({
      compiler: _ramda().default.propOr(undefined, 'compiler', env),
      tester: _ramda().default.propOr(undefined, 'tester', env),
      lang,
      bindingPrefix,
      extensions,
      saveDependenciesAsComponents,
      componentsDefaultDirectory,
      dependenciesDirectory,
      packageManager,
      packageManagerArgs,
      packageManagerProcessOptions,
      useWorkspaces,
      manageWorkspaces,
      resolveModules,
      distTarget: _ramda().default.propOr(undefined, 'target', dist),
      distEntry: _ramda().default.propOr(undefined, 'entry', dist),
      defaultScope,
      overrides: _consumerOverrides().default.load(overrides)
    });
  }

  static load(dirPath) {
    var _this3 = this;

    return (0, _bluebird().coroutine)(function* () {
      const res = yield _this3._loadIfExist(dirPath);

      if (!res) {
        throw new (_exceptions().BitConfigNotFound)();
      }

      return res;
    })();
  }

  static loadIfExist(dirPath) {
    var _this4 = this;

    return (0, _bluebird().coroutine)(function* () {
      const loadFunc = _this4.workspaceConfigLoadingRegistry;

      if (loadFunc && typeof loadFunc === 'function') {
        return loadFunc(dirPath);
      }

      return undefined;
    })();
  }

  static isExist(dirPath) {
    var _this5 = this;

    return (0, _bluebird().coroutine)(function* () {
      const isExistFunc = _this5.workspaceConfigIsExistRegistry;

      if (isExistFunc && typeof isExistFunc === 'function') {
        return isExistFunc(dirPath);
      }

      return undefined;
    })();
  }

  static _isExist(dirPath) {
    var _this6 = this;

    return (0, _bluebird().coroutine)(function* () {
      const bitJsonPath = _abstractConfig().default.composeBitJsonPath(dirPath);

      const packageJsonPath = _abstractConfig().default.composePackageJsonPath(dirPath);

      const bitJsonExist = yield _fsExtra().default.pathExists(bitJsonPath);

      if (bitJsonExist) {
        return true;
      }

      const packageJson = yield _this6.loadPackageJson(packageJsonPath);

      if (packageJson && packageJson.bit) {
        return true;
      }

      return false;
    })();
  }

  static _loadIfExist(dirPath) {
    var _this7 = this;

    return (0, _bluebird().coroutine)(function* () {
      const bitJsonPath = _abstractConfig().default.composeBitJsonPath(dirPath);

      const packageJsonPath = _abstractConfig().default.composePackageJsonPath(dirPath);

      const [bitJsonFile, packageJsonFile] = yield Promise.all([_this7.loadBitJson(bitJsonPath), // $FlowFixMe
      _this7.loadPackageJson(packageJsonPath)]);
      const bitJsonConfig = bitJsonFile || {}; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const packageJsonHasConfig = packageJsonFile && packageJsonFile.bit; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const packageJsonConfig = packageJsonHasConfig ? packageJsonFile.bit : {};
      if (_ramda().default.isEmpty(bitJsonConfig) && _ramda().default.isEmpty(packageJsonConfig)) return undefined; // in case of conflicts, bit.json wins package.json

      const config = Object.assign(packageJsonConfig, bitJsonConfig);

      const workspaceConfig = _this7.fromPlainObject(config);

      workspaceConfig.path = bitJsonPath;
      workspaceConfig.writeToBitJson = Boolean(bitJsonFile);
      workspaceConfig.writeToPackageJson = packageJsonHasConfig;
      workspaceConfig.packageJsonObject = packageJsonFile;
      return workspaceConfig;
    })();
  }

  static loadBitJson(bitJsonPath) {
    return (0, _bluebird().coroutine)(function* () {
      try {
        const file = yield _abstractConfig().default.loadJsonFileIfExist(bitJsonPath);
        return file;
      } catch (e) {
        throw new (_exceptions().InvalidBitJson)(bitJsonPath);
      }
    })();
  }

  static loadPackageJson(packageJsonPath) {
    return (0, _bluebird().coroutine)(function* () {
      try {
        const file = yield _abstractConfig().default.loadJsonFileIfExist(packageJsonPath);
        return file;
      } catch (e) {
        throw new (_exceptions().InvalidPackageJson)(packageJsonPath);
      }
    })();
  }

  static validate(object) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const {
      componentsDefaultDirectory,
      dependenciesDirectory
    } = object;
    const pathsToValidate = {
      componentsDefaultDirectory,
      dependenciesDirectory
    };
    Object.keys(pathsToValidate).forEach(field => throwForInvalidPath(field, pathsToValidate[field]));

    function throwForInvalidPath(fieldName, pathToValidate) {
      if (pathToValidate && !(0, _utils().isValidPath)(pathToValidate)) {
        throw new (_invalidConfigPropPath().default)(fieldName, pathToValidate);
      }
    } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    _consumerOverrides().default.validate(object.overrides);
  }

}

exports.default = WorkspaceConfig;
(0, _defineProperty2().default)(WorkspaceConfig, "workspaceConfigIsExistRegistry", void 0);
(0, _defineProperty2().default)(WorkspaceConfig, "workspaceConfigLoadingRegistry", void 0);
(0, _defineProperty2().default)(WorkspaceConfig, "workspaceConfigEnsuringRegistry", void 0);