import ComponentMap from '../../../bit-map/component-map';
import { BitId } from '../../../../bit-id';
import Component from '../../../component/consumer-component';
import Consumer from '../../../../consumer/consumer';
import { ImportSpecifier, FileObject, Tree } from '../files-dependency-builder/types/dependency-tree-type';
import { PathLinux, PathOsBased, PathLinuxRelative } from '../../../../utils/path';
import { Dependency } from '..';
import { RelativePath } from '../dependency';
import OverridesDependencies from './overrides-dependencies';
export declare type AllDependencies = {
    dependencies: Dependency[];
    devDependencies: Dependency[];
};
export declare type AllPackagesDependencies = {
    packageDependencies: Record<string, any> | null | undefined;
    devPackageDependencies: Record<string, any> | null | undefined;
    compilerPackageDependencies: Record<string, any> | null | undefined;
    testerPackageDependencies: Record<string, any> | null | undefined;
    peerPackageDependencies: Record<string, any> | null | undefined;
};
export declare type FileType = {
    isTestFile: boolean;
};
interface UntrackedFileEntry {
    relativePath: string;
    existing: boolean;
}
export interface UntrackedFileDependencyEntry {
    nested: boolean;
    untrackedFiles: Array<UntrackedFileEntry>;
}
export declare type RelativeComponentsAuthoredEntry = {
    importSource: string;
    componentId: BitId;
    importSpecifiers: ImportSpecifier[] | undefined;
};
declare type UntrackedDependenciesIssues = Record<string, UntrackedFileDependencyEntry>;
declare type RelativeComponentsAuthoredIssues = {
    [fileName: string]: RelativeComponentsAuthoredEntry[];
};
export declare type Issues = {
    missingPackagesDependenciesOnFs: {};
    missingPackagesDependenciesFromOverrides: string[];
    missingComponents: {};
    untrackedDependencies: UntrackedDependenciesIssues;
    missingDependenciesOnFs: {};
    missingLinks: {};
    missingCustomModuleResolutionLinks: {};
    relativeComponents: {};
    relativeComponentsAuthored: RelativeComponentsAuthoredIssues;
    parseErrors: {};
    resolveErrors: {};
    missingBits: {};
};
export default class DependencyResolver {
    component: Component;
    consumer: Consumer;
    componentId: BitId;
    componentMap: ComponentMap;
    componentFromModel: Component;
    extensionsAddedConfig: Record<string, any>;
    consumerPath: PathOsBased;
    tree: Tree;
    allDependencies: AllDependencies;
    allPackagesDependencies: AllPackagesDependencies;
    issues: Issues;
    processedFiles: string[];
    compilerFiles: PathLinux[];
    testerFiles: PathLinux[];
    overridesDependencies: OverridesDependencies;
    constructor(component: Component, consumer: Consumer, componentId: BitId);
    setTree(tree: Tree): void;
    loadDependenciesForComponent(bitDir: string, cacheResolvedDependencies: Record<string, any>, cacheProjectAst: Record<string, any> | undefined): Promise<Component>;
    populateDependencies(files: string[], testsFiles: string[]): void;
    removeIgnoredPackagesByOverrides(): void;
    throwForNonExistFile(file: string): void;
    throwForIncorrectRootDir(): void;
    manuallyAddDependencies(): void;
    applyOverridesOnEnvPackages(): void;
    traverseTreeForComponentId(depFile: PathLinux): BitId | undefined;
    getComponentIdByDepFile(depFile: PathLinux): {
        componentId: BitId | null | undefined;
        depFileRelative: PathLinux;
        destination: string | null | undefined;
    };
    _getComponentIdFromCustomResolveToPackageWithDist(depFile: string): BitId | null | undefined;
    getDependencyPathsFromModel(componentId: BitId, depFile: PathLinux, rootDir: PathLinux): {
        componentId: BitId;
        destination: string;
        depFileRelative: string;
    };
    processDepFiles(originFile: PathLinuxRelative, fileType: FileType, nested?: boolean): void;
    processOneDepFile(originFile: PathLinuxRelative, depFile: string, importSpecifiers: ImportSpecifier[] | undefined, linkFile: string | undefined, fileType: FileType, depFileObject: FileObject, nested?: boolean): boolean;
    processLinkFile(originFile: PathLinuxRelative, linkFile: FileObject, fileType: FileType): void;
    processBits(originFile: PathLinuxRelative, fileType: FileType): void;
    processPackages(originFile: PathLinuxRelative, fileType: FileType): void;
    processMissing(originFile: PathLinuxRelative, fileType: FileType): void;
    _addToMissingComponentsIfNeeded(missingComponents: string[], originFile: string, fileType: FileType): void;
    processErrors(originFile: PathLinuxRelative): void;
    processUnidentifiedPackages(originFile: PathLinuxRelative, fileType: FileType): void;
    private _pushToDependenciesIfNotExist;
    pushToDependenciesArray(currentComponentsDeps: Dependency, fileType: FileType): void;
    removeDevAndEnvDepsIfTheyAlsoRegulars(): void;
    findOriginallyCustomModuleResolvedDependencies(packages: string[]): Record<string, any> | null | undefined;
    combineIssues(): void;
    removeEmptyIssues(): void;
    getExistingDependency(dependencies: Dependency[], id: BitId): Dependency | null | undefined;
    getExistingDepRelativePaths(dependency: Dependency, relativePath: RelativePath): RelativePath | null | undefined;
    getDiffSpecifiers(originSpecifiers: ImportSpecifier[], targetSpecifiers: ImportSpecifier[]): any;
    populatePeerPackageDependencies(): void;
    _getPackageJson(): Record<string, any> | undefined;
    _addTypesPackagesForTypeScript(packages: Record<string, any>, originFile: PathLinuxRelative): void;
    _pkgFieldMapping(field: string): "packageDependencies" | "devPackageDependencies" | "peerPackageDependencies";
    _pushToUntrackDependenciesIssues(originFile: any, depFileRelative: any, nested?: boolean): void;
    _pushToRelativeComponentsIssues(originFile: any, componentId: any): void;
    _pushToRelativeComponentsAuthoredIssues(originFile: any, componentId: any, importSource: string, importSpecifiers: ImportSpecifier[] | undefined): void;
    _pushToMissingBitsIssues(originFile: PathLinuxRelative, componentId: BitId): void;
    _pushToMissingDependenciesOnFs(originFile: PathLinuxRelative, missingFiles: string[]): void;
    _pushToMissingPackagesDependenciesIssues(originFile: PathLinuxRelative, missingPackages: string[]): void;
    _pushToMissingCustomModuleIssues(originFile: PathLinuxRelative, componentId: BitId): void;
    _pushToMissingLinksIssues(originFile: PathLinuxRelative, componentId: BitId): void;
    _pushToMissingComponentsIssues(originFile: PathLinuxRelative, componentId: BitId): void;
}
export {};
