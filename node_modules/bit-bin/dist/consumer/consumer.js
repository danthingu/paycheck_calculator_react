"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _consumerLocator() {
  const data = require("./consumer-locator");

  _consumerLocator = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("./exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = _interopRequireDefault(require("./component"));

  _component = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _scope() {
  const data = require("../scope");

  _scope = function () {
    return data;
  };

  return data;
}

function _consumerMigratorManifest() {
  const data = _interopRequireDefault(require("./migrations/consumer-migrator-manifest"));

  _consumerMigratorManifest = function () {
    return data;
  };

  return data;
}

function _consumerMigrator() {
  const data = _interopRequireDefault(require("./migrations/consumer-migrator"));

  _consumerMigrator = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _loaderMessages() {
  const data = require("../cli/loader/loader-messages");

  _loaderMessages = function () {
    return data;
  };

  return data;
}

function _bitMap() {
  const data = _interopRequireDefault(require("./bit-map/bit-map"));

  _bitMap = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _dirStructure() {
  const data = _interopRequireDefault(require("./dir-structure/dir-structure"));

  _dirStructure = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _models() {
  const data = require("../scope/models");

  _models = function () {
    return data;
  };

  return data;
}

function packageJsonUtils() {
  const data = _interopRequireWildcard(require("./component/package-json-utils"));

  packageJsonUtils = function () {
    return data;
  };

  return data;
}

function _dependencies() {
  const data = require("./component/dependencies");

  _dependencies = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _tagModelComponent() {
  const data = _interopRequireDefault(require("../scope/component-ops/tag-model-component"));

  _tagModelComponent = function () {
    return data;
  };

  return data;
}

function _autoTag() {
  const data = require("../scope/component-ops/auto-tag");

  _autoTag = function () {
    return data;
  };

  return data;
}

function _exceptions2() {
  const data = require("../scope/exceptions");

  _exceptions2 = function () {
    return data;
  };

  return data;
}

function _manipulateDir() {
  const data = require("./component-ops/manipulate-dir");

  _manipulateDir = function () {
    return data;
  };

  return data;
}

function _componentLoader() {
  const data = _interopRequireDefault(require("./component/component-loader"));

  _componentLoader = function () {
    return data;
  };

  return data;
}

function _scopeRemotes() {
  const data = require("../scope/scope-remotes");

  _scopeRemotes = function () {
    return data;
  };

  return data;
}

function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("../scope/component-ops/scope-components-importer"));

  _scopeComponentsImporter = function () {
    return data;
  };

  return data;
}

function _installExtensions() {
  const data = _interopRequireDefault(require("../scope/extensions/install-extensions"));

  _installExtensions = function () {
    return data;
  };

  return data;
}

function _composeComponentPath() {
  const data = require("../utils/bit/compose-component-path");

  _composeComponentPath = function () {
    return data;
  };

  return data;
}

function _componentNodeModulesPath() {
  const data = _interopRequireDefault(require("../utils/bit/component-node-modules-path"));

  _componentNodeModulesPath = function () {
    return data;
  };

  return data;
}

function _envFactory() {
  const data = _interopRequireDefault(require("../legacy-extensions/env-factory"));

  _envFactory = function () {
    return data;
  };

  return data;
}

function _componentsPendingImport() {
  const data = _interopRequireDefault(require("./component-ops/exceptions/components-pending-import"));

  _componentsPendingImport = function () {
    return data;
  };

  return data;
}

function _packageNameToComponentId() {
  const data = require("../utils/bit/package-name-to-component-id");

  _packageNameToComponentId = function () {
    return data;
  };

  return data;
}

function _packageJsonFile() {
  const data = _interopRequireDefault(require("./component/package-json-file"));

  _packageJsonFile = function () {
    return data;
  };

  return data;
}

function _failedLoadForTag() {
  const data = require("./component/exceptions/failed-load-for-tag");

  _failedLoadForTag = function () {
    return data;
  };

  return data;
}

function _workspaceConfig() {
  const data = _interopRequireDefault(require("./config/workspace-config"));

  _workspaceConfig = function () {
    return data;
  };

  return data;
}

function _componentStatusLoader() {
  const data = require("./component-ops/component-status-loader");

  _componentStatusLoader = function () {
    return data;
  };

  return data;
}

/**
 * @todo: change the class name to Workspace
 */
class Consumer {
  // Mark that the consumer instance is of isolated env and not real
  // list of git hooks added during init process
  // list of git hooks already exists during init process
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // cache loaded components
  // args entered by the user in the command line after '--'
  constructor({
    projectPath,
    config,
    scope,
    created = false,
    isolated = false,
    bitMap,
    addedGitHooks,
    existingGitHooks
  }) {
    (0, _defineProperty2().default)(this, "projectPath", void 0);
    (0, _defineProperty2().default)(this, "created", void 0);
    (0, _defineProperty2().default)(this, "config", void 0);
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "bitMap", void 0);
    (0, _defineProperty2().default)(this, "isolated", false);
    (0, _defineProperty2().default)(this, "addedGitHooks", void 0);
    (0, _defineProperty2().default)(this, "existingGitHooks", void 0);
    (0, _defineProperty2().default)(this, "_dirStructure", void 0);
    (0, _defineProperty2().default)(this, "_componentsStatusCache", {});
    (0, _defineProperty2().default)(this, "packageManagerArgs", []);
    (0, _defineProperty2().default)(this, "componentLoader", void 0);
    (0, _defineProperty2().default)(this, "componentStatusLoader", void 0);
    (0, _defineProperty2().default)(this, "packageJson", void 0);
    this.projectPath = projectPath;
    this.config = config;
    this.created = created;
    this.isolated = isolated;
    this.scope = scope;
    this.bitMap = bitMap || _bitMap().default.load(projectPath);
    this.addedGitHooks = addedGitHooks;
    this.existingGitHooks = existingGitHooks;
    this.componentLoader = _componentLoader().default.getInstance(this);
    this.componentStatusLoader = new (_componentStatusLoader().ComponentStatusLoader)(this);
    this.packageJson = _packageJsonFile().default.loadSync(projectPath);
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  get compiler() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return this.getEnv(_constants().COMPILER_ENV_TYPE);
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  get tester() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return this.getEnv(_constants().TESTER_ENV_TYPE);
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  get dirStructure() {
    if (!this._dirStructure) {
      this._dirStructure = new (_dirStructure().default)(this.config.componentsDefaultDirectory, this.config._dependenciesDirectory);
    }

    return this._dirStructure;
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  get bitmapIds() {
    return this.bitMap.getAllBitIds();
  }

  getEnv(envType, context) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      const props = _this._getEnvProps(envType, context);

      if (!props) return undefined;
      return (0, _envFactory().default)(envType, props);
    })();
  }

  getTmpFolder(fullPath = false) {
    if (!fullPath) {
      return _constants().BIT_WORKSPACE_TMP_DIRNAME;
    }

    return path().join(this.getPath(), _constants().BIT_WORKSPACE_TMP_DIRNAME);
  }

  cleanTmpFolder() {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      const tmpPath = _this2.getTmpFolder(true);

      const exists = yield _fsExtra().default.pathExists(tmpPath);

      if (exists) {
        _logger().default.info(`consumer.cleanTmpFolder, deleting ${tmpPath}`);

        return _fsExtra().default.remove(tmpPath);
      }

      return undefined;
    })();
  }
  /**
   * Running migration process for consumer to update the stores (.bit.map.json) to the current version
   *
   * @param {any} verbose - print debug logs
   * @returns {Object} - wether the process run and wether it successeded
   * @memberof Consumer
   */
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  migrate(verbose) {
    var _this3 = this;

    return (0, _bluebird().coroutine)(function* () {
      // Check version of stores (bitmap / bitjson) to check if we need to run migrate
      // If migration is needed add loader - loader.start(BEFORE_MIGRATION);
      // bitmap migrate
      if (verbose) console.log('running migration process for consumer'); // eslint-disable-line
      // We start to use this process after version 0.10.9, so we assume the scope is in the last production version

      const bitmapVersion = _this3.bitMap.version || '0.10.9';

      if (_semver().default.gte(bitmapVersion, _constants().BIT_VERSION)) {
        _logger().default.silly('bit.map version is up to date');

        return {
          run: false
        };
      }

      _loader().default.start(_loaderMessages().BEFORE_MIGRATION);

      _logger().default.debugAndAddBreadCrumb('consumer.migrate', `start consumer migration. bitmapVersion version ${bitmapVersion}, bit version ${_constants().BIT_VERSION}`);

      const result = yield (0, _consumerMigrator().default)(bitmapVersion, _consumerMigratorManifest().default, _this3.bitMap, verbose);
      result.bitMap.version = _constants().BIT_VERSION; // mark the bitmap as changed to make sure it persist to FS

      result.bitMap.markAsChanged(); // Update the version of the bitmap instance of the consumer (to prevent duplicate migration)

      _this3.bitMap.version = result.bitMap.version;
      yield result.bitMap.write();

      _loader().default.stop();

      return {
        run: true,
        success: true
      };
    })();
  }

  write() {
    var _this4 = this;

    return (0, _bluebird().coroutine)(function* () {
      yield Promise.all([_this4.config.write({
        workspaceDir: _this4.projectPath
      }), _this4.scope.ensureDir()]);

      _this4.bitMap.markAsChanged();

      yield _this4.bitMap.write();
      return _this4;
    })();
  }

  getPath() {
    return this.projectPath;
  }

  toAbsolutePath(pathStr) {
    if (path().isAbsolute(pathStr)) throw new Error(`toAbsolutePath expects relative path, got ${pathStr}`);
    return path().join(this.projectPath, pathStr);
  }

  getPathRelativeToConsumer(pathToCheck) {
    const absolutePath = path().resolve(pathToCheck); // if pathToCheck was absolute, it returns it back

    return path().relative(this.getPath(), absolutePath);
  }

  getParsedId(id) {
    // @ts-ignore (we know it will never be undefined since it pass throw=true)
    const bitId = this.bitMap.getExistingBitId(id, true);

    const version = _bitId().BitId.getVersionOnlyFromString(id);

    return bitId.changeVersion(version || _constants().LATEST);
  }

  getParsedIdIfExist(id) {
    const bitId = this.bitMap.getExistingBitId(id, false);
    if (!bitId) return undefined;

    const version = _bitId().BitId.getVersionOnlyFromString(id);

    return bitId.changeVersion(version);
  }
  /**
   * throws a ComponentNotFound exception if not found in the model
   */


  loadComponentFromModel(id) {
    var _this5 = this;

    return (0, _bluebird().coroutine)(function* () {
      if (!id.version) throw new TypeError('consumer.loadComponentFromModel, version is missing from the id');
      const modelComponent = yield _this5.scope.getModelComponent(id);
      const componentVersion = modelComponent.toComponentVersion(id.version);
      const manipulateDirData = yield (0, _manipulateDir().getManipulateDirForExistingComponents)(_this5, componentVersion);
      return modelComponent.toConsumerComponent(id.version, _this5.scope.name, _this5.scope.objects, manipulateDirData);
    })();
  }
  /**
   * return a component only when it's stored locally.
   * don't go to any remote server and don't throw an exception if the component is not there.
   */


  loadComponentFromModelIfExist(id) {
    var _this6 = this;

    return (0, _bluebird().coroutine)(function* () {
      if (!id.version) return undefined;
      return _this6.loadComponentFromModel(id).catch(err => {
        if (err instanceof _exceptions2().ComponentNotFound) return undefined;
        throw err;
      });
    })();
  }

  loadAllVersionsOfComponentFromModel(id) {
    var _this7 = this;

    return (0, _bluebird().coroutine)(function* () {
      const modelComponent = yield _this7.scope.getModelComponent(id);
      const componentsP = modelComponent.listVersions().map( /*#__PURE__*/function () {
        var _ref = (0, _bluebird().coroutine)(function* (versionNum) {
          const componentVersion = modelComponent.toComponentVersion(versionNum);
          const manipulateDirData = yield (0, _manipulateDir().getManipulateDirForExistingComponents)(_this7, componentVersion);
          return modelComponent.toConsumerComponent(versionNum, _this7.scope.name, _this7.scope.objects, manipulateDirData);
        });

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());
      return Promise.all(componentsP);
    })();
  }

  loadComponentWithDependenciesFromModel(id, throwIfNotExist = true) {
    var _this8 = this;

    return (0, _bluebird().coroutine)(function* () {
      const scopeComponentsImporter = _scopeComponentsImporter().default.getInstance(_this8.scope);

      const getModelComponent = /*#__PURE__*/function () {
        var _ref2 = (0, _bluebird().coroutine)(function* () {
          if (throwIfNotExist) return _this8.scope.getModelComponent(id);
          const modelComponent = yield _this8.scope.getModelComponentIfExist(id);
          if (modelComponent) return modelComponent;
          yield scopeComponentsImporter.importMany(new (_bitId().BitIds)(id));
          return _this8.scope.getModelComponent(id);
        });

        return function getModelComponent() {
          return _ref2.apply(this, arguments);
        };
      }();

      const modelComponent = yield getModelComponent();

      if (!id.version) {
        throw new TypeError('consumer.loadComponentWithDependenciesFromModel, version is missing from the id');
      }

      const versionDependencies = yield scopeComponentsImporter.componentToVersionDependencies(modelComponent, id);
      const manipulateDirData = yield (0, _manipulateDir().getManipulateDirWhenImportingComponents)(_this8.bitMap, [versionDependencies], _this8.scope.objects);
      return versionDependencies.toConsumer(_this8.scope.objects, manipulateDirData);
    })();
  }

  loadComponent(id) {
    var _this9 = this;

    return (0, _bluebird().coroutine)(function* () {
      const {
        components
      } = yield _this9.loadComponents(_bitId().BitIds.fromArray([id]));
      return components[0];
    })();
  }

  loadComponentForCapsule(id) {
    return this.componentLoader.loadForCapsule(id);
  }

  loadComponents(ids, throwOnFailure = true) {
    var _this10 = this;

    return (0, _bluebird().coroutine)(function* () {
      return _this10.componentLoader.loadMany(ids, throwOnFailure);
    })();
  }

  importEnvironment(bitId, verbose = false, dontPrintEnvMsg) {
    return (0, _installExtensions().default)({
      ids: [{
        componentId: bitId
      }],
      scope: this.scope,
      verbose,
      dontPrintEnvMsg
    });
  }

  importComponents(ids, withAllVersions, saveDependenciesAsComponents) {
    var _this11 = this;

    return (0, _bluebird().coroutine)(function* () {
      const scopeComponentsImporter = _scopeComponentsImporter().default.getInstance(_this11.scope);

      const versionDependenciesArr = withAllVersions ? yield scopeComponentsImporter.importManyWithAllVersions(ids, false) : yield scopeComponentsImporter.importMany(ids);
      const shouldDependenciesSavedAsComponents = yield _this11.shouldDependenciesSavedAsComponents(versionDependenciesArr.map(v => v.component.id), saveDependenciesAsComponents);
      const manipulateDirData = yield (0, _manipulateDir().getManipulateDirWhenImportingComponents)(_this11.bitMap, versionDependenciesArr, _this11.scope.objects);
      const componentWithDependencies = yield (0, _pMapSeries().default)(versionDependenciesArr, versionDependencies => versionDependencies.toConsumer(_this11.scope.objects, manipulateDirData));
      componentWithDependencies.forEach(componentWithDeps => {
        const shouldSavedAsComponents = shouldDependenciesSavedAsComponents.find(c => c.id.isEqual(componentWithDeps.component.id));

        if (!shouldSavedAsComponents) {
          throw new Error(`saveDependenciesAsComponents is missing for ${componentWithDeps.component.id.toString()}`);
        }

        componentWithDeps.component.dependenciesSavedAsComponents = shouldSavedAsComponents.saveDependenciesAsComponents;
      });
      return componentWithDependencies;
    })();
  }

  shouldDependenciesSavedAsComponents(bitIds, saveDependenciesAsComponents) {
    var _this12 = this;

    return (0, _bluebird().coroutine)(function* () {
      if (saveDependenciesAsComponents === undefined) {
        saveDependenciesAsComponents = _this12.config._saveDependenciesAsComponents;
      }

      const remotes = yield (0, _scopeRemotes().getScopeRemotes)(_this12.scope);
      const shouldDependenciesSavedAsComponents = bitIds.map(bitId => {
        return {
          id: bitId,
          // if it doesn't go to the hub, it can't import dependencies as packages
          saveDependenciesAsComponents: saveDependenciesAsComponents || !remotes.isHub(bitId.scope)
        };
      });
      return shouldDependenciesSavedAsComponents;
    })();
  }
  /**
   * By default, the dists paths are inside the component.
   * If dist attribute is populated in bit.json, the paths are in consumer-root/dist-target.
   */


  shouldDistsBeInsideTheComponent() {
    return !this.config._distEntry && !this.config._distTarget;
  }

  potentialComponentsForAutoTagging(modifiedComponents) {
    const candidateComponents = this.bitMap.getAuthoredAndImportedBitIds();
    const modifiedComponentsWithoutVersions = modifiedComponents.map(modifiedComponent => modifiedComponent.toStringWithoutVersion()); // if a modified component is in candidates array, remove it from the array as it will be already tagged with the
    // correct version

    const idsWithoutModified = candidateComponents.filter(component => !modifiedComponentsWithoutVersions.includes(component.toStringWithoutVersion()));
    return _bitId().BitIds.fromArray(idsWithoutModified);
  }

  listComponentsForAutoTagging(modifiedComponents) {
    var _this13 = this;

    return (0, _bluebird().coroutine)(function* () {
      const candidateComponents = _this13.potentialComponentsForAutoTagging(modifiedComponents);

      return (0, _autoTag().getAutoTagPending)(_this13.scope, candidateComponents, modifiedComponents);
    })();
  }
  /**
   * Check whether a model representation and file-system representation of the same component is the same.
   * The way how it is done is by converting the file-system representation of the component into
   * a Version object. Once this is done, we have two Version objects, and we can compare their hashes
   */


  isComponentModified(componentFromModel, componentFromFileSystem) {
    var _this14 = this;

    return (0, _bluebird().coroutine)(function* () {
      if (!(componentFromModel instanceof _models().Version)) {
        throw new TypeError(`isComponentModified expects componentFromModel to be Version, got ${typeof componentFromModel}`);
      }

      if (!(componentFromFileSystem instanceof _component().default)) {
        throw new TypeError(`isComponentModified expects componentFromFileSystem to be ConsumerComponent, got ${typeof componentFromFileSystem}`);
      }

      if (typeof componentFromFileSystem._isModified === 'undefined') {
        const componentMap = _this14.bitMap.getComponent(componentFromFileSystem.id);

        if (componentMap.originallySharedDir) {
          componentFromFileSystem.originallySharedDir = componentMap.originallySharedDir;
        } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


        const {
          version
        } = yield _this14.scope.sources.consumerComponentToVersion({
          consumer: _this14,
          consumerComponent: componentFromFileSystem
        });
        version.log = componentFromModel.log; // ignore the log, it's irrelevant for the comparison
        // sometime dependencies from the FS don't have an exact version.

        const copyDependenciesVersionsFromModelToFS = (dependenciesFS, dependenciesModel) => {
          dependenciesFS.get().forEach(dependency => {
            const dependencyFromModel = dependenciesModel.get().find(modelDependency => modelDependency.id.isEqualWithoutVersion(dependency.id));

            if (dependencyFromModel && !dependency.id.hasVersion()) {
              dependency.id = dependencyFromModel.id;
            }
          });
        };

        copyDependenciesVersionsFromModelToFS(version.dependencies, componentFromModel.dependencies);
        copyDependenciesVersionsFromModelToFS(version.devDependencies, componentFromModel.devDependencies);
        sortProperties(version); // prefix your command with "BIT_LOG=*" to see the actual id changes

        if (process.env.BIT_LOG && componentFromModel.hash().hash !== version.hash().hash) {
          console.log('-------------------componentFromModel------------------------'); // eslint-disable-line no-console

          console.log(componentFromModel.id()); // eslint-disable-line no-console

          console.log('------------------------componentFromFileSystem (version)----'); // eslint-disable-line no-console

          console.log(version.id()); // eslint-disable-line no-console

          console.log('-------------------------END---------------------------------'); // eslint-disable-line no-console
        }

        componentFromFileSystem._isModified = componentFromModel.hash().hash !== version.hash().hash;
      }

      return componentFromFileSystem._isModified;

      function sortProperties(version) {
        // sort the files by 'relativePath' because the order can be changed when adding or renaming
        // files in bitmap, which affects later on the model.
        version.files = _ramda().default.sortBy(_ramda().default.prop('relativePath'), version.files);
        componentFromModel.files = _ramda().default.sortBy(_ramda().default.prop('relativePath'), componentFromModel.files);
        version.dependencies.sort();
        version.devDependencies.sort();
        version.packageDependencies = (0, _utils().sortObject)(version.packageDependencies);
        version.devPackageDependencies = (0, _utils().sortObject)(version.devPackageDependencies);
        version.compilerPackageDependencies = (0, _utils().sortObject)(version.compilerPackageDependencies);
        version.testerPackageDependencies = (0, _utils().sortObject)(version.testerPackageDependencies);
        version.peerPackageDependencies = (0, _utils().sortObject)(version.peerPackageDependencies);
        sortOverrides(version.overrides);
        componentFromModel.dependencies.sort();
        componentFromModel.devDependencies.sort();
        componentFromModel.packageDependencies = (0, _utils().sortObject)(componentFromModel.packageDependencies);
        componentFromModel.devPackageDependencies = (0, _utils().sortObject)(componentFromModel.devPackageDependencies);
        componentFromModel.compilerPackageDependencies = (0, _utils().sortObject)(componentFromModel.compilerPackageDependencies);
        componentFromModel.testerPackageDependencies = (0, _utils().sortObject)(componentFromModel.testerPackageDependencies);
        componentFromModel.peerPackageDependencies = (0, _utils().sortObject)(componentFromModel.peerPackageDependencies);
        sortOverrides(componentFromModel.overrides);
      }

      function sortOverrides(overrides) {
        if (!overrides) return;

        _constants().DEPENDENCIES_FIELDS.forEach(field => {
          if (overrides[field]) overrides[field] = (0, _utils().sortObject)(overrides[field]);
        });
      }
    })();
  }

  getManyComponentsStatuses(ids) {
    var _this15 = this;

    return (0, _bluebird().coroutine)(function* () {
      return _this15.componentStatusLoader.getManyComponentsStatuses(ids);
    })();
  }

  getComponentStatusById(id) {
    var _this16 = this;

    return (0, _bluebird().coroutine)(function* () {
      return _this16.componentStatusLoader.getComponentStatusById(id);
    })();
  }

  tag(ids, message, exactVersion, releaseType, force, verbose, ignoreUnresolvedDependencies, ignoreNewestVersion, skipTests = false, skipAutoTag) {
    var _this17 = this;

    return (0, _bluebird().coroutine)(function* () {
      _logger().default.debug(`tagging the following components: ${ids.toString()}`);

      _analytics().Analytics.addBreadCrumb('tag', `tagging the following components: ${_analytics().Analytics.hashData(ids)}`);

      const components = yield _this17._loadComponentsForTag(ids); // go through the components list to check if there are missing dependencies
      // if there is at least one we won't tag anything

      const componentsWithRelativeAuthored = components.filter(component => component.issues && component.issues.relativeComponentsAuthored);

      if (!_this17.isLegacy && !_ramda().default.isEmpty(componentsWithRelativeAuthored)) {
        throw new (_exceptions().MissingDependencies)(componentsWithRelativeAuthored);
      }

      if (!ignoreUnresolvedDependencies) {
        // components that have issues other than relativeComponentsAuthored.
        const componentsWithOtherIssues = components.filter(component => {
          const issues = component.issues;
          return issues && Object.keys(issues).some(label => label !== 'relativeComponentsAuthored' && !_ramda().default.isEmpty(issues[label]));
        });
        if (!_ramda().default.isEmpty(componentsWithOtherIssues)) throw new (_exceptions().MissingDependencies)(componentsWithOtherIssues);
      }

      const areComponentsMissingFromScope = components.some(c => !c.componentFromModel && c.id.hasScope());

      if (areComponentsMissingFromScope) {
        throw new (_componentsPendingImport().default)();
      }

      const {
        taggedComponents,
        autoTaggedResults
      } = yield (0, _tagModelComponent().default)({
        consumerComponents: components,
        scope: _this17.scope,
        message,
        exactVersion,
        releaseType,
        force,
        consumer: _this17,
        ignoreNewestVersion,
        skipTests,
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        verbose,
        skipAutoTag
      });
      const autoTaggedComponents = autoTaggedResults.map(r => r.component);
      const allComponents = [...taggedComponents, ...autoTaggedComponents];
      yield _this17.updateComponentsVersions(allComponents);
      return {
        taggedComponents,
        autoTaggedResults
      };
    })();
  }

  _loadComponentsForTag(ids) {
    var _this18 = this;

    return (0, _bluebird().coroutine)(function* () {
      const {
        components
      } = yield _this18.loadComponents(ids);

      if (_this18.isLegacy) {
        return components;
      }

      let shouldReloadComponents;
      const componentsWithRelativePaths = [];
      const componentsWithFilesNotDir = [];
      components.forEach(component => {
        const componentMap = component.componentMap;
        if (componentMap.rootDir) return;
        const hasRelativePaths = component.issues && component.issues.relativeComponentsAuthored; // leaving this because it can be helpful for users upgrade from legacy

        if (componentMap.trackDir && !hasRelativePaths) {
          componentMap.changeRootDirAndUpdateFilesAccordingly(componentMap.trackDir);
          shouldReloadComponents = true;
          return;
        }

        if (hasRelativePaths) {
          componentsWithRelativePaths.push(component.id.toStringWithoutVersion());
        }

        if (!componentMap.trackDir) {
          componentsWithFilesNotDir.push(component.id.toStringWithoutVersion());
        }
      });

      if (componentsWithRelativePaths.length || componentsWithFilesNotDir.length) {
        throw new (_failedLoadForTag().FailedLoadForTag)(componentsWithRelativePaths.sort(), componentsWithFilesNotDir.sort());
      }

      if (!shouldReloadComponents) return components;

      _this18.componentLoader.clearComponentsCache();

      const {
        components: reloadedComponents
      } = yield _this18.loadComponents(ids);
      return reloadedComponents;
    })();
  }

  updateComponentsVersions(components) {
    const getPackageJsonDir = (componentMap, bitId, bindingPrefix) => {
      if (componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED) {
        if (componentMap.hasRootDir()) return null; // no package.json in this case

        return (0, _componentNodeModulesPath().default)(bindingPrefix, bitId, true, this.config.defaultScope);
      }

      return componentMap.rootDir;
    };

    const updateVersionsP = components.map(component => {
      const id = component instanceof _models().ModelComponent ? component.toBitIdWithLatestVersionAllowNull() : component.id;
      this.bitMap.updateComponentId(id);
      const componentMap = this.bitMap.getComponent(id);
      const packageJsonDir = getPackageJsonDir(componentMap, id, component.bindingPrefix);
      return packageJsonDir // if it has package.json, it's imported, which must have a version
      ? packageJsonUtils().updateAttribute(this, packageJsonDir, 'version', id.version) : Promise.resolve();
    });
    return Promise.all(updateVersionsP);
  }

  getComponentIdFromNodeModulesPath(requirePath, bindingPrefix) {
    requirePath = (0, _utils().pathNormalizeToLinux)(requirePath);
    const prefix = requirePath.includes('node_modules') ? 'node_modules/' : '';
    const withoutPrefix = prefix ? requirePath.substr(requirePath.indexOf(prefix) + prefix.length) : requirePath;

    if (!withoutPrefix.includes('/')) {
      throw new (_generalError().default)('getComponentIdFromNodeModulesPath expects the path to have at least one slash for the scoped package, such as @bit/');
    }

    const packageSplitBySlash = withoutPrefix.split('/'); // the part after the second slash is the path inside the package, just ignore it.
    // (e.g. @bit/my-scope.my-name/internal-path.js).

    const packageName = `${packageSplitBySlash[0]}/${packageSplitBySlash[1]}`;
    return (0, _packageNameToComponentId().packageNameToComponentId)(this, packageName, bindingPrefix);
  }

  composeRelativeComponentPath(bitId) {
    const {
      componentsDefaultDirectory
    } = this.dirStructure;
    return (0, _composeComponentPath().composeComponentPath)(bitId, componentsDefaultDirectory);
  }

  composeComponentPath(bitId) {
    const addToPath = [this.getPath(), this.composeRelativeComponentPath(bitId)];

    _logger().default.debug(`component dir path: ${addToPath.join('/')}`);

    _analytics().Analytics.addBreadCrumb('composeComponentPath', `component dir path: ${_analytics().Analytics.hashData(addToPath.join('/'))}`);

    return path().join(...addToPath);
  }

  composeRelativeDependencyPath(bitId) {
    const dependenciesDir = this.dirStructure.dependenciesDirStructure;
    return (0, _composeComponentPath().composeDependencyPath)(bitId, dependenciesDir);
  }

  composeDependencyPath(bitId) {
    const relativeDependencyPath = this.composeRelativeDependencyPath(bitId);
    return path().join(this.getPath(), relativeDependencyPath);
  }

  static create(projectPath, noGit = false, workspaceConfigProps) {
    return this.ensure(projectPath, noGit, workspaceConfigProps);
  }

  static _getScopePath(projectPath, noGit) {
    const gitDirPath = path().join(projectPath, _constants().DOT_GIT_DIR);
    let resolvedScopePath = path().join(projectPath, _constants().BIT_HIDDEN_DIR);

    if (!noGit && _fsExtra().default.existsSync(gitDirPath) && !_fsExtra().default.existsSync(resolvedScopePath)) {
      resolvedScopePath = path().join(gitDirPath, _constants().BIT_GIT_DIR);
    }

    return resolvedScopePath;
  }

  static ensure(projectPath, standAlone = false, workspaceConfigProps) {
    return (0, _bluebird().coroutine)(function* () {
      const resolvedScopePath = Consumer._getScopePath(projectPath, standAlone);

      let existingGitHooks;

      const bitMap = _bitMap().default.load(projectPath); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      const scopeP = _scope().Scope.ensure(resolvedScopePath);

      const configP = _workspaceConfig().default.ensure(projectPath, standAlone, workspaceConfigProps);

      const [scope, config] = yield Promise.all([scopeP, configP]);
      return new Consumer({
        projectPath,
        created: true,
        scope,
        config,
        bitMap,
        existingGitHooks
      });
    })();
  }
  /**
   * if resetHard, delete consumer-files: bitMap and bit.json and also the local scope (.bit dir).
   * otherwise, delete the consumer-files only when they are corrupted
   */


  static reset(projectPath, resetHard, noGit = false) {
    return (0, _bluebird().coroutine)(function* () {
      const resolvedScopePath = Consumer._getScopePath(projectPath, noGit);

      _bitMap().default.reset(projectPath, resetHard);

      const scopeP = _scope().Scope.reset(resolvedScopePath, resetHard);

      const configP = _workspaceConfig().default.reset(projectPath, resetHard);

      yield Promise.all([scopeP, configP]);
    })();
  }

  static createIsolatedWithExistingScope(consumerPath, scope) {
    return (0, _bluebird().coroutine)(function* () {
      // if it's an isolated environment, it's normal to have already the consumer
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const config = yield _workspaceConfig().default._ensure(consumerPath); // isolated environments in the workspace rely on a physical node_modules folder
      // for this reason, we must use a package manager that supports one

      config.packageManager = 'npm'; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      return new Consumer({
        projectPath: consumerPath,
        created: true,
        scope,
        isolated: true,
        config
      });
    })();
  }

  static locateProjectScope(projectPath) {
    if (_fsExtra().default.existsSync(path().join(projectPath, _constants().DOT_GIT_DIR, _constants().BIT_GIT_DIR))) {
      return path().join(projectPath, _constants().DOT_GIT_DIR, _constants().BIT_GIT_DIR);
    }

    if (_fsExtra().default.existsSync(path().join(projectPath, _constants().BIT_HIDDEN_DIR))) {
      return path().join(projectPath, _constants().BIT_HIDDEN_DIR);
    }

    return undefined;
  }

  static load(currentPath) {
    return (0, _bluebird().coroutine)(function* () {
      const consumerInfo = yield (0, _consumerLocator().getConsumerInfo)(currentPath);

      if (!consumerInfo) {
        return Promise.reject(new (_exceptions().ConsumerNotFound)());
      }

      let consumer;

      if ((!consumerInfo.hasConsumerConfig || !consumerInfo.hasScope) && consumerInfo.hasBitMap) {
        consumer = yield Consumer.create(consumerInfo.path);
        yield Promise.all([consumer.config.write({
          workspaceDir: consumer.projectPath
        }), consumer.scope.ensureDir()]);
      }

      const config = consumer && consumer.config ? consumer.config : yield _workspaceConfig().default.loadIfExist(consumerInfo.path);
      const scopePath = Consumer.locateProjectScope(consumerInfo.path); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const scope = yield _scope().Scope.load(scopePath); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      return new Consumer({
        projectPath: consumerInfo.path,
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        config,
        scope
      });
    })();
  }
  /**
   * legacy is a workspace uses the old bit.json or "bit" prop of package.json.
   * new workspaces use workspace.jsonc file
   */


  get isLegacy() {
    if (!('isLegacy' in this.config)) {
      // this happens for example when running `bit import --compiler`. the environment dir has its
      // own consumer and the config is not ILegacyWorkspaceConfig but WorkspaceConfig
      return true;
    }

    return this.config.isLegacy;
  }
  /**
   * clean up removed components from bitmap
   * @param {BitIds} componentsToRemoveFromFs - delete component that are used by other components.
   * @param {BitIds} removedDependencies - delete component that are used by other components.
   */


  cleanFromBitMap(componentsToRemoveFromFs, removedDependencies) {
    var _this19 = this;

    return (0, _bluebird().coroutine)(function* () {
      _logger().default.debug(`consumer.cleanFromBitMap, cleaning ${componentsToRemoveFromFs.toString()} from .bitmap`);

      _this19.bitMap.removeComponents(componentsToRemoveFromFs);

      _this19.bitMap.removeComponents(removedDependencies);
    })();
  }

  addRemoteAndLocalVersionsToDependencies(component, loadedFromFileSystem) {
    var _this20 = this;

    return (0, _bluebird().coroutine)(function* () {
      _logger().default.debug(`addRemoteAndLocalVersionsToDependencies for ${component.id.toString()}`);

      _analytics().Analytics.addBreadCrumb('addRemoteAndLocalVersionsToDependencies', `addRemoteAndLocalVersionsToDependencies for ${_analytics().Analytics.hashData(component.id.toString())}`);

      let modelDependencies = new (_dependencies().Dependencies)([]);
      let modelDevDependencies = new (_dependencies().Dependencies)([]);

      if (loadedFromFileSystem) {
        // when loaded from file-system, the dependencies versions are fetched from bit.map.
        // find the model version of the component and get the stored versions of the dependencies
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        const mainComponentFromModel = component.componentFromModel;

        if (mainComponentFromModel) {
          // otherwise, the component is probably on the file-system only and not on the model.
          modelDependencies = mainComponentFromModel.dependencies;
          modelDevDependencies = mainComponentFromModel.devDependencies;
        }
      }

      yield component.dependencies.addRemoteAndLocalVersions(_this20.scope, modelDependencies);
      yield component.devDependencies.addRemoteAndLocalVersions(_this20.scope, modelDevDependencies);
    })();
  }

  getAuthoredAndImportedDependentsIdsOf(components) {
    var _this21 = this;

    return (0, _bluebird().coroutine)(function* () {
      const authoredAndImportedComponents = _this21.bitMap.getAllBitIds([_constants().COMPONENT_ORIGINS.IMPORTED, _constants().COMPONENT_ORIGINS.AUTHORED]);

      const componentsIds = _bitId().BitIds.fromArray(components.map(c => c.id));

      return _this21.scope.findDirectDependentComponents(authoredAndImportedComponents, componentsIds);
    })();
  }

  getAuthoredAndImportedDependentsComponentsOf(components) {
    var _this22 = this;

    return (0, _bluebird().coroutine)(function* () {
      const dependentsIds = yield _this22.getAuthoredAndImportedDependentsIdsOf(components);

      const scopeComponentsImporter = _scopeComponentsImporter().default.getInstance(_this22.scope);

      const versionDependenciesArr = yield scopeComponentsImporter.importMany(dependentsIds, true, false);
      const manipulateDirData = yield (0, _manipulateDir().getManipulateDirWhenImportingComponents)(_this22.bitMap, versionDependenciesArr, _this22.scope.objects);
      const dependentComponentsP = versionDependenciesArr.map(c => c.component.toConsumer(_this22.scope.objects, manipulateDirData));
      return Promise.all(dependentComponentsP);
    })();
  }

  ejectConf(componentId) {
    var _this23 = this;

    return (0, _bluebird().coroutine)(function* () {
      const component = yield _this23.loadComponent(componentId);
      return component.writeConfig(_this23);
    })();
  }

  injectConf(componentId, force) {
    var _this24 = this;

    return (0, _bluebird().coroutine)(function* () {
      const component = yield _this24.loadComponent(componentId);
      return component.injectConfig(_this24.getPath(), _this24.bitMap, force);
    })();
  }

  _getEnvProps(envType, context) {
    const envs = this.config._getEnvsByType(envType);

    if (!envs) return undefined;
    const envName = Object.keys(envs)[0];
    const envObject = envs[envName];
    return {
      name: envName,
      consumerPath: this.getPath(),
      scopePath: this.scope.getPath(),
      rawConfig: envObject.rawConfig,
      files: envObject.files,
      bitJsonPath: path().dirname(this.config.path),
      options: envObject.options,
      envType,
      context
    };
  }

  onDestroy() {
    var _this25 = this;

    return (0, _bluebird().coroutine)(function* () {
      yield _this25.cleanTmpFolder();
      return _this25.bitMap.write();
    })();
  }

}

exports.default = Consumer;