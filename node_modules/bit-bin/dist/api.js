"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  show: true,
  list: true,
  buildOne: true,
  buildAll: true,
  addMany: true,
  loadCoreExtensions: true,
  getLoadedCoreExtension: true,
  getDeclarationCoreExtension: true,
  harmony: true,
  coreExtensions: true
};
exports.show = show;
exports.list = list;
exports.buildOne = buildOne;
exports.buildAll = buildAll;
exports.addMany = addMany;
exports.loadCoreExtensions = loadCoreExtensions;
exports.getLoadedCoreExtension = getLoadedCoreExtension;
exports.getDeclarationCoreExtension = getDeclarationCoreExtension;
Object.defineProperty(exports, "harmony", {
  enumerable: true,
  get: function () {
    return _harmony.default;
  }
});
Object.defineProperty(exports, "coreExtensions", {
  enumerable: true,
  get: function () {
    return _bit().manifestsMap;
  }
});

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

var _harmony = _interopRequireWildcard(require("@teambit/harmony"));

Object.keys(_harmony).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _harmony[key];
    }
  });
});

function _pWaitFor() {
  const data = _interopRequireDefault(require("p-wait-for"));

  _pWaitFor = function () {
    return data;
  };

  return data;
}

function _index() {
  const data = require("./api/consumer/index");

  _index = function () {
    return data;
  };

  return data;
}

function _index2() {
  const data = require("./api/scope/index");

  _index2 = function () {
    return data;
  };

  return data;
}

function _hooks() {
  const data = _interopRequireDefault(require("./hooks"));

  _hooks = function () {
    return data;
  };

  return data;
}

function _config() {
  const data = require("./extensions/config");

  _config = function () {
    return data;
  };

  return data;
}

function _bit() {
  const data = require("./extensions/bit");

  _bit = function () {
    return data;
  };

  return data;
}

_hooks().default.init();

let harmonyLoaded = false;
let harmonyCurrentlyLoading = false;

function show(scopePath, id, opts) {
  // When using the API programmatically do not use the scope cache by default
  const loadScopeFromCache = opts && opts.loadScopeFromCache !== undefined ? !!opts.loadScopeFromCache : false; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  return (0, _index().getScopeComponent)({
    scopePath,
    id,
    allVersions: opts && opts.versions,
    loadScopeFromCache
  }).then(({
    component
  }) => {
    if (Array.isArray(component)) {
      return component.map(v => v.toObject());
    }

    return component.toObject();
  });
}

function list(scopePath, namespacesUsingWildcards, opts = {}) {
  // When using the API programmatically do not use the scope cache by default
  const loadScopeFromCache = opts && opts.loadScopeFromCache !== undefined ? !!opts.loadScopeFromCache : false;
  return (0, _index2().scopeList)(scopePath, namespacesUsingWildcards, loadScopeFromCache).then(listScopeResult => listScopeResult.map(result => result.id.toString()));
}

function buildOne(_x) {
  return _buildOne.apply(this, arguments);
}

function _buildOne() {
  _buildOne = (0, _bluebird().coroutine)(function* (id, noCache = false, verbose = false, workspaceDir) {
    return (0, _index().build)(id, noCache, verbose, workspaceDir);
  });
  return _buildOne.apply(this, arguments);
}

function buildAll(_x2) {
  return _buildAll.apply(this, arguments);
}

function _buildAll() {
  _buildAll = (0, _bluebird().coroutine)(function* (id, noCache = false, verbose = false) {
    return (0, _index().buildAll)(noCache, verbose);
  });
  return _buildAll.apply(this, arguments);
}

function addMany(_x3, _x4) {
  return _addMany.apply(this, arguments);
}
/**
 * Make sure harmony is loaded in specific cwd (to simulate like you run the cli in a workspace/scope)
 * This will return the harmony instance after load all core extensions
 *
 * @export
 * @param {string} [cwd]
 * @returns
 */


function _addMany() {
  _addMany = (0, _bluebird().coroutine)(function* (components, alternateCwd) {
    return (0, _index().addMany)(components, alternateCwd);
  });
  return _addMany.apply(this, arguments);
}

function loadCoreExtensions() {
  return _loadCoreExtensions.apply(this, arguments);
}
/**
 * Make sure harmony is loaded in specific cwd (to simulate like you run the cli in a workspace/scope)
 * Then return the loaded extension.
 * this return the actual initialized extension
 *
 * @export
 * @param {string} extensionId
 * @param {string} [cwd]
 * @returns
 */


function _loadCoreExtensions() {
  _loadCoreExtensions = (0, _bluebird().coroutine)(function* (options = {}) {
    // Sometime different code can ask for loading the extensions
    // for example if you call getLoadedCoreExtension in a promise.all
    // this make sure we are wait for harmony to load if it's already in load process before we send response back
    if (harmonyCurrentlyLoading) {
      yield (0, _pWaitFor().default)(() => harmonyCurrentlyLoading === false, {
        timeout: options.timeout || 10000
      });
    }

    if (harmonyLoaded) {
      return _harmony.default;
    }

    harmonyCurrentlyLoading = true;
    const originalCwd = process.cwd();

    if (options.cwd) {
      process.chdir(options.cwd);
    }

    yield _harmony.default.run(_config().ConfigExt);
    yield _harmony.default.set([_bit().BitExt]);
    process.chdir(originalCwd);
    harmonyLoaded = true;
    harmonyCurrentlyLoading = false;
    return _harmony.default;
  });
  return _loadCoreExtensions.apply(this, arguments);
}

function getLoadedCoreExtension(_x5) {
  return _getLoadedCoreExtension.apply(this, arguments);
}
/**
 * Get the deceleration (manifest) of a core extension
 * This is used in order to put the extension as dependency for other extension
 *
 * @export
 * @param {string} extensionId
 * @returns
 */


function _getLoadedCoreExtension() {
  _getLoadedCoreExtension = (0, _bluebird().coroutine)(function* (extensionId, options = {}) {
    yield loadCoreExtensions(options);
    return _harmony.default.get(extensionId);
  });
  return _getLoadedCoreExtension.apply(this, arguments);
}

function getDeclarationCoreExtension(extensionId) {
  return _bit().manifestsMap[extensionId];
}