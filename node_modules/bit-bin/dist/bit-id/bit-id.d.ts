import { PathOsBased } from '../utils/path';
export declare type BitIdProps = {
    scope?: string | null | undefined;
    box?: string | undefined;
    name: string;
    version?: string | undefined;
};
export declare type BitIdStr = string;
export default class BitId {
    readonly scope: string | null | undefined;
    readonly box: string | undefined;
    readonly name: string;
    readonly version: string | undefined;
    constructor({ scope, box, name, version }: BitIdProps);
    clone(): BitId;
    changeScope(newScope?: string | null | undefined): BitId;
    changeVersion(newVersion: string | undefined): BitId;
    isLocal(scopeName?: string): boolean;
    getVersion(): import("../version").default;
    hasVersion(): boolean;
    hasScope(): boolean;
    hasSameName(id: BitId): boolean;
    hasSameScope(id: BitId): boolean;
    hasSameVersion(id: BitId): boolean;
    toString(ignoreScope?: boolean, ignoreVersion?: boolean): BitIdStr;
    toStringWithoutScope(): BitIdStr;
    toStringWithoutVersion(): BitIdStr;
    toStringWithoutScopeAndVersion(): BitIdStr;
    isEqual(bitId: BitId): boolean;
    isEqualWithoutVersion(bitId: BitId): boolean;
    isEqualWithoutScopeAndVersion(bitId: BitId): boolean;
    serialize(): {
        scope: string | null | undefined;
        name: string;
        version: string | undefined;
    };
    toObject(): {
        [x: string]: string | undefined;
    };
    toFullPath(): PathOsBased;
    static getStringWithoutVersion(id: string): string;
    static getVersionOnlyFromString(id: string): string;
    static parse(id: BitIdStr, hasScope?: boolean, version?: string): BitId;
    static parseObsolete(id: BitIdStr, version?: string): BitId;
    static parseBackwardCompatible(id: string | BitIdProps): BitId;
    static getValidScopeName(scope: string): string;
    static getValidIdChunk(chunk: string): string;
    static getValidBitId(box: string | undefined, name: string): BitId;
    static isValidVersion(version: string): boolean;
}
