"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _graphlib() {
  const data = require("graphlib");

  _graphlib = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _index() {
  const data = require("../index");

  _index = function () {
    return data;
  };

  return data;
}

class Graph extends _graphlib().Graph {
  getSuccessorsByEdgeTypeRecursively(bitId, successorsList = [], visited = {}) {
    const successors = this.successors(bitId) || [];

    if (successors.length > 0 && !visited[bitId]) {
      successors.forEach(successor => {
        visited[bitId] = true;
        successorsList.push(successor);
        return this.getSuccessorsByEdgeTypeRecursively(successor, successorsList, visited);
      });
    }

    return successorsList;
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  static buildGraphFromScope(scope) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      const graph = new Graph();
      const allModelComponents = yield scope.list();
      yield _this.addScopeComponentsAsNodes(allModelComponents, graph);
    })();
  }

  static _addDependenciesToGraph(id, graph, component) {
    const idStr = id.toString(); // save the full BitId of a string id to be able to retrieve it later with no confusion

    if (!graph.hasNode(idStr)) graph.setNode(idStr, id);
    Object.entries(component.depsIdsGroupedByType).forEach(([depType, depIds]) => {
      depIds.forEach(dependencyId => {
        const depIdStr = dependencyId.toString();
        if (!graph.hasNode(depIdStr)) graph.setNode(depIdStr, dependencyId);
        graph.setEdge(idStr, depIdStr, depType);
      });
    });
  }

  static addScopeComponentsAsNodes(allModelComponents, graph, workspaceComponents, onlyLatest = false) {
    return (0, _bluebird().coroutine)(function* () {
      const scope = yield (0, _index().loadScope)(process.cwd());
      yield Promise.all(allModelComponents.map( /*#__PURE__*/function () {
        var _ref = (0, _bluebird().coroutine)(function* (modelComponent) {
          const latestVersion = modelComponent.latest();
          const buildVersionP = modelComponent.listVersions().map( /*#__PURE__*/function () {
            var _ref2 = (0, _bluebird().coroutine)(function* (versionNum) {
              if (onlyLatest && latestVersion !== versionNum) return;
              const id = modelComponent.toBitId().changeVersion(versionNum);
              const componentFromWorkspace = workspaceComponents ? workspaceComponents.find(comp => comp.id.isEqual(id)) : undefined;

              if (!componentFromWorkspace) {
                const componentVersion = yield scope.getConsumerComponentIfExist(id);

                if (componentVersion) {
                  // a component might be in the scope with only the latest version (happens when it's a nested dep)
                  graph.setNode(componentVersion.id.toString(), componentVersion);
                }
              }
            });

            return function (_x2) {
              return _ref2.apply(this, arguments);
            };
          }());
          yield Promise.all(buildVersionP);
        });

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }()));
    })();
  }

  static buildGraphFromWorkspace(consumer, onlyLatest = false) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      const componentsList = new (_componentsList().default)(consumer);
      const allModelComponents = yield consumer.scope.list();
      const workspaceComponents = yield componentsList.getFromFileSystem();
      const graph = new Graph();
      workspaceComponents.forEach(component => {
        const id = component.id.toString();
        graph.setNode(id, component);
      });
      yield _this2.addScopeComponentsAsNodes(allModelComponents, graph, workspaceComponents, onlyLatest);

      _ramda().default.forEach(componentId => {
        const component = graph.node(componentId);
        Object.entries(component.depsIdsGroupedByType).forEach(([depType, depIds]) => {
          depIds.forEach(dependencyId => {
            const depIdStr = dependencyId.toString();

            if (graph.hasNode(depIdStr)) {
              graph.setEdge(componentId, depIdStr, depType);
            }
          });
        });
      }, graph.nodes());

      return graph;
    })();
  }

}

exports.default = Graph;