"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _objects() {
  const data = require("../objects");

  _objects = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _dependencies() {
  const data = require("../../consumer/component/dependencies");

  _dependencies = function () {
    return data;
  };

  return data;
}

function _sources() {
  const data = require("../../consumer/component/sources");

  _sources = function () {
    return data;
  };

  return data;
}

function _versionInvalid() {
  const data = _interopRequireDefault(require("../exceptions/version-invalid"));

  _versionInvalid = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _versionValidator() {
  const data = _interopRequireDefault(require("../version-validator"));

  _versionValidator = function () {
    return data;
  };

  return data;
}

function _extensionData() {
  const data = require("../../consumer/config/extension-data");

  _extensionData = function () {
    return data;
  };

  return data;
}

/**
 * Represent a version model in the scope
 */
class Version extends _objects().BitObject {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  constructor(props) {
    super();
    (0, _defineProperty2().default)(this, "mainFile", void 0);
    (0, _defineProperty2().default)(this, "files", void 0);
    (0, _defineProperty2().default)(this, "dists", void 0);
    (0, _defineProperty2().default)(this, "mainDistFile", void 0);
    (0, _defineProperty2().default)(this, "compiler", void 0);
    (0, _defineProperty2().default)(this, "tester", void 0);
    (0, _defineProperty2().default)(this, "log", void 0);
    (0, _defineProperty2().default)(this, "ci", void 0);
    (0, _defineProperty2().default)(this, "specsResults", void 0);
    (0, _defineProperty2().default)(this, "docs", void 0);
    (0, _defineProperty2().default)(this, "dependencies", void 0);
    (0, _defineProperty2().default)(this, "devDependencies", void 0);
    (0, _defineProperty2().default)(this, "flattenedDependencies", void 0);
    (0, _defineProperty2().default)(this, "flattenedDevDependencies", void 0);
    (0, _defineProperty2().default)(this, "packageDependencies", void 0);
    (0, _defineProperty2().default)(this, "devPackageDependencies", void 0);
    (0, _defineProperty2().default)(this, "peerPackageDependencies", void 0);
    (0, _defineProperty2().default)(this, "compilerPackageDependencies", void 0);
    (0, _defineProperty2().default)(this, "testerPackageDependencies", void 0);
    (0, _defineProperty2().default)(this, "bindingPrefix", void 0);
    (0, _defineProperty2().default)(this, "ignoreSharedDir", void 0);
    (0, _defineProperty2().default)(this, "customResolvedPaths", void 0);
    (0, _defineProperty2().default)(this, "overrides", void 0);
    (0, _defineProperty2().default)(this, "packageJsonChangedProps", void 0);
    (0, _defineProperty2().default)(this, "extensions", void 0);
    this.mainFile = props.mainFile;
    this.files = props.files;
    this.dists = props.dists;
    this.mainDistFile = props.mainDistFile;
    this.compiler = props.compiler;
    this.tester = props.tester;
    this.log = props.log;
    this.dependencies = new (_dependencies().Dependencies)(props.dependencies);
    this.devDependencies = new (_dependencies().Dependencies)(props.devDependencies);
    this.docs = props.docs;
    this.ci = props.ci || {};
    this.specsResults = props.specsResults;
    this.flattenedDependencies = props.flattenedDependencies || new (_bitId().BitIds)();
    this.flattenedDevDependencies = props.flattenedDevDependencies || new (_bitId().BitIds)();
    this.packageDependencies = props.packageDependencies || {};
    this.devPackageDependencies = props.devPackageDependencies || {};
    this.peerPackageDependencies = props.peerPackageDependencies || {};
    this.compilerPackageDependencies = props.compilerPackageDependencies || {};
    this.testerPackageDependencies = props.testerPackageDependencies || {};
    this.bindingPrefix = props.bindingPrefix;
    this.ignoreSharedDir = props.ignoreSharedDir;
    this.customResolvedPaths = props.customResolvedPaths;
    this.overrides = props.overrides || {};
    this.packageJsonChangedProps = props.packageJsonChangedProps || {};
    this.extensions = props.extensions || _extensionData().ExtensionDataList.fromArray([]);
    this.validateVersion();
  }

  validateVersion() {
    const nonEmptyFields = ['mainFile', 'files'];
    nonEmptyFields.forEach(field => {
      if (!this[field]) {
        throw new (_versionInvalid().default)(`failed creating a version object, the field "${field}" can't be empty`);
      }
    });
  }

  id() {
    const obj = this.toObject(); // @todo: remove the entire dependencies.relativePaths from the ID (it's going to be a breaking change)

    const getDependencies = deps => {
      const clonedDependencies = deps.cloneAsString(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      return clonedDependencies.map(dependency => {
        return {
          id: dependency.id,
          relativePaths: dependency.relativePaths.map(relativePath => {
            return {
              sourceRelativePath: relativePath.sourceRelativePath,
              destinationRelativePath: relativePath.destinationRelativePath
            };
          })
        };
      });
    };

    const filterFunction = (val, key) => {
      if (key === 'devDependencies' || key === 'devPackageDependencies' || key === 'peerPackageDependencies' || key === 'overrides') {
        return !_ramda().default.isEmpty(val);
      }

      return !!val;
    };

    return JSON.stringify((0, _utils().filterObject)({
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      mainFile: obj.mainFile,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      files: obj.files,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      compiler: obj.compiler,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      tester: obj.tester,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      log: obj.log,
      dependencies: getDependencies(this.dependencies),
      devDependencies: getDependencies(this.devDependencies),
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageDependencies: obj.packageDependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      devPackageDependencies: obj.devPackageDependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      peerPackageDependencies: obj.peerPackageDependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      bindingPrefix: obj.bindingPrefix,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      overrides: obj.overrides
    }, filterFunction));
  }

  get extensionDependencies() {
    return new (_dependencies().Dependencies)(this.extensions.extensionsBitIds.map(id => new (_dependencies().Dependency)(id, [])));
  }

  getAllFlattenedDependencies() {
    return _bitId().BitIds.fromArray([...this.flattenedDependencies, ...this.flattenedDevDependencies]);
  }

  getAllDependencies() {
    return [...this.dependencies.dependencies, ...this.devDependencies.dependencies, ...this.extensionDependencies.dependencies];
  }

  get depsIdsGroupedByType() {
    return {
      dependencies: this.dependencies.getAllIds(),
      devDependencies: this.devDependencies.getAllIds(),
      extensionDependencies: this.extensions.extensionsBitIds
    };
  }

  getAllDependenciesCloned() {
    const dependencies = [...this.dependencies.getClone(), ...this.devDependencies.getClone()];
    return new (_dependencies().Dependencies)(dependencies);
  }

  getAllDependenciesIds() {
    const allDependencies = _ramda().default.flatten(Object.values(this.depsIdsGroupedByType));

    return _bitId().BitIds.fromArray(allDependencies);
  }

  getDependenciesIdsExcludeExtensions() {
    return _bitId().BitIds.fromArray([...this.dependencies.getAllIds(), ...this.devDependencies.getAllIds()]);
  }

  updateFlattenedDependency(currentId, newId) {
    const getUpdated = flattenedDependencies => {
      const updatedIds = flattenedDependencies.map(depId => {
        if (depId.isEqual(currentId)) return newId;
        return depId;
      });
      return _bitId().BitIds.fromArray(updatedIds);
    };

    this.flattenedDependencies = getUpdated(this.flattenedDependencies);
    this.flattenedDevDependencies = getUpdated(this.flattenedDevDependencies);
  }

  refs() {
    const extractRefsFromFiles = files => {
      const refs = files ? files.map(file => file.file) : [];
      return refs;
    };

    const files = extractRefsFromFiles(this.files);
    const dists = extractRefsFromFiles(this.dists);
    const artifacts = extractRefsFromFiles(_ramda().default.flatten(this.extensions.map(e => e.artifacts)));
    return [...dists, ...files, ...artifacts].filter(ref => ref);
  }

  toObject() {
    const _convertFileToObject = file => {
      return {
        file: file.file.toString(),
        relativePath: file.relativePath,
        name: file.name,
        test: file.test
      };
    };

    const _convertEnvToObject = env => {
      if (typeof env === 'string') {
        return env;
      } // Store the env as string in case there is no config and files (for backward compatibility)


      if (envNameOnly(env)) {
        return env.name;
      }

      const result = {
        name: env.name,
        config: env.config,
        files: []
      };
      return result;
    };

    const _removeEmptyPackagesEnvs = pkgEnv => {
      _constants().DEPENDENCIES_FIELDS.forEach(dependencyType => {
        if (pkgEnv[dependencyType] && _ramda().default.isEmpty(pkgEnv[dependencyType])) {
          delete pkgEnv[dependencyType];
        }
      });

      return pkgEnv;
    };

    return (0, _utils().filterObject)({
      files: this.files ? this.files.map(_convertFileToObject) : null,
      mainFile: this.mainFile,
      dists: this.dists ? this.dists.map(_convertFileToObject) : null,
      mainDistFile: this.mainDistFile,
      compiler: this.compiler ? _convertEnvToObject(this.compiler) : null,
      bindingPrefix: this.bindingPrefix || _constants().DEFAULT_BINDINGS_PREFIX,
      ignoreSharedDir: this.ignoreSharedDir,
      tester: this.tester ? _convertEnvToObject(this.tester) : null,
      log: {
        message: this.log.message,
        date: this.log.date,
        username: this.log.username,
        email: this.log.email
      },
      ci: this.ci,
      specsResults: this.specsResults,
      docs: this.docs,
      dependencies: this.dependencies.cloneAsObject(),
      devDependencies: this.devDependencies.cloneAsObject(),
      flattenedDependencies: this.flattenedDependencies.map(dep => dep.serialize()),
      flattenedDevDependencies: this.flattenedDevDependencies.map(dep => dep.serialize()),
      extensions: this.extensions.map(ext => {
        const extensionClone = ext.clone();

        if (extensionClone.extensionId) {
          // TODO: fix the types of extensions. after this it should be an object not an object id
          // @ts-ignore
          extensionClone.extensionId = ext.extensionId.serialize();
        }

        extensionClone.artifacts = extensionClone.artifacts.map(file => ({
          file: file.file.toString(),
          relativePath: file.relativePath
        }));
        return extensionClone;
      }),
      packageDependencies: this.packageDependencies,
      devPackageDependencies: this.devPackageDependencies,
      peerPackageDependencies: this.peerPackageDependencies,
      compilerPackageDependencies: _removeEmptyPackagesEnvs(this.compilerPackageDependencies),
      testerPackageDependencies: _removeEmptyPackagesEnvs(this.testerPackageDependencies),
      customResolvedPaths: this.customResolvedPaths,
      overrides: this.overrides,
      packageJsonChangedProps: this.packageJsonChangedProps
    }, val => !!val);
  }

  validateBeforePersisting(versionStr) {
    _logger().default.silly(`validating version object, hash: ${this.hash().hash}`);

    const version = Version.parse(versionStr);
    version.validate();
  }

  toBuffer(pretty) {
    const obj = this.toObject();
    const args = (0, _utils().getStringifyArgs)(pretty);
    const str = JSON.stringify(obj, ...args);
    if (this.validateBeforePersist) this.validateBeforePersisting(str);
    return Buffer.from(str);
  }
  /**
   * used by the super class BitObject
   */


  static parse(contents) {
    const {
      mainFile,
      dists,
      mainDistFile,
      files,
      compiler,
      bindingPrefix,
      ignoreSharedDir,
      tester,
      log,
      docs,
      ci,
      specsResults,
      dependencies,
      devDependencies,
      flattenedDependencies,
      flattenedDevDependencies,
      devPackageDependencies,
      peerPackageDependencies,
      compilerPackageDependencies,
      testerPackageDependencies,
      packageDependencies,
      customResolvedPaths,
      overrides,
      packageJsonChangedProps,
      extensions
    } = JSON.parse(contents);

    const _getDependencies = (deps = []) => {
      if (deps.length && _ramda().default.is(String, (0, _utils().first)(deps))) {
        // backward compatibility
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        return deps.map(dependency => ({
          id: _bitId().BitId.parseObsolete(dependency)
        }));
      }

      const getRelativePath = relativePath => {
        if (relativePath.importSpecifiers) {
          // backward compatibility. Before the massive validation was added, an item of
          // relativePath.importSpecifiers array could be missing the mainFile property, which is
          // an invalid ImportSpecifier. (instead the mainFile it had another importSpecifiers object).
          relativePath.importSpecifiers = relativePath.importSpecifiers.filter(importSpecifier => importSpecifier.mainFile);
          if (!relativePath.importSpecifiers.length) delete relativePath.importSpecifiers;
        }

        return relativePath;
      };

      return deps.map(dependency => {
        return {
          id: _bitId().BitId.parseBackwardCompatible(dependency.id),
          relativePaths: Array.isArray(dependency.relativePaths) ? dependency.relativePaths.map(getRelativePath) : dependency.relativePaths
        };
      });
    };

    const _getFlattenedDependencies = (deps = []) => {
      return _bitId().BitIds.fromArray(deps.map(dep => _bitId().BitId.parseBackwardCompatible(dep)));
    };

    const parseFile = file => {
      return {
        file: _objects().Ref.from(file.file),
        relativePath: file.relativePath,
        name: file.name,
        test: file.test
      };
    }; // @ts-ignore


    const _getExtensions = (exts = []) => {
      if (exts.length) {
        const newExts = exts.map(extension => {
          if (extension.extensionId) {
            const extensionId = new (_bitId().BitId)(extension.extensionId);
            const entry = new (_extensionData().ExtensionDataEntry)(undefined, extensionId, undefined, extension.config, extension.data);
            return entry;
          }

          const artifacts = (extension.artifacts || []).map(a => ({
            file: _objects().Ref.from(a.file),
            relativePath: a.relativePath
          }));
          const entry = new (_extensionData().ExtensionDataEntry)(extension.id, undefined, extension.name, extension.config, extension.data, artifacts);
          return entry;
        });
        return _extensionData().ExtensionDataList.fromArray(newExts);
      }

      return new (_extensionData().ExtensionDataList)();
    };

    return new Version({
      mainFile,
      files: files ? files.map(parseFile) : null,
      dists: dists ? dists.map(parseFile) : null,
      mainDistFile,
      compiler: compiler ? parseEnv(compiler) : null,
      bindingPrefix: bindingPrefix || null,
      ignoreSharedDir: ignoreSharedDir || undefined,
      tester: tester ? parseEnv(tester) : null,
      log: {
        message: log.message,
        date: log.date,
        username: log.username,
        email: log.email
      },
      ci,
      specsResults,
      docs,
      dependencies: _getDependencies(dependencies),
      devDependencies: _getDependencies(devDependencies),
      flattenedDependencies: _getFlattenedDependencies(flattenedDependencies),
      flattenedDevDependencies: _getFlattenedDependencies(flattenedDevDependencies),
      devPackageDependencies,
      peerPackageDependencies,
      compilerPackageDependencies,
      testerPackageDependencies,
      packageDependencies,
      customResolvedPaths,
      overrides,
      packageJsonChangedProps,
      extensions: _getExtensions(extensions)
    });
  }
  /**
   * used by raw-object.toRealObject()
   */


  static from(versionProps) {
    return Version.parse(JSON.stringify(versionProps));
  }
  /**
   * Create version model object from consumer component
   * @param {*} param0
   */


  static fromComponent({
    component,
    files,
    dists,
    mainDistFile,
    flattenedDependencies,
    flattenedDevDependencies,
    message,
    specsResults,
    extensions,
    username,
    email
  }) {
    const parseFile = file => {
      return {
        file: file.file.hash(),
        relativePath: file.relativePath,
        name: file.name,
        test: file.test
      };
    };

    const compiler = component.compiler ? component.compiler.toModelObject() : undefined;
    const tester = component.tester ? component.tester.toModelObject() : undefined;

    const parseComponentExtensions = () => {
      const extensionsCloned = extensions;
      extensionsCloned.forEach(extensionDataEntry => {
        extensionDataEntry.artifacts = extensionDataEntry.artifacts.map(artifact => {
          return {
            file: artifact.file.hash(),
            relativePath: artifact.relativePath
          };
        });
      });
      return extensionsCloned;
    };

    const compilerDynamicPakageDependencies = component.compiler ? component.compiler.dynamicPackageDependencies : undefined;
    const testerDynamicPakageDependencies = component.tester ? component.tester.dynamicPackageDependencies : undefined;
    return new Version({
      mainFile: component.mainFile,
      files: files.map(parseFile),
      dists: dists ? dists.map(parseFile) : undefined,
      mainDistFile,
      compiler,
      bindingPrefix: component.bindingPrefix,
      tester,
      log: {
        message,
        username,
        email,
        date: Date.now().toString()
      },
      specsResults,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      docs: component.docs,
      dependencies: component.dependencies.get(),
      devDependencies: component.devDependencies.get(),
      packageDependencies: component.packageDependencies,
      devPackageDependencies: component.devPackageDependencies,
      peerPackageDependencies: component.peerPackageDependencies,
      compilerPackageDependencies: _ramda().default.mergeDeepRight(component.compilerPackageDependencies || {}, compilerDynamicPakageDependencies || {}),
      testerPackageDependencies: _ramda().default.mergeDeepRight(component.testerPackageDependencies || {}, testerDynamicPakageDependencies || {}),
      flattenedDependencies,
      flattenedDevDependencies,
      ignoreSharedDir: component.ignoreSharedDir,
      customResolvedPaths: component.customResolvedPaths,
      overrides: component.overrides.componentOverridesData,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageJsonChangedProps: component.packageJsonChangedProps,
      extensions: parseComponentExtensions()
    });
  }

  setSpecsResults(specsResults) {
    this.specsResults = specsResults;
  }

  setDist(dist) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    this.dist = dist ? {
      file: dist.hash(),
      name: _constants().DEFAULT_BUNDLE_FILENAME
    } : null;
  }

  setCIProps(ci) {
    this.ci = ci;
  }

  modelFilesToSourceFiles(repository) {
    return Promise.all(this.files.map(file => _sources().SourceFile.loadFromSourceFileModel(file, repository)));
  }
  /**
   * Validate the version model properties, to make sure we are not inserting something
   * in the wrong format
   */


  validate() {
    (0, _versionValidator().default)(this);
  }

}

exports.default = Version;

function parseEnv(env) {
  if (typeof env === 'string') {
    return env;
  } // Store the env as string in case there is no config and files (for backward compatibility)


  if (envNameOnly(env)) {
    return env.name;
  }

  return {
    name: env.name,
    config: env.config
  };
}

function envNameOnly(env) {
  if ((!env.config || _ramda().default.isEmpty(env.config)) && (!env.files || _ramda().default.isEmpty(env.files))) {
    return true;
  }

  return false;
}